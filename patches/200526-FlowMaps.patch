diff --git a/src/tdme/tests/FlowMapTest.cpp b/src/tdme/tests/FlowMapTest.cpp
index f57410b5..eb719738 100644
--- a/src/tdme/tests/FlowMapTest.cpp
+++ b/src/tdme/tests/FlowMapTest.cpp
@@ -84,7 +84,7 @@ void FlowMapTest::main(int argc, char** argv)
 
 void FlowMapTest::display()
 {
-	if (startPlayerCellPosition.clone().sub(startPlayerObject->getTranslation()).computeLength() < 0.1f){
+	if (startPlayerCellPosition.clone().sub(startPlayerObject->getTranslation()).computeLength() < 0.1f) {
 		auto cell = flowMap->getCell(startPlayerObject->getTranslation().getX(), startPlayerObject->getTranslation().getZ());
 		if (cell != nullptr) {
 			startPlayerCellDirection = cell->getDirection();
@@ -116,14 +116,14 @@ void FlowMapTest::dispose()
 void FlowMapTest::initialize()
 {
 	engine->initialize();
-	LevelFileImport::doImport("resources/tests/levels/pathfinding", "test.tl", &level);
+	LevelFileImport::doImport("resources/tests/levels/pathfinding", "test.2.tl", &level);
 	Level::setLight(engine, &level);
 	Level::addLevel(engine, &level, false, false, false);
 	Level::addLevel(world, &level);
 	auto cam = engine->getCamera();
 	cam->setZNear(0.1f);
 	cam->setZFar(15.0f);
-	cam->setLookFrom(level.getCenter() + Vector3(0.0f, 10.0f, 0.0f));
+	cam->setLookFrom(level.getCenter() + Vector3(0.0f, 20.0f, 0.0f));
 	cam->setLookAt(level.getCenter());
 	cam->setUpVector(cam->computeUpVector(cam->getLookFrom(), cam->getLookAt()));
 	emptyModel = ModelReader::read("resources/engine/tools/leveleditor/models", "empty.dae");
@@ -159,10 +159,10 @@ void FlowMapTest::initialize()
 	endPlayerObject2->setEffectColorAdd(Color4(1.0f, 0.0f, 0.0f, 0.0f));
 	endPlayerObject2->setEffectColorMul(Color4(1.0f, 0.0f, 0.0f, 1.0f));
 	engine->addEntity(endPlayerObject2);
-	pathPositions.push_back(Vector3(-2.5f, 0.25f, -4.5f));
+	pathPositions.push_back(Vector3(-10.5f, 0.25f, -12.0f));
+	pathPositions.push_back(Vector3(10.5f, 0.25f, -12.5f));
 	pathPositions.push_back(Vector3(-2.5f, 0.25f, 0.5f));
-	pathPositions.push_back(Vector3(2.5f, 0.25f, 0.5f));
-	pathPositions.push_back(Vector3(2.5f, 0.25f, -4.5f));
+	pathPositions.push_back(Vector3(10.5f, 0.25f, 0.5f));
 	pathFinding = new PathFinding(world, false, 1000, 2.0f, 0.5f);
 	doPathFinding();
 }
@@ -190,15 +190,23 @@ void FlowMapTest::doPathFinding() {
 	endPlayerObject1->update();
 	endPlayerObject2->setTranslation(pathPositions[(int)(Math::random() * pathPositions.size())]);
 	endPlayerObject2->update();
+	vector<Vector3> path;
+	pathFinding->findPath(
+		startPlayerObject->getTransformations().getTranslation(),
+		endPlayerObject1->getTransformations().getTranslation(),
+		Level::RIGIDBODY_TYPEID_STATIC,
+		path
+	);
+	Console::println("Found a path: steps: " + to_string(path.size()));
 	flowMap = pathFinding->createFlowMap(
 		{
 			endPlayerObject1->getTransformations().getTranslation(),
-			endPlayerObject2->getTransformations().getTranslation()
 		},
-		level.getBoundingBox()->getCenter(),
-		Math::ceil(level.getBoundingBox()->getDimensions().getZ()),
-		Math::ceil(level.getBoundingBox()->getDimensions().getX()),
-		Level::RIGIDBODY_TYPEID_STATIC
+		Vector3(),
+		6.0f,
+		6.0f,
+		Level::RIGIDBODY_TYPEID_STATIC,
+		path
 	);
 	auto i = 0;
 	while(true == true) {
@@ -209,19 +217,18 @@ void FlowMapTest::doPathFinding() {
 	}
 	if (flowMap == nullptr) return;
 	i = 0;
-	auto stepSize = 0.5f;
 	auto center = level.getBoundingBox()->getCenter();
 	auto depth = Math::ceil(level.getBoundingBox()->getDimensions().getZ());
 	auto width = Math::ceil(level.getBoundingBox()->getDimensions().getX());
-	for (auto z = -depth / 2; z < depth / 2; z+= stepSize)
-	for (auto x = -width / 2; x < width / 2; x+= stepSize) {
+	for (auto z = -depth / 2; z <= depth / 2; z+= flowMap->getStepSize())
+	for (auto x = -width / 2; x <= width / 2; x+= flowMap->getStepSize()) {
 		auto cellPosition = Vector3(
 			x + center.getX(),
 			0.0f,
 			z + center.getZ()
 		);
 		auto cell = flowMap->getCell(cellPosition.getX(), cellPosition.getZ());
-		if (cell == nullptr || cell->isWalkable() == false) continue;
+		if (cell == nullptr) continue;
 		auto flowDirectionEntityId = "flowdirection." + to_string(i);
 		auto yRotationAngle = Vector3::computeAngle(Vector3(0.0f, 0.0f, 1.0f), cell->getDirection(), Vector3(0.0f, 1.0f, 0.0f));
 		auto cellObject = new Object3D(flowDirectionEntityId, emptyModel);
@@ -229,6 +236,7 @@ void FlowMapTest::doPathFinding() {
 		cellObject->setTranslation(cellPosition + Vector3(0.0f, 0.25f, 0.0f));
 		cellObject->addRotation(Vector3(0.0f, 1.0f, 0.0f), yRotationAngle - 90.0f);
 		cellObject->setDisableDepthTest(true);
+		if (cell->isWalkable() == false) cellObject->setEffectColorMul(Color4(1.0f, 0.0f, 0.0f, 1.0f));
 		cellObject->update();
 		engine->addEntity(cellObject);
 		i++;
diff --git a/src/tdme/tests/FlowMapTest.h b/src/tdme/tests/FlowMapTest.h
index cc346fba..34734b91 100644
--- a/src/tdme/tests/FlowMapTest.h
+++ b/src/tdme/tests/FlowMapTest.h
@@ -49,7 +49,6 @@ private:
 	Object3D* endPlayerObject2 { nullptr };
 	PathFinding* pathFinding { nullptr };
 	vector<Vector3> pathPositions;
-	vector<Vector3> path;
 	int64_t timeLastUpdate;
 	FlowMap* flowMap { nullptr };
 
diff --git a/src/tdme/utils/FlowMap.h b/src/tdme/utils/FlowMap.h
index 5d86dd40..b282907c 100644
--- a/src/tdme/utils/FlowMap.h
+++ b/src/tdme/utils/FlowMap.h
@@ -5,6 +5,7 @@
 
 #include <tdme/math/Math.h>
 #include <tdme/math/Vector3.h>
+#include <tdme/utils/Console.h>
 #include <tdme/utils/FlowMapCell.h>
 
 using std::map;
@@ -13,6 +14,7 @@ using std::to_string;
 
 using tdme::math::Math;
 using tdme::math::Vector3;
+using tdme::utils::Console;
 using tdme::utils::FlowMapCell;
 
 /**
@@ -28,19 +30,32 @@ private:
 
 	/**
 	 * Adds a cell to flow map
-	 * @param position position
+	 * @param id ud
 	 * @param walkable walkable
 	 * @param direction direction
 	 */
-	inline void addCell(const Vector3& position, bool walkable, const Vector3& direction) {
-		auto cellId = toKey(
-			Math::floor(position.getX() / stepSize) * stepSize,
-			Math::floor(position.getZ() / stepSize) * stepSize
-		);
-		cells[cellId] = FlowMapCell(position, walkable, direction);
+	inline void addCell(const string& id, bool walkable, const Vector3& direction) {
+		Console::println("FlowMap::addCell(): " + id);
+		cells[id] = FlowMapCell(walkable, direction);
 	}
 
 public:
+	/**
+	 * Align position component
+	 * @param value value which is usually a position vector 3 position component
+	 * @param stepSize step size
+	 */
+	inline static float alignPositionComponent(float value, float stepSize) {
+		return Math::floor(value / stepSize) * stepSize;
+	}
+
+	/**
+	 * Align position component
+	 * @param value value which is usually a position vector 3 position component
+	 */
+	inline float alignPositionComponent(float value) const {
+		return alignPositionComponent(value, stepSize);
+	}
 
 	/**
 	 * Return string representation of given x,z for path finding key
@@ -49,6 +64,7 @@ public:
 	 * @return string representation
 	 */
 	inline static string toKey(float x, float z) {
+		/*
 		string result;
 		int32_t value = 0;
 		result.reserve(sizeof(value) * 2);
@@ -57,6 +73,15 @@ public:
 		value = static_cast<int>(z * 10.0f);
 		result.append((char*)&value, sizeof(value));
 		return result;
+		*/
+		string result;
+		int32_t value = 0;
+		value = static_cast<int>(x * 10.0f);
+		result+= to_string(value);
+		result+= ",";
+		value = static_cast<int>(z * 10.0f);
+		result+= to_string(value);
+		return result;
 	}
 
 	/**
@@ -79,8 +104,8 @@ public:
 	 */
 	inline FlowMapCell* getCell(float x, float z) {
 		auto cellId = toKey(
-			Math::floor(x / stepSize) * stepSize,
-			Math::floor(z / stepSize) * stepSize
+			alignPositionComponent(x),
+			alignPositionComponent(z)
 		);
 		auto cellIt = cells.find(cellId);
 		if (cellIt == cells.end()) return nullptr;
@@ -94,8 +119,8 @@ public:
 	 */
 	inline const FlowMapCell* getCell(float x, float z) const {
 		auto cellId = toKey(
-			Math::floor(x / stepSize) * stepSize,
-			Math::floor(z / stepSize) * stepSize
+			alignPositionComponent(x),
+			alignPositionComponent(z)
 		);
 		auto cellIt = cells.find(cellId);
 		if (cellIt == cells.end()) return nullptr;
diff --git a/src/tdme/utils/FlowMapCell.h b/src/tdme/utils/FlowMapCell.h
index a57885f8..1a071cce 100644
--- a/src/tdme/utils/FlowMapCell.h
+++ b/src/tdme/utils/FlowMapCell.h
@@ -19,18 +19,10 @@ public:
 
 	/**
 	 * Private constructor
-	 * @param position position
 	 * @param walkable walkable
 	 * @param direction direction
 	 */
-	FlowMapCell(const Vector3& position, bool walkable, const Vector3& direction): position(position), walkable(walkable), direction(direction) {
-	}
-
-	/**
-	 * @return cell position
-	 */
-	inline const Vector3& getPosition() const {
-		return position;
+	FlowMapCell(bool walkable, const Vector3& direction): walkable(walkable), direction(direction) {
 	}
 
 	/**
@@ -56,7 +48,7 @@ public:
 	}
 
 private:
-	Vector3 position;
+	string id;
 	bool walkable;
 	Vector3 direction;
 };
diff --git a/src/tdme/utils/PathFinding.cpp b/src/tdme/utils/PathFinding.cpp
index 6c76f37e..01c2043d 100644
--- a/src/tdme/utils/PathFinding.cpp
+++ b/src/tdme/utils/PathFinding.cpp
@@ -72,8 +72,15 @@ void PathFinding::reset() {
 }
 
 bool PathFinding::isWalkableInternal(float x, float y, float z, float& height, uint16_t collisionTypeIds, bool ignoreStepUpMax) {
+	auto cacheId = toKey(x, y, z) + ";" + to_string(collisionTypeIds) + ";" + to_string(ignoreStepUpMax);
+	auto walkableCacheIt = walkableCache.find(cacheId);
+	if (walkableCacheIt != walkableCache.end()) {
+		height = walkableCacheIt->second;
+		return height > -10000.0f;
+	}
 	auto walkable = isWalkable(x, y, z, height, collisionTypeIds, ignoreStepUpMax);
 	if (walkable == false) return false;
+	walkableCache[cacheId] = walkable == false?-10000.0f:height;
 	return customTest == nullptr || customTest->isWalkable(this, x, height, z) == true;
 }
 
@@ -517,7 +524,7 @@ bool PathFinding::findPath(const Vector3& startPosition, const Vector3& endPosit
 	return success;
 }
 
-FlowMap* PathFinding::createFlowMap(const vector<Vector3>& endPositions, const Vector3& center, float depth, float width, const uint16_t collisionTypeIds, PathFindingCustomTest* customTest, FlowMap* flowMap) {
+FlowMap* PathFinding::createFlowMap(const vector<Vector3>& endPositions, const Vector3& center, float depth, float width, const uint16_t collisionTypeIds, const vector<Vector3>& path, PathFindingCustomTest* customTest) {
 	// set up custom test
 	this->customTest = customTest;
 
@@ -541,6 +548,10 @@ FlowMap* PathFinding::createFlowMap(const vector<Vector3>& endPositions, const V
 	actorTransformations.update();
 	world->addCollisionBody("tdme.pathfinding.actor", true, 32768, actorTransformations, {actorBoundingVolume});
 
+	const vector<Vector3> emptyPath = { center };
+	const vector<Vector3>& pathToUse = path.empty() == false?path:emptyPath;
+	auto stepSize2 = stepSize + 0.01f;
+
 	// see: https://howtorts.github.io/2014/01/04/basic-flow-fields.html
 	// generate cost map via dijkstra
 	struct DijkstraCellStruct {
@@ -552,34 +563,42 @@ FlowMap* PathFinding::createFlowMap(const vector<Vector3>& endPositions, const V
 	};
 	map<string, DijkstraCellStruct> dijkstraCellMap;
 	vector<DijkstraCellStruct*> dijkstraCellsToProcess;
-	for (auto z = -depth / 2; z < depth / 2; z+= stepSize) {
-		for (auto x = -width / 2; x < width / 2; x+= stepSize) {
-			auto cellPosition = Vector3(
-				Math::floor((x + center.getX()) / stepSize) * stepSize,
-				-10000.0f,
-				Math::floor((z + center.getZ()) / stepSize) * stepSize
-			);
-			auto cellKey = FlowMap::toKey(
-				cellPosition.getX(),
-				cellPosition.getZ()
-			);
-			dijkstraCellMap[cellKey] =
-				{
-					.id = cellKey,
-					.tested = false,
-					.position = cellPosition,
-					.walkable = false,
-					.costs = 0.0f
-				};
+	for (auto& centerPathNode: pathToUse) {
+		for (auto z = -depth / 2.0f; z <= depth / 2.0f; z+= stepSize) {
+			for (auto x = -width / 2.0f; x <= width / 2.0f; x+= stepSize) {
+				auto cellPosition = Vector3(
+					FlowMap::alignPositionComponent(x + centerPathNode.getX(), stepSize),
+					-10000.0f,
+					FlowMap::alignPositionComponent(z + centerPathNode.getZ(), stepSize)
+				);
+				auto cellKey = FlowMap::toKey(
+					cellPosition.getX(),
+					cellPosition.getZ()
+				);
+				auto dijkstraCellIt = dijkstraCellMap.find(cellKey);
+				if (dijkstraCellIt != dijkstraCellMap.end()) continue;
+				dijkstraCellMap[cellKey] =
+					{
+						.id = cellKey,
+						.tested = false,
+						.position = cellPosition,
+						.walkable = false,
+						.costs = 0.0f
+					};
+				if (VERBOSE == true) Console::println("added dijkstra cell: " + cellKey);
+			}
 		}
 	}
 
 	// set up end position in costs map
+	if (endPositions.size() == 0) {
+		Console::println("PathFinding::createFlowMap(): no end positions given");
+	}
 	for (auto& endPosition: endPositions) {
 		auto endPositionGrid = Vector3(
-			Math::floor(endPosition.getX() / stepSize) * stepSize,
+			FlowMap::alignPositionComponent(endPosition.getX(), stepSize),
 			endPosition.getY(),
-			Math::floor(endPosition.getZ() / stepSize) * stepSize
+			FlowMap::alignPositionComponent(endPosition.getZ(), stepSize)
 		);
 		auto endPositionCellKey = FlowMap::toKey(
 			endPositionGrid.getX(),
@@ -605,11 +624,11 @@ FlowMap* PathFinding::createFlowMap(const vector<Vector3>& endPositions, const V
 		for (auto z = -1; z <= 1; z++)
 		for (auto x = -1; x <= 1; x++)
 		if (z != 0 || x != 0) {
-			float neighbourX = x * stepSize + dijkstraCell.position.getX();
-			float neighbourZ = z * stepSize + dijkstraCell.position.getZ();
+			float neighbourX = x * stepSize2 + dijkstraCell.position.getX();
+			float neighbourZ = z * stepSize2 + dijkstraCell.position.getZ();
 			auto neighbourCellKey = FlowMap::toKey(
-				Math::floor(neighbourX / stepSize) * stepSize,
-				Math::floor(neighbourZ / stepSize) * stepSize
+				FlowMap::alignPositionComponent(neighbourX, stepSize),
+				FlowMap::alignPositionComponent(neighbourZ, stepSize)
 			);
 			auto dijkstraNeighbourCellIt = dijkstraCellMap.find(neighbourCellKey);
 			if (dijkstraNeighbourCellIt == dijkstraCellMap.end()) {
@@ -626,89 +645,118 @@ FlowMap* PathFinding::createFlowMap(const vector<Vector3>& endPositions, const V
 				dijkstraNeighbourCell.position.setY(neighbourY);
 				dijkstraNeighbourCell.costs = dijkstraCell.costs + 1.0f;
 				dijkstraCellsToProcess.push_back(&dijkstraNeighbourCell);
+				if (VERBOSE == true) Console::println("is walkable I: " + neighbourCellKey + ": " + to_string(neighbourY));
+			} else {
+				if (VERBOSE == true) Console::println("not walkable I: " + neighbourCellKey + ": " + to_string(neighbourY));
 			}
 		}
 	}
 
 	// generate flow map
-	if (flowMap == nullptr) flowMap = new FlowMap(stepSize);
-	for (auto z = -depth / 2; z < depth / 2; z+= stepSize)
-	for (auto x = -width / 2; x < width / 2; x+= stepSize) {
-		auto cellPosition = Vector3(
-			Math::floor((x + center.getX()) / stepSize) * stepSize,
-			0.0f,
-			Math::floor((z + center.getZ()) / stepSize) * stepSize
-		);
-		auto cellKey = FlowMap::toKey(
-			cellPosition.getX(),
-			cellPosition.getZ()
-		);
-
-		// walkable?
-		auto dijkstraCellIt = dijkstraCellMap.find(cellKey);
-		if (dijkstraCellIt == dijkstraCellMap.end()) {
-			continue;
-		}
-		auto& dijkstraCell = dijkstraCellIt->second;
-		if (dijkstraCell.walkable == false) continue;
-
-		// check neighbours around our current cell
-		DijkstraCellStruct* minDijkstraCell = nullptr;
-		auto minDijkstraCosts = Float::MAX_VALUE;
-		for (auto _z = -1; _z <= 1; _z++)
-		for (auto _x = -1; _x <= 1; _x++)
-		if (_z != 0 || _x != 0) {
-			//
-			float neighbourX = _x * stepSize + cellPosition.getX();
-			float neighbourZ = _z * stepSize + cellPosition.getZ();
-			auto neighbourCellKey = FlowMap::toKey(
-				Math::floor(neighbourX / stepSize) * stepSize,
-				Math::floor(neighbourZ / stepSize) * stepSize
+	auto flowMap = new FlowMap(stepSize);
+	for (auto& centerPathNode: pathToUse) {
+		for (auto z = -depth / 2.0f; z <= depth / 2.0f; z+= stepSize)
+		for (auto x = -width / 2.0f; x <= width / 2.0f; x+= stepSize) {
+			auto cellPosition = Vector3(
+				FlowMap::alignPositionComponent(x + centerPathNode.getX(), stepSize),
+				0.0f,
+				FlowMap::alignPositionComponent(z + centerPathNode.getZ(), stepSize)
 			);
-			auto dijkstraNeighbourCellIt = dijkstraCellMap.find(neighbourCellKey);
-			if (dijkstraNeighbourCellIt == dijkstraCellMap.end()) {
+			auto cellKey = FlowMap::toKey(
+				cellPosition.getX(),
+				cellPosition.getZ()
+			);
+			// walkable?
+			auto dijkstraCellIt = dijkstraCellMap.find(cellKey);
+			if (dijkstraCellIt == dijkstraCellMap.end()) {
 				continue;
-			} else {
-				auto& dijkstraNeighbourCell = dijkstraNeighbourCellIt->second;
-				if (dijkstraNeighbourCell.walkable == true) {
-					auto dijkstraNeighbourCellCosts = dijkstraNeighbourCell.costs - dijkstraCell.costs;
-					if (minDijkstraCell == nullptr || dijkstraNeighbourCellCosts < minDijkstraCosts) {
-						minDijkstraCell = &dijkstraNeighbourCell;
-						minDijkstraCosts = dijkstraNeighbourCellCosts;
+			}
+			auto& dijkstraCell = dijkstraCellIt->second;
+			if (dijkstraCell.walkable == false) continue;
+
+			// check neighbours around our current cell
+			DijkstraCellStruct* minDijkstraCell = nullptr;
+			auto minDijkstraCosts = Float::MAX_VALUE;
+			for (auto _z = -1; _z <= 1; _z++)
+			for (auto _x = -1; _x <= 1; _x++)
+			if (_z != 0 || _x != 0) {
+				//
+				float neighbourX = _x * stepSize2 + cellPosition.getX();
+				float neighbourZ = _z * stepSize2 + cellPosition.getZ();
+				auto neighbourCellKey = FlowMap::toKey(
+					FlowMap::alignPositionComponent(neighbourX, stepSize),
+					FlowMap::alignPositionComponent(neighbourZ, stepSize)
+				);
+				auto dijkstraNeighbourCellIt = dijkstraCellMap.find(neighbourCellKey);
+				if (dijkstraNeighbourCellIt == dijkstraCellMap.end()) {
+					continue;
+				} else {
+					auto& dijkstraNeighbourCell = dijkstraNeighbourCellIt->second;
+					if (dijkstraNeighbourCell.walkable == true) {
+						auto dijkstraNeighbourCellCosts = dijkstraNeighbourCell.costs - dijkstraCell.costs;
+						if (minDijkstraCell == nullptr || dijkstraNeighbourCellCosts < minDijkstraCosts) {
+							minDijkstraCell = &dijkstraNeighbourCell;
+							minDijkstraCosts = dijkstraNeighbourCellCosts;
+
+						}
+						if (VERBOSE == true) Console::println("is walkable II: " + neighbourCellKey);
+					} else {
+						if (VERBOSE == true) Console::println("not walkable II: " + neighbourCellKey);
 					}
 				}
 			}
-		}
-		if (minDijkstraCell != nullptr) {
-			auto direction = minDijkstraCell->position.clone().sub(dijkstraCell.position).setY(0.0f).normalize();
-			flowMap->addCell(
-				cellPosition, 
-				minDijkstraCell->walkable,
-				direction
-			);
+			if (minDijkstraCell != nullptr) {
+				auto direction = minDijkstraCell->position.clone().sub(dijkstraCell.position).setY(0.0f).normalize();
+				if (Float::isNaN(direction.getX()) || Float::isNaN(direction.getY()) || Float::isNaN(direction.getZ())) {
+					Console::println(
+						"NaN: a: " +
+						minDijkstraCell->id + "; " +
+						to_string(minDijkstraCell->position.getX()) + ", " + 
+						to_string(minDijkstraCell->position.getY()) + ", " + 
+						to_string(minDijkstraCell->position.getZ()) + " -> " + 
+						dijkstraCell.id + "; " +
+						to_string(dijkstraCell.position.getX()) + ", " + 
+						to_string(dijkstraCell.position.getY()) + ", " + 
+						to_string(dijkstraCell.position.getZ()) + ": " +
+						to_string(minDijkstraCell == &dijkstraCell) + "; " +
+						to_string(cellPosition.getX()) + ", " + 
+						to_string(cellPosition.getY()) + ", " + 
+						to_string(cellPosition.getZ()) + "; " + 
+						cellKey
+					);
+				}
+				flowMap->addCell(
+					cellKey,
+					minDijkstraCell->walkable,
+					direction
+				);
+				if (VERBOSE == true) Console::println("add cell: " + cellKey);
+			}
 		}
 	}
 
 	// do some post adjustments
-	for (auto z = -depth / 2; z < depth / 2; z+= stepSize)
-	for (auto x = -width / 2; x < width / 2; x+= stepSize) {
-		auto cell = flowMap->getCell(x + center.getX(), z + center.getZ());
-		if (cell == nullptr) continue;
-		auto topCell = flowMap->getCell(x + center.getX(), -1 * stepSize + z + center.getZ());
-		if (topCell == nullptr && cell->getDirection().getZ() < 0.0f){
-			cell->setDirection(cell->getDirection().clone().setZ(0.0f).normalize());
-		}
-		auto bottomCell = flowMap->getCell(x + center.getX(), 1 * stepSize + z + center.getZ());
-		if (bottomCell == nullptr && cell->getDirection().getZ() > 0.0f){
-			cell->setDirection(cell->getDirection().clone().setZ(0.0f).normalize());
-		}
-		auto leftCell = flowMap->getCell(-1 * stepSize + x + center.getX(), z + center.getZ());
-		if (leftCell == nullptr && cell->getDirection().getX() < 0.0f){
-			cell->setDirection(cell->getDirection().clone().setX(0.0f).normalize());
-		}
-		auto rightCell = flowMap->getCell(1 * stepSize + x + center.getX(), z + center.getZ());
-		if (rightCell == nullptr && cell->getDirection().getX() > 0.0f){
-			cell->setDirection(cell->getDirection().clone().setX(0.0f).normalize());
+	for (auto& centerPathNode: pathToUse) {
+		for (auto z = -depth / 2.0f; z <= depth / 2.0f; z+= stepSize)
+		for (auto x = -width / 2.0f; x <= width / 2.0f; x+= stepSize) {
+			auto cell = flowMap->getCell(x + centerPathNode.getX(), z + centerPathNode.getZ());
+			if (cell == nullptr) continue;
+			auto topCell = flowMap->getCell(x + centerPathNode.getX(), -1 * stepSize2 + z + centerPathNode.getZ());
+			if (topCell == nullptr && cell->getDirection().getZ() < 0.0f){
+				cell->setDirection(cell->getDirection().clone().setZ(0.0f).normalize());
+			}
+			auto bottomCell = flowMap->getCell(x + centerPathNode.getX(), 1 * stepSize2 + z + centerPathNode.getZ());
+			if (bottomCell == nullptr && cell->getDirection().getZ() > 0.0f){
+				cell->setDirection(cell->getDirection().clone().setZ(0.0f).normalize());
+			}
+			auto leftCell = flowMap->getCell(-1 * stepSize2 + x + centerPathNode.getX(), z + centerPathNode.getZ());
+			if (leftCell == nullptr && cell->getDirection().getX() < 0.0f){
+				cell->setDirection(cell->getDirection().clone().setX(0.0f).normalize());
+			}
+			auto rightCell = flowMap->getCell(1 * stepSize2 + x + centerPathNode.getX(), z + centerPathNode.getZ());
+			if (rightCell == nullptr && cell->getDirection().getX() > 0.0f){
+				cell->setDirection(cell->getDirection().clone().setX(0.0f).normalize());
+			}
 		}
 	}
 
@@ -716,7 +764,6 @@ FlowMap* PathFinding::createFlowMap(const vector<Vector3>& endPositions, const V
 	this->actorBoundingVolume = nullptr;
 	this->actorBoundingVolumeSlopeTest = nullptr;
 	world->removeBody("tdme.pathfinding.actor");
-	world->removeBody("tdme.pathfinding.actor.slopetest");
 
 	// dispose custom test
 	if (this->customTest != nullptr) {
diff --git a/src/tdme/utils/PathFinding.h b/src/tdme/utils/PathFinding.h
index 6dd81469..90f01a71 100644
--- a/src/tdme/utils/PathFinding.h
+++ b/src/tdme/utils/PathFinding.h
@@ -65,6 +65,20 @@ public:
 	 */
 	~PathFinding();
 
+	/**
+	 * @return step size
+	 */
+	inline float getStepSize() {
+		return stepSize;
+	}
+
+	/**
+	 * Clear caches
+	 */
+	inline void clearCaches() {
+		walkableCache.clear();
+	}
+
 	/**
 	 * Return string representation of given x,y,z for path finding key
 	 * @param x x
@@ -117,10 +131,10 @@ public:
 	 * @param width flow map width
 	 * @param collisionTypeIds collision type ids
 	 * @param customTest custom test
-	 * @param flowMap flow map to add new cells
+	 * @param path path to test along
 	 * @return flow map
 	 */
-	FlowMap* createFlowMap(const vector<Vector3>& endPositions, const Vector3& center, float depth, float width, const uint16_t collisionTypeIds, PathFindingCustomTest* customTest = nullptr, FlowMap* flowMap = nullptr);
+	FlowMap* createFlowMap(const vector<Vector3>& endPositions, const Vector3& center, float depth, float width, const uint16_t collisionTypeIds, const vector<Vector3>& path = vector<Vector3>(), PathFindingCustomTest* customTest = nullptr);
 
 private:
 	/**
@@ -217,4 +231,5 @@ private:
 	map<string, PathFindingNode*> closedNodes;
 	BoundingVolume* actorBoundingVolume { nullptr };
 	BoundingVolume* actorBoundingVolumeSlopeTest { nullptr };
+	map<string, float> walkableCache;
 };
