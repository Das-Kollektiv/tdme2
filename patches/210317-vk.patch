diff --git a/Makefile b/Makefile
index 0ad932a5..a4a80287 100644
--- a/Makefile
+++ b/Makefile
@@ -850,47 +850,8 @@ else
 endif
 
 MAIN_SRCS = \
-	src/tdme/tests/AngleTest-main.cpp \
-	src/tdme/tests/AudioTest-main.cpp \
-	src/tdme/tests/CrashTest-main.cpp \
-	src/tdme/tests/EngineTest-main.cpp \
-	src/tdme/tests/EntityHierarchyTest-main.cpp \
-	src/tdme/tests/HashLinkTest-main.cpp \
-	src/tdme/tests/HTTPClientTest-main.cpp \
-	src/tdme/tests/HTTPDownloadClientTest-main.cpp \
-	src/tdme/tests/LODTest-main.cpp \
-	src/tdme/tests/FlowMapTest-main.cpp \
-	src/tdme/tests/FoliageTest-main.cpp \
-	src/tdme/tests/MathOperatorTest-main.cpp \
-	src/tdme/tests/PathFindingTest-main.cpp \
-	src/tdme/tests/PivotTest-main.cpp \
-	src/tdme/tests/PhysicsTest1-main.cpp \
-	src/tdme/tests/PhysicsTest2-main.cpp \
-	src/tdme/tests/PhysicsTest3-main.cpp \
-	src/tdme/tests/PhysicsTest4-main.cpp \
-	src/tdme/tests/RayTracingTest-main.cpp \
-	src/tdme/tests/SkinningTest-main.cpp \
-	src/tdme/tests/ThreadingTest-main.cpp \
-	src/tdme/tests/TreeTest-main.cpp \
-	src/tdme/tests/UDPClientTest-main.cpp \
-	src/tdme/tests/UDPServerTest-main.cpp \
 	src/tdme/tests/WaterTest-main.cpp \
-	src/tdme/tools/gui/GUITest-main.cpp \
-	src/tdme/tools/installer/Installer-main.cpp \
-	src/tdme/tools/modeleditor/TDMEModelEditor-main.cpp \
-	src/tdme/tools/particlesystem/TDMEParticleSystem-main.cpp \
-	src/tdme/tools/sceneeditor/TDMESceneEditor-main.cpp \
-	src/tdme/tools/terraineditor/TDMETerrainEditor-main.cpp \
-	src/tdme/tools/cli/archive-main.cpp \
-	src/tdme/tools/cli/converttotm-main.cpp \
-	src/tdme/tools/cli/copyanimationsetups-main.cpp \
-	src/tdme/tools/cli/create-installer-main.cpp \
-	src/tdme/tools/cli/fixdoxygen-main.cpp \
-	src/tdme/tools/cli/generatelicenses-main.cpp \
-	src/tdme/tools/cli/importtmm-main.cpp \
-	src/tdme/tools/cli/optimizemodel-main.cpp \
-	src/tdme/tools/cli/scenefixmodelszup2yup-main.cpp \
-	src/tdme/tools/cli/sortincludes-main.cpp
+	src/tdme/tests/PhysicsTest1-main.cpp \
 
 MAINS = $(MAIN_SRCS:$(SRC)/%-main.cpp=$(BIN)/%)
 OBJS = $(SRCS:$(SRC)/%.cpp=$(OBJ)/%.o)
diff --git a/src/tdme/engine/subsystems/renderer/VKRenderer.cpp b/src/tdme/engine/subsystems/renderer/VKRenderer.cpp
index 86302518..b40d2f58 100644
--- a/src/tdme/engine/subsystems/renderer/VKRenderer.cpp
+++ b/src/tdme/engine/subsystems/renderer/VKRenderer.cpp
@@ -443,7 +443,7 @@ inline void VKRenderer::finishSetupCommandBuffers() {
 	for (auto contextIdx = 0; contextIdx < Engine::getThreadCount(); contextIdx++) finishSetupCommandBuffer(contextIdx);
 }
 
-inline void VKRenderer::setImageLayout(int contextIdx, texture_type* textureObject, const array<ThsvsAccessType,2>& nextAccessTypes, ThsvsImageLayout nextLayout, bool discardContent, uint32_t baseLevel, uint32_t levelCount) {
+inline void VKRenderer::setImageLayout(int contextIdx, texture_type* textureObject, const array<ThsvsAccessType,2>& nextAccessTypes, ThsvsImageLayout nextLayout, bool discardContent, uint32_t baseMipLevel, uint32_t levelCount) {
 	auto& context = contexts[contextIdx];
 
 	// does this texture object point to a cube map color/depth buffer texture?
@@ -470,7 +470,7 @@ inline void VKRenderer::setImageLayout(int contextIdx, texture_type* textureObje
 		.image = _textureObject->image,
 		.subresourceRange = {
 			.aspectMask = _textureObject->aspect_mask,
-			.baseMipLevel = baseLevel,
+			.baseMipLevel = baseMipLevel,
 			.levelCount = levelCount,
 			.baseArrayLayer = static_cast<uint32_t>(textureObject->cubemap_buffer_texture != nullptr?textureObject->cubemap_texture_index - CUBEMAPTEXTUREINDEX_MIN:0),
 			.layerCount = 1
@@ -499,6 +499,46 @@ inline void VKRenderer::setImageLayout(int contextIdx, texture_type* textureObje
 	_textureObject->vkLayout = vkImageMemoryBarrier.newLayout;
 }
 
+void VKRenderer::setImageLayout2(int contextIdx, texture_type* textureObject, const array<ThsvsAccessType,2>& accessTypes, const array<ThsvsAccessType,2>& nextAccessTypes, ThsvsImageLayout layout, ThsvsImageLayout nextLayout, bool discardContent, uint32_t baseMipLevel, uint32_t levelCount, uint32_t baseArrayLayer, uint32_t layerCount) {
+	auto& context = contexts[contextIdx];
+
+	ThsvsImageBarrier svsImageBarrier = {
+		.prevAccessCount = static_cast<uint32_t>(accessTypes[1] != THSVS_ACCESS_NONE?2:1),
+		.pPrevAccesses = accessTypes.data(),
+		.nextAccessCount = static_cast<uint32_t>(nextAccessTypes[1] != THSVS_ACCESS_NONE?2:1),
+		.pNextAccesses = nextAccessTypes.data(),
+		.prevLayout = layout,
+		.nextLayout = nextLayout,
+		.discardContents = discardContent,
+		.srcQueueFamilyIndex = 0,
+		.dstQueueFamilyIndex = 0,
+		.image = textureObject->image,
+		.subresourceRange = {
+			.aspectMask = textureObject->aspect_mask,
+			.baseMipLevel = baseMipLevel,
+			.levelCount = levelCount,
+			.baseArrayLayer = baseArrayLayer,
+			.layerCount = layerCount
+		}
+	};
+	VkImageMemoryBarrier vkImageMemoryBarrier;
+	VkPipelineStageFlags srcStages;
+	VkPipelineStageFlags dstStages;
+	thsvsGetVulkanImageMemoryBarrier(
+		svsImageBarrier,
+		&srcStages,
+		&dstStages,
+		&vkImageMemoryBarrier
+	);
+
+	//
+	VkResult err;
+
+	//
+	prepareSetupCommandBuffer(contextIdx);
+	vkCmdPipelineBarrier(context.setup_cmd_inuse, srcStages, dstStages, 0, 0, nullptr, 0, nullptr, 1, &vkImageMemoryBarrier);
+}
+
 inline uint32_t VKRenderer::getMipLevels(Texture* texture) {
 	if (texture->isUseMipMap() == false) return 1;
 	if (texture->getAtlasSize() > 1) {
@@ -1393,9 +1433,22 @@ void VKRenderer::initialize()
 	}};
 	uploadBufferObjectInternal(0, empty_vertex_buffer, bogusVertexBuffer.size() * sizeof(float), (uint8_t*)bogusVertexBuffer.data(), (VkBufferUsageFlagBits)(VK_BUFFER_USAGE_TRANSFER_DST_BIT | VK_BUFFER_USAGE_VERTEX_BUFFER_BIT));
 
-	//
-	white_texture_default_id = Engine::getInstance()->getTextureManager()->addTexture(TextureReader::read("resources/engine/textures", "transparent_pixel.png"), getDefaultContext());
-	white_texture_default = textures.find(white_texture_default_id)->second;
+	// fall back texture white
+	white_texture_sampler2d_default_id = Engine::getInstance()->getTextureManager()->addTexture(TextureReader::read("resources/engine/textures", "transparent_pixel.png"), getDefaultContext());
+	white_texture_sampler2d_default = textures.find(white_texture_sampler2d_default_id)->second;
+
+	// fallback cube map texture white
+	white_texture_samplercube_default_id = Engine::getInstance()->getTextureManager()->addCubeMapTexture(
+		"cubemap-default-white",
+		TextureReader::read("resources/engine/textures", "transparent_pixel.png"),
+		TextureReader::read("resources/engine/textures", "transparent_pixel.png"),
+		TextureReader::read("resources/engine/textures", "transparent_pixel.png"),
+		TextureReader::read("resources/engine/textures", "transparent_pixel.png"),
+		TextureReader::read("resources/engine/textures", "transparent_pixel.png"),
+		TextureReader::read("resources/engine/textures", "transparent_pixel.png"),
+		getDefaultContext()
+	);
+	white_texture_samplercube_default = textures.find(white_texture_samplercube_default_id)->second;
 }
 
 void VKRenderer::initializeRenderPass() {
@@ -4018,7 +4071,7 @@ inline void VKRenderer::setProgramUniformInternal(void* context, int32_t uniform
 		shaderIdx++;
 	}
 	if (changedUniforms == 0) {
-		Console::println("VKRenderer::" + string(__FUNCTION__) + "(): program: no uniform changed");
+		if (VERBOSE == true) Console::println("VKRenderer::" + string(__FUNCTION__) + "(): program: no uniform changed");
 	}
 }
 
@@ -4453,7 +4506,7 @@ void VKRenderer::createColorBufferTexture(int32_t textureId, int32_t width, int3
 {
 	if (VERBOSE == true) Console::println("VKRenderer::" + string(__FUNCTION__) + "(): " + to_string(textureId) + " / " + to_string(width) + "x" + to_string(height) + "(" + to_string(cubeMapTextureId) + " / " + to_string(cubeMapTextureIndex) + ")");
 	auto& colorBufferTexture = *textures.find(textureId)->second;
-	colorBufferTexture.format = format;
+	colorBufferTexture.format = VK_FORMAT_R8G8B8A8_UNORM;
 	colorBufferTexture.width = width;
 	colorBufferTexture.height = height;
 	colorBufferTexture.cubemap_texture_index = cubeMapTextureId == ID_NONE?0:cubeMapTextureIndex;
@@ -4569,11 +4622,154 @@ void VKRenderer::createColorBufferTexture(int32_t textureId, int32_t width, int3
 }
 
 void VKRenderer::uploadCubeMapTexture(void* context, Texture* textureLeft, Texture* textureRight, Texture* textureTop, Texture* textureBottom, Texture* textureFront, Texture* textureBack) {
-	Console::println("VKRenderer::" + string(__FUNCTION__) + "(): Not yet implemented");
+	if (VERBOSE == true) {
+		Console::println(
+			"VKRenderer::" + string(__FUNCTION__) + "(): " +
+			textureLeft->getId() + " / " +
+			textureRight->getId() + " / " +
+			textureTop->getId() + " / " +
+			textureBottom->getId() + " / " +
+			textureFront->getId() + " / " +
+			textureBack->getId()
+		);
+	}
+
+	// have our context typed
+	auto& contextTyped = *static_cast<context_type*>(context);
+
+	//
+	textures_rwlock.writeLock(); // TODO: have a more fine grained locking here
+	auto textureObjectIt = textures.find(contextTyped.bound_textures[contextTyped.texture_unit_active]);
+	if (textureObjectIt == textures.end()) {
+		textures_rwlock.unlock();
+		Console::println("VKRenderer::" + string(__FUNCTION__) + "(): texture not found: " + to_string(contextTyped.bound_textures[contextTyped.texture_unit_active]));
+		return;
+	}
+	auto& texture = *textureObjectIt->second;
+
+	// already uploaded
+	if (texture.uploaded == true) {
+		Console::println("VKRenderer::" + string(__FUNCTION__) + "(): texture already uploaded: " + to_string(contextTyped.bound_textures[contextTyped.texture_unit_active]));
+		textures_rwlock.unlock();
+		return;
+	}
+
+	texture.type = texture_type::TYPE_CUBEMAP;
+	texture.width = textureLeft->getTextureWidth();
+	texture.height = textureLeft->getTextureHeight();
+	texture.format = VK_FORMAT_R8G8B8A8_UNORM;
+	texture.aspect_mask = VK_IMAGE_ASPECT_COLOR_BIT;
+	texture.access_types = { THSVS_ACCESS_HOST_PREINITIALIZED, THSVS_ACCESS_NONE };
+	texture.vkLayout = VK_IMAGE_LAYOUT_PREINITIALIZED;
+
+	// create color buffer texture
+	//	TODO: no general
+	const VkImageCreateInfo image_create_info = {
+		.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO,
+		.pNext = nullptr,
+		.flags = VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT,
+		.imageType = VK_IMAGE_TYPE_2D,
+		.format = texture.format,
+		.extent = {
+			.width = texture.width,
+			.height = texture.height,
+			.depth = 1
+		},
+		.mipLevels = 1,
+		.arrayLayers = 6,
+		.samples = VK_SAMPLE_COUNT_1_BIT,
+		.tiling = VK_IMAGE_TILING_OPTIMAL,
+		.usage = VK_IMAGE_USAGE_SAMPLED_BIT | VK_IMAGE_USAGE_TRANSFER_DST_BIT,
+		.sharingMode = VK_SHARING_MODE_EXCLUSIVE,
+		.queueFamilyIndexCount = 0,
+		.pQueueFamilyIndices = 0,
+		.initialLayout = VK_IMAGE_LAYOUT_PREINITIALIZED,
+	};
+
+	//
+	VkResult err;
+
+	VmaAllocationCreateInfo image_alloc_create_info = {};
+	image_alloc_create_info.usage = VMA_MEMORY_USAGE_GPU_ONLY;
+
+	VmaAllocationInfo allocation_info = {};
+	err = vmaCreateImage(allocator, &image_create_info, &image_alloc_create_info, &texture.image, &texture.allocation, &allocation_info);
+	assert(!err);
+
+	//
+	uploadCubeMapSingleTexture(context, &texture, textureLeft, 0);
+	uploadCubeMapSingleTexture(context, &texture, textureRight, 1);
+	uploadCubeMapSingleTexture(context, &texture, textureTop, 2);
+	uploadCubeMapSingleTexture(context, &texture, textureBottom, 3);
+	uploadCubeMapSingleTexture(context, &texture, textureFront, 4);
+	uploadCubeMapSingleTexture(context, &texture, textureBack, 5);
+
+	texture.access_types = { THSVS_ACCESS_FRAGMENT_SHADER_READ_SAMPLED_IMAGE_OR_UNIFORM_TEXEL_BUFFER, THSVS_ACCESS_NONE };
+	texture.vkLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
+
+	// create sampler
+	const VkSamplerCreateInfo sampler = {
+		.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,
+		.pNext = nullptr,
+		.flags = 0,
+		.magFilter = VK_FILTER_LINEAR,
+		.minFilter = VK_FILTER_LINEAR,
+		.mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST,
+		.addressModeU = VK_SAMPLER_ADDRESS_MODE_REPEAT,
+		.addressModeV = VK_SAMPLER_ADDRESS_MODE_REPEAT,
+		.addressModeW = VK_SAMPLER_ADDRESS_MODE_REPEAT,
+		.mipLodBias = 0.0f,
+		.anisotropyEnable = VK_FALSE,
+		.maxAnisotropy = 1,
+		.compareEnable = VK_FALSE,
+		.compareOp = VK_COMPARE_OP_NEVER,
+		.minLod = 0.0f,
+		.maxLod = 0.0f,
+		.borderColor = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE,
+		.unnormalizedCoordinates = VK_FALSE,
+	};
+	err = vkCreateSampler(device, &sampler, nullptr, &texture.sampler);
+	assert(!err);
+
+	// create image view
+	VkImageViewCreateInfo view = {
+		.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
+		.pNext = nullptr,
+		.flags = 0,
+		.image = texture.image,
+		.viewType = VK_IMAGE_VIEW_TYPE_CUBE,
+		.format = texture.format,
+		.components = {
+			.r = VK_COMPONENT_SWIZZLE_R,
+			.g = VK_COMPONENT_SWIZZLE_G,
+			.b = VK_COMPONENT_SWIZZLE_B,
+			.a = VK_COMPONENT_SWIZZLE_A,
+		},
+		.subresourceRange = {
+			.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
+			.baseMipLevel = 0,
+			.levelCount = 1,
+			.baseArrayLayer = 0,
+			.layerCount = 6
+		}
+	};
+	err = vkCreateImageView(device, &view, nullptr, &texture.view);
+	assert(!err);
+
+	//
+	texture.uploaded = true;
+
+	//
+	textures_rwlock.unlock();
 }
 
 int32_t VKRenderer::createCubeMapTexture(void* context, int32_t width, int32_t height) {
 	if (VERBOSE == true) Console::println("VKRenderer::" + string(__FUNCTION__) + "()");
+
+	// have our context typed
+	auto& contextTyped = *static_cast<context_type*>(context);
+
+	//
 	auto texturePtr = new texture_type();
 	textures_rwlock.writeLock();
 	auto reuseTextureId = -1;
@@ -4586,6 +4782,7 @@ int32_t VKRenderer::createCubeMapTexture(void* context, int32_t width, int32_t h
 	texture.type = texture_type::TYPE_CUBEMAP;
 	texture.width = width;
 	texture.height = height;
+	texture.aspect_mask = VK_IMAGE_ASPECT_COLOR_BIT;
 	texture.vkLayout = VK_IMAGE_LAYOUT_GENERAL;
 	textures[texture.id] = texturePtr;
 
@@ -4619,7 +4816,7 @@ int32_t VKRenderer::createCubeMapTexture(void* context, int32_t width, int32_t h
 			.sharingMode = VK_SHARING_MODE_EXCLUSIVE,
 			.queueFamilyIndexCount = 0,
 			.pQueueFamilyIndices = 0,
-			.initialLayout = VK_IMAGE_LAYOUT_GENERAL,
+			.initialLayout = VK_IMAGE_LAYOUT_UNDEFINED,
 		};
 
 		//
@@ -4682,6 +4879,20 @@ int32_t VKRenderer::createCubeMapTexture(void* context, int32_t width, int32_t h
 		assert(!err);
 	}
 
+	setImageLayout2(
+		contextTyped.idx,
+		texture.cubemap_colorbuffer,
+		{ THSVS_ACCESS_NONE, THSVS_ACCESS_NONE },
+		{ THSVS_ACCESS_NONE, THSVS_ACCESS_NONE },
+		THSVS_IMAGE_LAYOUT_OPTIMAL,
+		THSVS_IMAGE_LAYOUT_GENERAL,
+		false,
+		0,
+		1,
+		0,
+		6
+	);
+
 	// create depth buffer texture
 	//	TODO: only create on demand
 	{
@@ -4723,29 +4934,6 @@ int32_t VKRenderer::createCubeMapTexture(void* context, int32_t width, int32_t h
 		VmaAllocationInfo allocation_info = {};
 		err = vmaCreateImage(allocator, &image_create_info, &image_alloc_create_info, &texture.cubemap_depthbuffer->image, &texture.cubemap_depthbuffer->allocation, &allocation_info);
 		assert(!err);
-
-		/*
-		// TODO: we do not need this view AFAIK
-		// create image view
-		VkImageViewCreateInfo view = {
-			.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
-			.pNext = nullptr,
-			.flags = 0,
-			.image = texture.cubemap_depthbuffer->image,
-			.viewType = VK_IMAGE_VIEW_TYPE_CUBE,
-			.format = texture.cubemap_depthbuffer->format,
-			.components = VkComponentMapping(),
-			.subresourceRange = {
-				.aspectMask = VK_IMAGE_ASPECT_DEPTH_BIT,
-				.baseMipLevel = 0,
-				.levelCount = 1,
-				.baseArrayLayer = 0,
-				.layerCount = 6
-			},
-		};
-		err = vkCreateImageView(device, &view, nullptr, &texture.view);
-		assert(!err);
-		*/
 	}
 
 	//
@@ -5029,6 +5217,150 @@ void VKRenderer::uploadTexture(void* context, Texture* texture)
 	AtomicOperations::increment(statistics.textureUploads);
 }
 
+void VKRenderer::uploadCubeMapSingleTexture(void* context, texture_type* cubemapTextureType, Texture* texture, uint32_t baseArrayLayer)
+{
+	if (VERBOSE == true) Console::println("VKRenderer::" + string(__FUNCTION__) + "(): " + texture->getId());
+
+	// have our context typed
+	auto& contextTyped = *static_cast<context_type*>(context);
+	auto& cubemap_texture_type = *cubemapTextureType;
+
+	//
+	const VkFormat tex_format = texture->getHeight() == 32?VK_FORMAT_R8G8B8A8_UNORM:VK_FORMAT_R8G8B8A8_UNORM;
+	VkFormatProperties props;
+	VkResult err;
+	vkGetPhysicalDeviceFormatProperties(gpu, tex_format, &props);
+	if ((props.optimalTilingFeatures & VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT) == VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT) {
+		// we need a setup command buffer here
+		prepareSetupCommandBuffer(contextTyped.idx);
+
+		//
+		struct texture_type staging_texture;
+		memset(&staging_texture, 0, sizeof(staging_texture));
+		staging_texture.width = texture->getTextureWidth();
+		staging_texture.height = texture->getTextureHeight();
+		staging_texture.type = texture_type::TYPE_TEXTURE;
+		staging_texture.aspect_mask = VK_IMAGE_ASPECT_COLOR_BIT;
+
+		//
+		prepareTextureImage(
+			contextTyped.idx,
+			&staging_texture,
+			VK_IMAGE_TILING_LINEAR,
+			VK_IMAGE_USAGE_TRANSFER_SRC_BIT,
+			VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT,
+			texture,
+			{ THSVS_ACCESS_TRANSFER_READ, THSVS_ACCESS_NONE },
+			THSVS_IMAGE_LAYOUT_OPTIMAL
+		);
+
+		//
+		setImageLayout2(
+			contextTyped.idx,
+			&cubemap_texture_type,
+			{ THSVS_ACCESS_HOST_PREINITIALIZED, THSVS_ACCESS_NONE },
+			{ THSVS_ACCESS_TRANSFER_WRITE, THSVS_ACCESS_NONE },
+			THSVS_IMAGE_LAYOUT_OPTIMAL,
+			THSVS_IMAGE_LAYOUT_OPTIMAL,
+			true,
+			0,
+			1,
+			baseArrayLayer,
+			1
+		);
+
+		//
+		VkImageCopy copy_region = {
+			.srcSubresource = {
+				.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
+				.mipLevel = 0,
+				.baseArrayLayer = 0,
+				.layerCount = 1
+			},
+			.srcOffset = {
+				.x = 0,
+				.y = 0,
+				.z = 0
+			},
+			.dstSubresource = {
+				.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
+				.mipLevel = 0,
+				.baseArrayLayer = baseArrayLayer,
+				.layerCount = 1
+			},
+			.dstOffset = {
+				.x = 0,
+				.y = 0,
+				.z = 0
+			},
+			.extent = {
+				.width = cubemap_texture_type.width,
+				.height = cubemap_texture_type.height,
+				.depth = 1
+			}
+		};
+		vkCmdCopyImage(
+			contextTyped.setup_cmd_inuse,
+			staging_texture.image,
+			VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL,
+			cubemap_texture_type.image,
+			VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL,
+			1,
+			&copy_region
+		);
+
+		//
+		setImageLayout2(
+			contextTyped.idx,
+			&cubemap_texture_type,
+			{ THSVS_ACCESS_TRANSFER_WRITE, THSVS_ACCESS_NONE },
+			{ THSVS_ACCESS_FRAGMENT_SHADER_READ_SAMPLED_IMAGE_OR_UNIFORM_TEXEL_BUFFER, THSVS_ACCESS_NONE },
+			THSVS_IMAGE_LAYOUT_OPTIMAL,
+			THSVS_IMAGE_LAYOUT_OPTIMAL,
+			false,
+			0,
+			1,
+			baseArrayLayer,
+			1
+		);
+
+		// mark for deletion
+		delete_mutex.lock();
+		delete_images.push_back(
+			{
+				.image = staging_texture.image,
+				.allocation = staging_texture.allocation,
+				.image_view = VK_NULL_HANDLE,
+				.sampler = VK_NULL_HANDLE
+			}
+		);
+		delete_mutex.unlock();
+
+		//
+		finishSetupCommandBuffer(contextTyped.idx);
+	} else
+	if ((props.linearTilingFeatures & VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT) == VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT) {
+		// Device can texture using linear textures
+		prepareTextureImage(
+			contextTyped.idx,
+			&cubemap_texture_type,
+			VK_IMAGE_TILING_LINEAR,
+			VK_IMAGE_USAGE_SAMPLED_BIT,
+			VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT,
+			texture,
+			{ THSVS_ACCESS_FRAGMENT_SHADER_READ_SAMPLED_IMAGE_OR_UNIFORM_TEXEL_BUFFER, THSVS_ACCESS_NONE },
+			THSVS_IMAGE_LAYOUT_OPTIMAL
+		);
+		finishSetupCommandBuffer(contextTyped.idx);
+	} else {
+		// Can't support VK_FORMAT_B8G8R8A8_UNORM !?
+		assert(!"No support for B8G8R8A8_UNORM as texture image format");
+	}
+
+	//
+	AtomicOperations::increment(statistics.textureUploads);
+}
+
 void VKRenderer::resizeDepthBufferTexture(int32_t textureId, int32_t width, int32_t height)
 {
 	if (VERBOSE == true) Console::println("VKRenderer::" + string(__FUNCTION__) + "(): " + to_string(textureId) + " / " + to_string(width) + "x" + to_string(height));
@@ -5660,7 +5992,7 @@ inline VKRenderer::texture_type* VKRenderer::getTextureInternal(int contextIdx,
 		auto& contextTyped = contexts[contextIdx];
 		texture = contextTyped.texture_vector[textureId];
 		if (texture != nullptr) {
-			if (texture->type == texture_type::TYPE_TEXTURE && texture->uploaded == false) return white_texture_default;
+			if (texture->type == texture_type::TYPE_TEXTURE && texture->uploaded == false) return white_texture_sampler2d_default;
 			return texture;
 		}
 
@@ -5670,7 +6002,7 @@ inline VKRenderer::texture_type* VKRenderer::getTextureInternal(int contextIdx,
 	if (textureIt == textures.end()) {
 		textures_rwlock.unlock();
 		Console::println("VKRenderer::" + string(__FUNCTION__) + "(): texture with id " + to_string(textureId) + " does not exist");
-		return white_texture_default;
+		return white_texture_sampler2d_default;
 	}
 	// we have a texture, also place it in context
 	texture = textureIt->second;
@@ -5795,10 +6127,16 @@ inline void VKRenderer::drawInstancedTrianglesFromBufferObjects(void* context, i
 	for (auto i = 0; i < contextTyped.bound_textures.size(); i++) {
 		auto textureId = contextTyped.bound_textures[i];
 		auto& texture = contextTyped.objects_render_command.textures[i];
-		auto& textureObject = textureId != ID_NONE?*getTextureInternal(contextTyped.idx, textureId):*white_texture_default;
-		texture.sampler = textureObject.sampler;
-		texture.view = textureObject.view;
-		texture.layout = textureObject.vkLayout;
+		if (textureId == ID_NONE) {
+			texture.sampler = VK_NULL_HANDLE;
+			texture.view = VK_NULL_HANDLE;
+			texture.layout = VK_IMAGE_LAYOUT_UNDEFINED;
+		} else {
+			auto& textureObject = *getTextureInternal(contextTyped.idx, textureId);
+			texture.sampler = textureObject.sampler;
+			texture.view = textureObject.view;
+			texture.layout = textureObject.vkLayout;
+		}
 	}
 
 	// ubos
@@ -5949,18 +6287,54 @@ inline void VKRenderer::executeCommand(int contextIdx) {
 			// sampler2D + samplerCube
 			for (auto uniform: shader->samplerUniformList) {
 				if (uniform->texture_unit == -1) {
-					texDescs[samplerIdx] = {
-						.sampler = white_texture_default->sampler,
-						.imageView = white_texture_default->view,
-						.imageLayout = white_texture_default->vkLayout
-					};
+					switch(uniform->type) {
+						case shader_type::uniform_type::TYPE_SAMPLER2D:
+							texDescs[samplerIdx] = {
+								.sampler = white_texture_sampler2d_default->sampler,
+								.imageView = white_texture_sampler2d_default->view,
+								.imageLayout = white_texture_sampler2d_default->vkLayout
+							};
+							break;
+						case shader_type::uniform_type::TYPE_SAMPLERCUBE:
+							texDescs[samplerIdx] = {
+								.sampler = white_texture_samplercube_default->sampler,
+								.imageView = white_texture_samplercube_default->view,
+								.imageLayout = white_texture_samplercube_default->vkLayout
+							};
+							break;
+						default:
+							Console::println("VKRenderer::" + string(__FUNCTION__) + "(): object command: unknown sampler: " + to_string(uniform->type));
+							break;
+					}
 				} else {
 					auto& texture = contextTyped.objects_render_command.textures[uniform->texture_unit];
-					texDescs[samplerIdx] = {
-						.sampler = texture.sampler,
-						.imageView = texture.view,
-						.imageLayout = texture.layout
-					};
+					if (texture.view == VK_NULL_HANDLE) {
+						switch(uniform->type) {
+							case shader_type::uniform_type::TYPE_SAMPLER2D:
+								texDescs[samplerIdx] = {
+									.sampler = white_texture_sampler2d_default->sampler,
+									.imageView = white_texture_sampler2d_default->view,
+									.imageLayout = white_texture_sampler2d_default->vkLayout
+								};
+								break;
+							case shader_type::uniform_type::TYPE_SAMPLERCUBE:
+								texDescs[samplerIdx] = {
+									.sampler = white_texture_samplercube_default->sampler,
+									.imageView = white_texture_samplercube_default->view,
+									.imageLayout = white_texture_samplercube_default->vkLayout
+								};
+								break;
+							default:
+								Console::println("VKRenderer::" + string(__FUNCTION__) + "(): object command: unknown sampler: " + to_string(uniform->type));
+								break;
+						}
+					} else {
+						texDescs[samplerIdx] = {
+							.sampler = texture.sampler,
+							.imageView = texture.view,
+							.imageLayout = texture.layout
+						};
+					}
 				}
 				descriptorSetWrites[uniform->position] = {
 					.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
@@ -6042,18 +6416,54 @@ inline void VKRenderer::executeCommand(int contextIdx) {
 			// sampler2D + samplerCube
 			for (auto uniform: shader->samplerUniformList) {
 				if (uniform->texture_unit == -1) {
-					texDescs[samplerIdx] = {
-						.sampler = white_texture_default->sampler,
-						.imageView = white_texture_default->view,
-						.imageLayout = white_texture_default->vkLayout
-					};
+					switch(uniform->type) {
+						case shader_type::uniform_type::TYPE_SAMPLER2D:
+							texDescs[samplerIdx] = {
+								.sampler = white_texture_sampler2d_default->sampler,
+								.imageView = white_texture_sampler2d_default->view,
+								.imageLayout = white_texture_sampler2d_default->vkLayout
+							};
+							break;
+						case shader_type::uniform_type::TYPE_SAMPLERCUBE:
+							texDescs[samplerIdx] = {
+								.sampler = white_texture_samplercube_default->sampler,
+								.imageView = white_texture_samplercube_default->view,
+								.imageLayout = white_texture_samplercube_default->vkLayout
+							};
+							break;
+						default:
+							Console::println("VKRenderer::" + string(__FUNCTION__) + "(): object command: unknown sampler: " + to_string(uniform->type));
+							break;
+					}
 				} else {
 					auto& texture = contextTyped.points_render_command.textures[uniform->texture_unit];
-					texDescs[samplerIdx] = {
-						.sampler = texture.sampler,
-						.imageView = texture.view,
-						.imageLayout = texture.layout
-					};
+					if (texture.view == VK_NULL_HANDLE) {
+						switch(uniform->type) {
+							case shader_type::uniform_type::TYPE_SAMPLER2D:
+								texDescs[samplerIdx] = {
+									.sampler = white_texture_sampler2d_default->sampler,
+									.imageView = white_texture_sampler2d_default->view,
+									.imageLayout = white_texture_sampler2d_default->vkLayout
+								};
+								break;
+							case shader_type::uniform_type::TYPE_SAMPLERCUBE:
+								texDescs[samplerIdx] = {
+									.sampler = white_texture_samplercube_default->sampler,
+									.imageView = white_texture_samplercube_default->view,
+									.imageLayout = white_texture_samplercube_default->vkLayout
+								};
+								break;
+							default:
+								Console::println("VKRenderer::" + string(__FUNCTION__) + "(): object command: unknown sampler: " + to_string(uniform->type));
+								break;
+						}
+					} else {
+						texDescs[samplerIdx] = {
+							.sampler = texture.sampler,
+							.imageView = texture.view,
+							.imageLayout = texture.layout
+						};
+					}
 				}
 				descriptorSetWrites[uniform->position] = {
 					.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
@@ -6129,18 +6539,54 @@ inline void VKRenderer::executeCommand(int contextIdx) {
 			// sampler2D + samplerCube
 			for (auto uniform: shader->samplerUniformList) {
 				if (uniform->texture_unit == -1) {
-					texDescs[samplerIdx] = {
-						.sampler = white_texture_default->sampler,
-						.imageView = white_texture_default->view,
-						.imageLayout = white_texture_default->vkLayout
-					};
+					switch(uniform->type) {
+						case shader_type::uniform_type::TYPE_SAMPLER2D:
+							texDescs[samplerIdx] = {
+								.sampler = white_texture_sampler2d_default->sampler,
+								.imageView = white_texture_sampler2d_default->view,
+								.imageLayout = white_texture_sampler2d_default->vkLayout
+							};
+							break;
+						case shader_type::uniform_type::TYPE_SAMPLERCUBE:
+							texDescs[samplerIdx] = {
+								.sampler = white_texture_samplercube_default->sampler,
+								.imageView = white_texture_samplercube_default->view,
+								.imageLayout = white_texture_samplercube_default->vkLayout
+							};
+							break;
+						default:
+							Console::println("VKRenderer::" + string(__FUNCTION__) + "(): object command: unknown sampler: " + to_string(uniform->type));
+							break;
+					}
 				} else {
 					auto& texture = contextTyped.lines_render_command.textures[uniform->texture_unit];
-					texDescs[samplerIdx] = {
-						.sampler = texture.sampler,
-						.imageView = texture.view,
-						.imageLayout = texture.layout
-					};
+					if (texture.view == VK_NULL_HANDLE) {
+						switch(uniform->type) {
+							case shader_type::uniform_type::TYPE_SAMPLER2D:
+								texDescs[samplerIdx] = {
+									.sampler = white_texture_sampler2d_default->sampler,
+									.imageView = white_texture_sampler2d_default->view,
+									.imageLayout = white_texture_sampler2d_default->vkLayout
+								};
+								break;
+							case shader_type::uniform_type::TYPE_SAMPLERCUBE:
+								texDescs[samplerIdx] = {
+									.sampler = white_texture_samplercube_default->sampler,
+									.imageView = white_texture_samplercube_default->view,
+									.imageLayout = white_texture_samplercube_default->vkLayout
+								};
+								break;
+							default:
+								Console::println("VKRenderer::" + string(__FUNCTION__) + "(): object command: unknown sampler: " + to_string(uniform->type));
+								break;
+						}
+					} else {
+						texDescs[samplerIdx] = {
+							.sampler = texture.sampler,
+							.imageView = texture.view,
+							.imageLayout = texture.layout
+						};
+					}
 				}
 				descriptorSetWrites[uniform->position] = {
 					.sType = VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET,
@@ -6311,10 +6757,16 @@ void VKRenderer::drawPointsFromBufferObjects(void* context, int32_t points, int3
 	for (auto i = 0; i < contextTyped.bound_textures.size(); i++) {
 		auto textureId = contextTyped.bound_textures[i];
 		auto& texture = contextTyped.points_render_command.textures[i];
-		auto& textureObject = textureId != ID_NONE?*getTextureInternal(contextTyped.idx, textureId):*white_texture_default;
-		texture.sampler = textureObject.sampler;
-		texture.view = textureObject.view;
-		texture.layout = textureObject.vkLayout;
+		if (textureId == ID_NONE) {
+			texture.sampler = VK_NULL_HANDLE;
+			texture.view = VK_NULL_HANDLE;
+			texture.layout = VK_IMAGE_LAYOUT_UNDEFINED;
+		} else {
+			auto& textureObject = *getTextureInternal(contextTyped.idx, textureId);
+			texture.sampler = textureObject.sampler;
+			texture.view = textureObject.view;
+			texture.layout = textureObject.vkLayout;
+		}
 	}
 
 	// ubos
@@ -6373,10 +6825,16 @@ void VKRenderer::drawLinesFromBufferObjects(void* context, int32_t points, int32
 	for (auto i = 0; i < contextTyped.bound_textures.size(); i++) {
 		auto textureId = contextTyped.bound_textures[i];
 		auto& texture = contextTyped.lines_render_command.textures[i];
-		auto& textureObject = textureId != ID_NONE?*getTextureInternal(contextTyped.idx, textureId):*white_texture_default;
-		texture.sampler = textureObject.sampler;
-		texture.view = textureObject.view;
-		texture.layout = textureObject.vkLayout;
+		if (textureId == ID_NONE) {
+			texture.sampler = VK_NULL_HANDLE;
+			texture.view = VK_NULL_HANDLE;
+			texture.layout = VK_IMAGE_LAYOUT_UNDEFINED;
+		} else {
+			auto& textureObject = *getTextureInternal(contextTyped.idx, textureId);
+			texture.sampler = textureObject.sampler;
+			texture.view = textureObject.view;
+			texture.layout = textureObject.vkLayout;
+		}
 	}
 
 	// ubos
diff --git a/src/tdme/engine/subsystems/renderer/VKRenderer.h b/src/tdme/engine/subsystems/renderer/VKRenderer.h
index 666da860..a96f1f95 100644
--- a/src/tdme/engine/subsystems/renderer/VKRenderer.h
+++ b/src/tdme/engine/subsystems/renderer/VKRenderer.h
@@ -388,8 +388,10 @@ private:
 	buffer_object_type* empty_vertex_buffer { nullptr };
 	int empty_vertex_buffer_id { 0 };
 	int depth_buffer_default { 0 };
-	int white_texture_default_id { 0 };
-	texture_type* white_texture_default { nullptr };
+	int white_texture_sampler2d_default_id { 0 };
+	texture_type* white_texture_sampler2d_default { nullptr };
+	int white_texture_samplercube_default_id { 0 };
+	texture_type* white_texture_samplercube_default { nullptr };
 
 	VkDescriptorPool desc_pool { VK_NULL_HANDLE };
 
@@ -435,7 +437,8 @@ private:
 
 	//
 	VkBool32 checkLayers(uint32_t check_count, const char **check_names, uint32_t layer_count, VkLayerProperties *layers);
-	void setImageLayout(int contextIdx, texture_type* textureObject, const array<ThsvsAccessType,2>& nextAccessTypes, ThsvsImageLayout nextLayout, bool discardContent, uint32_t baseLevel = 0, uint32_t levelCount = 1);
+	void setImageLayout(int contextIdx, texture_type* textureObject, const array<ThsvsAccessType,2>& nextAccessTypes, ThsvsImageLayout nextLayout, bool discardContent, uint32_t baseMipLevel = 0, uint32_t levelCount = 1);
+	void setImageLayout2(int contextIdx, texture_type* textureObject, const array<ThsvsAccessType,2>& accessTypes, const array<ThsvsAccessType,2>& nextAccessTypes, ThsvsImageLayout layout, ThsvsImageLayout nextLayout, bool discardContent, uint32_t baseMipLevel, uint32_t levelCount, uint32_t baseArrayLayer, uint32_t layerCount);
 	uint32_t getMipLevels(Texture* texture);
 	void prepareTextureImage(int contextIdx, struct texture_type* textureObject, VkImageTiling tiling, VkImageUsageFlags usage, VkFlags requiredFlags, Texture* texture, const array<ThsvsAccessType,2>& nextAccesses, ThsvsImageLayout imageLayout, bool disableMipMaps = true, uint32_t baseLevel = 0, uint32_t levelCount = 1);
 	VkBuffer getBufferObjectInternal(int contextIdx,  int32_t bufferObjectId, uint32_t& size);
@@ -498,6 +501,8 @@ private:
 	array<VkCommandBuffer, 3> endDrawCommandBuffer(int contextIdx, int bufferId = -1, bool cycleBuffers = true);
 	void submitDrawCommandBuffers(int commandBufferCount, VkCommandBuffer* commandBuffers, VkFence& fence, bool waitUntilSubmitted = false, bool resetFence = true);
 	void recreateContextFences(int contextIdx);
+	void uploadCubeMapSingleTexture(void* context, texture_type* cubemapTextureType, Texture* texture, uint32_t baseArrayLayer);
+
 protected:
 	/**
 	 * Protected constructor
