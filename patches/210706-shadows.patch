diff --git a/Makefile b/Makefile
index 0d6fbac9..0f92f806 100644
--- a/Makefile
+++ b/Makefile
@@ -911,24 +911,6 @@ MAIN_SRCS = \
 	src/tdme/tests/UDPClientTest-main.cpp \
 	src/tdme/tests/UDPServerTest-main.cpp \
 	src/tdme/tests/WaterTest-main.cpp \
-	src/tdme/tools/editor/TDMEEditor-main.cpp \
-	src/tdme/tools/gui/GUITest-main.cpp \
-	src/tdme/tools/installer/Installer-main.cpp \
-	src/tdme/tools/modeleditor/TDMEModelEditor-main.cpp \
-	src/tdme/tools/particlesystem/TDMEParticleSystem-main.cpp \
-	src/tdme/tools/sceneeditor/TDMESceneEditor-main.cpp \
-	src/tdme/tools/terraineditor/TDMETerrainEditor-main.cpp \
-	src/tdme/tools/cli/archive-main.cpp \
-	src/tdme/tools/cli/converttotm-main.cpp \
-	src/tdme/tools/cli/copyanimationsetups-main.cpp \
-	src/tdme/tools/cli/create-installer-main.cpp \
-	src/tdme/tools/cli/fixdoxygen-main.cpp \
-	src/tdme/tools/cli/generatelicenses-main.cpp \
-	src/tdme/tools/cli/importtmodel-main.cpp \
-	src/tdme/tools/cli/makefilegenerator-main.cpp \
-	src/tdme/tools/cli/optimizemodel-main.cpp \
-	src/tdme/tools/cli/scenefixmodelszup2yup-main.cpp \
-	src/tdme/tools/cli/sortincludes-main.cpp
 
 MAINS = $(MAIN_SRCS:$(SRC)/%-main.cpp=$(BIN)/%)
 OBJS = $(SRCS:$(SRC)/%.cpp=$(OBJ)/%.o)
diff --git a/src/tdme/engine/Camera.cpp b/src/tdme/engine/Camera.cpp
index 08102aa9..299e21d4 100644
--- a/src/tdme/engine/Camera.cpp
+++ b/src/tdme/engine/Camera.cpp
@@ -25,6 +25,8 @@ Camera::Camera(Renderer* renderer)
 	zNear = 0.1f;
 	zFar = 150.0f;
 	cameraMode = CAMERAMODE_LOOKAT;
+	frustumMode = FRUSTUMMODE_PERSPECTIVE;
+	orthographicFrustumScale = 1.0f;
 	upVector.set(0.0f, 1.0f, 0.0f);
 	forwardVector.set(0.0f, 0.0f, 1.0f);
 	sideVector.set(1.0f, 0.0f, 0.0f);
@@ -64,33 +66,65 @@ Vector3 Camera::computeUpVector(const Vector3& lookFrom, const Vector3& lookAt)
 Matrix4x4& Camera::computeProjectionMatrix()
 {
 	// see: see http://www.songho.ca/opengl/gl_transform.html
-	auto tangent = static_cast<float>(Math::tan(fovY / 2.0f * 3.1415927f / 180.0f));
-	auto height = zNear * tangent;
-	auto width = height * aspect;
-	return computeFrustumMatrix(-width, width, -height, height, zNear, zFar);
-}
-
-Matrix4x4& Camera::computeFrustumMatrix(float leftPlane, float rightPlane, float bottomPlane, float topPlane, float nearPlane, float farPlane)
-{
-	// see: http://www.songho.ca/opengl/gl_transform.html
-	return projectionMatrix.set(
-		2.0f * nearPlane / (rightPlane - leftPlane),
-		0.0f,
-		0.0f,
-		0.0f,
-		0.0f,
-		2.0f * nearPlane / (topPlane - bottomPlane),
-		0.0f,
-		0.0f,
-		(rightPlane + leftPlane) / (rightPlane - leftPlane),
-		(topPlane + bottomPlane) / (topPlane - bottomPlane),
-		-(farPlane + nearPlane) / (farPlane - nearPlane),
-		-1.0f,
-		0.0f,
-		0.0f,
-		-(2.0f * farPlane * nearPlane) / (farPlane - nearPlane),
-		1.0f
-	);
+	switch(frustumMode) {
+		case FRUSTUMMODE_ORTHOGRAPHIC:
+			{
+				auto leftPlane = (-width / 2.0f) * orthographicFrustumScale;
+				auto rightPlane = (width / 2.0f) * orthographicFrustumScale;
+				auto topPlane = (height / 2.0f) * orthographicFrustumScale;
+				auto bottomPlane = (-height / 2.0f) * orthographicFrustumScale;
+				auto nearPlane = zNear;
+				auto farPlane = zFar;
+				return projectionMatrix.set(
+					2.0f / (rightPlane - leftPlane),
+					0.0f,
+					0.0f,
+					0.0f,
+					0.0f,
+					2.0f / (topPlane - bottomPlane),
+					0.0f,
+					0.0f,
+					0.0f,
+					0.0f,
+					-2.0f / (farPlane - nearPlane),
+					0.0f,
+					-(rightPlane + leftPlane) / (rightPlane - leftPlane),
+					-(topPlane + bottomPlane) / (topPlane - bottomPlane),
+					-(farPlane + nearPlane) / (farPlane - nearPlane),
+					1.0f
+				);
+			}
+		default:
+			{
+				auto tangent = static_cast<float>(Math::tan(fovY / 2.0f * 3.1415927f / 180.0f));
+				auto height = zNear * tangent;
+				auto width = height * aspect;
+				auto leftPlane = -width;
+				auto rightPlane = width;
+				auto topPlane = height;
+				auto bottomPlane = -height;
+				auto nearPlane = zNear;
+				auto farPlane = zFar;
+				return projectionMatrix.set(
+					2.0f * nearPlane / (rightPlane - leftPlane),
+					0.0f,
+					0.0f,
+					0.0f,
+					0.0f,
+					2.0f * nearPlane / (topPlane - bottomPlane),
+					0.0f,
+					0.0f,
+					(rightPlane + leftPlane) / (rightPlane - leftPlane),
+					(topPlane + bottomPlane) / (topPlane - bottomPlane),
+					-(farPlane + nearPlane) / (farPlane - nearPlane),
+					-1.0f,
+					0.0f,
+					0.0f,
+					-(2.0f * farPlane * nearPlane) / (farPlane - nearPlane),
+					1.0f
+				);
+			}
+	}
 }
 
 Matrix4x4& Camera::computeModelViewMatrix()
diff --git a/src/tdme/engine/Camera.h b/src/tdme/engine/Camera.h
index adc8ceee..8d09b036 100644
--- a/src/tdme/engine/Camera.h
+++ b/src/tdme/engine/Camera.h
@@ -21,6 +21,7 @@ using tdme::math::Vector3;
 class tdme::engine::Camera final
 {
 public:
+	enum FrustumMode { FRUSTUMMODE_PERSPECTIVE, FRUSTUMMODE_ORTHOGRAPHIC };
 	enum CameraMode { CAMERAMODE_LOOKAT, CAMERAMODE_NONE };
 
 private:
@@ -33,6 +34,8 @@ private:
 	float zNear;
 	float zFar;
 	CameraMode cameraMode;
+	FrustumMode frustumMode;
+	float orthographicFrustumScale;
 	Vector3 lookFrom;
 	Vector3 lookAt;
 	Vector3 upVector;
@@ -96,6 +99,36 @@ public:
 		this->cameraMode = cameraMode;
 	}
 
+	/**
+	 * @return frustum mode
+	 */
+	inline FrustumMode getFrustumMode() const {
+		return frustumMode;
+	}
+
+	/**
+	 * Set frustum mode
+	 * @param frustum mode
+	 */
+	inline void setFrustumMode(FrustumMode frustumMode) {
+		this->frustumMode = frustumMode;
+	}
+
+	/**
+	 * @return orthographic frustum scale
+	 */
+	inline float getOrthographicFrustumScale() const {
+		return orthographicFrustumScale;
+	}
+
+	/**
+	 * Set orthographic frustum scale
+	 * @param orthographicFrustumScale orthographic frustum scale
+	 */
+	inline void setOrthographicFrustumScale(float orthographicFrustumScale) {
+		this->orthographicFrustumScale = orthographicFrustumScale;
+	}
+
 	/**
 	 * @return field of view Y
 	 */
@@ -336,18 +369,6 @@ private:
 	 */
 	Matrix4x4& computeProjectionMatrix();
 
-	/**
-	 * Computes frustum matrix
-	 * @param leftPlane left plane
-	 * @param rightPlane right plane
-	 * @param bottomPlane top plane
-	 * @param topPlane bottom plane
-	 * @param nearPlane near plane
-	 * @param farPlane far plane
-	 * @return frustum matrix
-	 */
-	Matrix4x4& computeFrustumMatrix(float leftPlane, float rightPlane, float bottomPlane, float topPlane, float nearPlane, float farPlane);
-
 	/**
 	 * Computes projection matrix for given look from, look at and up vector
 	 * @return model view matrix
diff --git a/src/tdme/engine/Frustum.h b/src/tdme/engine/Frustum.h
index 3052306f..1f020369 100644
--- a/src/tdme/engine/Frustum.h
+++ b/src/tdme/engine/Frustum.h
@@ -64,15 +64,13 @@ public:
 	void updateFrustum();
 
 	/**
-	 * Checks if given vector is in frustum
-	 * @param vector vecto
+	 * Checks if given vertex is in frustum
+	 * @param vector vector
 	 * @return visibility
 	 */
-	inline bool isVisible(const Vector3& vector) {
-		for (auto& p : planes) {
-			auto& normal = p.getNormal();
-			auto distance = p.getDistance();
-			if (Vector3::computeDotProduct(normal, vector) + distance <= 0) {
+	inline bool isVisible(const Vector3& vertex) {
+		for (auto& p: planes) {
+			if (Vector3::computeDotProduct(p.getNormal(), vertex) + p.getDistance() < 0.0f) {
 				return false;
 			}
 		}
@@ -87,9 +85,8 @@ public:
 	inline bool isVisible(Sphere* s) {
 		auto& center = s->getCenter();
 		auto radius = s->getRadius();
-		for (auto& p : planes) {
-			auto& normal = p.getNormal();
-			if (Vector3::computeDotProduct(normal, center) + p.getDistance() <= -radius) {
+		for (auto& p: planes) {
+			if (Vector3::computeDotProduct(p.getNormal(), center) + p.getDistance() < -radius) {
 				return false;
 			}
 		}
@@ -109,17 +106,17 @@ public:
 		auto maxY = b->getMax()[1];
 		auto maxZ = b->getMax()[2];
 		Vector3 point;
-		for (auto& p : planes) {
+		for (auto& p :planes) {
 			auto& normal = p.getNormal();
 			auto distance = p.getDistance();
-			if (Vector3::computeDotProduct(normal, point.set(minX, minY, minZ)) + distance > 0) continue;
-			if (Vector3::computeDotProduct(normal, point.set(maxX, minY, minZ)) + distance > 0) continue;
-			if (Vector3::computeDotProduct(normal, point.set(minX, maxY, minZ)) + distance > 0) continue;
-			if (Vector3::computeDotProduct(normal, point.set(maxX, maxY, minZ)) + distance > 0) continue;
-			if (Vector3::computeDotProduct(normal, point.set(minX, minY, maxZ)) + distance > 0) continue;
-			if (Vector3::computeDotProduct(normal, point.set(maxX, minY, maxZ)) + distance > 0) continue;
-			if (Vector3::computeDotProduct(normal, point.set(minX, maxY, maxZ)) + distance > 0) continue;
-			if (Vector3::computeDotProduct(normal, point.set(maxX, maxY, maxZ)) + distance > 0) continue;
+			if (Vector3::computeDotProduct(normal, point.set(minX, minY, minZ)) + distance > 0.0f) continue;
+			if (Vector3::computeDotProduct(normal, point.set(maxX, minY, minZ)) + distance > 0.0f) continue;
+			if (Vector3::computeDotProduct(normal, point.set(minX, maxY, minZ)) + distance > 0.0f) continue;
+			if (Vector3::computeDotProduct(normal, point.set(maxX, maxY, minZ)) + distance > 0.0f) continue;
+			if (Vector3::computeDotProduct(normal, point.set(minX, minY, maxZ)) + distance > 0.0f) continue;
+			if (Vector3::computeDotProduct(normal, point.set(maxX, minY, maxZ)) + distance > 0.0f) continue;
+			if (Vector3::computeDotProduct(normal, point.set(minX, maxY, maxZ)) + distance > 0.0f) continue;
+			if (Vector3::computeDotProduct(normal, point.set(maxX, maxY, maxZ)) + distance > 0.0f) continue;
 			return false;
 		}
 		return true;
diff --git a/src/tdme/engine/primitives/LineSegment.cpp b/src/tdme/engine/primitives/LineSegment.cpp
index 86fe3b6b..6a946d52 100644
--- a/src/tdme/engine/primitives/LineSegment.cpp
+++ b/src/tdme/engine/primitives/LineSegment.cpp
@@ -1,15 +1,22 @@
 #include <tdme/engine/primitives/LineSegment.h>
 
+#include <string>
+
 #include <tdme/engine/primitives/BoundingBox.h>
 #include <tdme/engine/primitives/OrientedBoundingBox.h>
 #include <tdme/math/Math.h>
 #include <tdme/math/Vector3.h>
+#include <tdme/utilities/Console.h>
+
+using std::string;
+using std::to_string;
 
 using tdme::engine::primitives::BoundingBox;
 using tdme::engine::primitives::LineSegment;
 using tdme::engine::primitives::OrientedBoundingBox;
 using tdme::math::Math;
 using tdme::math::Vector3;
+using tdme::utilities::Console;
 
 void LineSegment::computeClosestPointOnLineSegment(const Vector3& p1, const Vector3& q1, const Vector3& p, Vector3& c) {
 	// see https://forum.unity.com/threads/how-do-i-find-the-closest-point-on-a-line.340058/
@@ -201,7 +208,7 @@ bool LineSegment::doesLineSegmentCollideWithTriangle(const Vector3& p1, const Ve
 	// At this stage we can compute t to find out where the intersection point is on the line.
 	float t = f * Vector3::computeDotProduct(edge2, q);
 	if (t > Math::EPSILON) {
-		// ray intersection
+		// ray iprintlnntersection
 		contact = r1 + rayVector * t;
 		return true;
 	} else {
@@ -209,3 +216,16 @@ bool LineSegment::doesLineSegmentCollideWithTriangle(const Vector3& p1, const Ve
 		return false;
 	}
 }
+
+bool LineSegment::doesLineSegmentCollideWithPlane(const Vector3& n, float d, const Vector3& p1, const Vector3& p2, Vector3& contact) {
+	// see: https://math.stackexchange.com/questions/83990/line-and-plane-intersection-in-3d
+	auto lineDirection = p2.clone().sub(p1);
+	auto lineLength = lineDirection.computeLength();
+	lineDirection.normalize();
+	float nDotP1 = Vector3::computeDotProduct(n, p1);
+	float nDotLineDirection = Vector3::computeDotProduct(n, lineDirection);
+	auto t = ((d - nDotP1) / nDotLineDirection);
+	if (t < 0.0 || t > lineLength) return false;
+	contact.set(p1 + (lineDirection * t));
+	return true;
+}
diff --git a/src/tdme/engine/primitives/LineSegment.h b/src/tdme/engine/primitives/LineSegment.h
index 84257498..99aefe48 100644
--- a/src/tdme/engine/primitives/LineSegment.h
+++ b/src/tdme/engine/primitives/LineSegment.h
@@ -95,4 +95,16 @@ public:
 	 * @return line segment collides with triangle
 	 */
 	static bool doesLineSegmentCollideWithTriangle(const Vector3& p1, const Vector3& p2, const Vector3& p3, const Vector3& r1, const Vector3& r2, Vector3& contact);
+
+	/**
+	 * Does line segment collides with triangle
+	 * @param n n plane normal
+	 * @param d d plane distance from origin
+	 * @param p1 p1 line segment point 1
+	 * @param p2 p2 line segment point 2
+	 * @param contact point of intersection
+	 * @return line segment collides with plane
+	 */
+	static bool doesLineSegmentCollideWithPlane(const Vector3& n, float d, const Vector3& p1, const Vector3& p2, Vector3& contact);
+
 };
diff --git a/src/tdme/engine/subsystems/shadowmapping/ShadowMap.cpp b/src/tdme/engine/subsystems/shadowmapping/ShadowMap.cpp
index b63c738f..a67805ae 100644
--- a/src/tdme/engine/subsystems/shadowmapping/ShadowMap.cpp
+++ b/src/tdme/engine/subsystems/shadowmapping/ShadowMap.cpp
@@ -3,6 +3,7 @@
 #include <vector>
 
 #include <tdme/engine/primitives/BoundingBox.h>
+#include <tdme/engine/primitives/LineSegment.h>
 #include <tdme/engine/subsystems/renderer/Renderer.h>
 #include <tdme/engine/subsystems/rendering/EntityRenderer.h>
 #include <tdme/engine/subsystems/shadowmapping/ShadowMapping.h>
@@ -25,6 +26,7 @@
 using std::vector;
 
 using tdme::engine::primitives::BoundingBox;
+using tdme::engine::primitives::LineSegment;
 using tdme::engine::subsystems::renderer::Renderer;
 using tdme::engine::subsystems::rendering::EntityRenderer;
 using tdme::engine::subsystems::shadowmapping::ShadowMap;
@@ -113,11 +115,80 @@ void ShadowMap::createShadowMap(Light* light)
 	// TODO: object->preRender only uses default context, lets see how to make this multithreaded
 	auto context = shadowMapping->renderer->getDefaultContext();
 
+	//
+	auto camera = shadowMapping->engine->getCamera();
+	camera->update(nullptr, camera->getWidth(), camera->getHeight());
+
+	// try to determine light position
+	// 	left
+	auto left = camera->getModelViewProjectionInvertedMatrix().multiply(
+		Vector4(
+			(2.0f * 0.0f) - 1.0f,
+			1.0f - (2.0f * 0.5f),
+			2.0f * 0.997f - 1.0f,
+			1.0f
+		)
+	);
+	left.scale(1.0f / left.getW());
+
+	//	right
+	auto right = camera->getModelViewProjectionInvertedMatrix().multiply(
+		Vector4(
+			(2.0f * 1.0f) - 1.0f,
+			1.0f - (2.0f * 0.5f),
+			2.0f * 0.997f - 1.0f,
+			1.0f
+		)
+	);
+	right.scale(1.0f / right.getW());
+
+	//	center
+	auto center4 = camera->getModelViewProjectionInvertedMatrix().multiply(
+		Vector4(
+			(2.0f * 0.5f) - 1.0f,
+			1.0f - (2.0f * 1.0f),
+			2.0f * 0.5f - 1.0f,
+			1.0f
+		)
+	);
+	center4.scale(1.0f / center4.getW());
+
+	// so we get some contraints for the shadow map camera, TODO: improve me
+	Vector3 center(Vector3(center4.getX(), center4.getY(), center4.getZ()));
+	auto width = Vector3(right.getX(), right.getY(), right.getZ()).sub(Vector3(left.getX(), left.getY(), left.getZ())).computeLength() * shadowMapping->engine->getShadowMapLightEyeDistanceScale();
+
+	// light camera
+	Vector3 lightDirection;
+	Vector3 lightLookFrom;
+	// compute camera from view of light
+	lightDirection.set(light->getSpotDirection()).normalize();
+	lightLookFrom
+		.set(center)
+		.sub(lightDirection.clone().scale(width * 0.5f));
+
+	// set up light camera from view of light
+	Vector3 lightCameraUpVector;
+	Vector3 lightCameraSideVector;
+	lightCamera->setFrustumMode(Camera::FRUSTUMMODE_ORTHOGRAPHIC);
+	lightCamera->setOrthographicFrustumScale((width / frameBuffer->getWidth()) / 1.25f);
+	lightCamera->setZNear(camera->getZNear());
+	lightCamera->setZFar(250.0f);
+	lightCamera->setLookFrom(lightLookFrom);
+	lightCamera->setForwardVector(lightDirection);
+	lightCamera->setSideVector(Vector3(1.0f, 0.0f, 0.0f));
+	// TODO: fix cross product NaN if side vector == forward vector
+	lightCameraUpVector = Vector3::computeCrossProduct(lightCamera->getForwardVector(), lightCamera->getSideVector());
+	lightCamera->setUpVector(lightCameraUpVector);
+	lightCameraSideVector = Vector3::computeCrossProduct(lightCamera->getForwardVector(), lightCamera->getUpVector());
+	lightCamera->setSideVector(lightCameraSideVector);
+	lightCamera->setUpVector(lightCameraUpVector);
+	lightCamera->update(context, frameBuffer->getWidth(), frameBuffer->getHeight());
+
 	// clear visible objects
 	visibleObjects.clear();
 
 	// determine visible objects and objects that should generate a shadow
-	for (auto entity: shadowMapping->engine->getPartition()->getVisibleEntities(shadowMapping->engine->getCamera()->getFrustum())) {
+	for (auto entity: shadowMapping->engine->getPartition()->getVisibleEntities(lightCamera->getFrustum())) {
 		switch (entity->getEntityType()) {
 			case Entity::ENTITYTYPE_OBJECT3DRENDERGROUP:
 				{
@@ -211,71 +282,6 @@ void ShadowMap::createShadowMap(Light* light)
 		}
 	}
 
-	//
-	auto camera = shadowMapping->engine->getCamera();
-
-	// try to determine light position
-
-	// 	left
-	auto left = camera->getModelViewProjectionInvertedMatrix().multiply(
-		Vector4(
-			(2.0f * 0.0f) - 1.0f,
-			1.0f - (2.0f * 0.5f),
-			2.0f * 0.997f - 1.0f,
-			1.0f
-		)
-	);
-	left.scale(1.0f / left.getW());
-
-	//	right
-	auto right = camera->getModelViewProjectionInvertedMatrix().multiply(
-		Vector4(
-			(2.0f * 1.0f) - 1.0f,
-			1.0f - (2.0f * 0.5f),
-			2.0f * 0.997f - 1.0f,
-			1.0f
-		)
-	);
-	right.scale(1.0f / right.getW());
-
-	//	center
-	auto center4 = camera->getModelViewProjectionInvertedMatrix().multiply(
-		Vector4(
-			(2.0f * 0.5f) - 1.0f,
-			1.0f - (2.0f * 1.0f),
-			2.0f * 0.5f - 1.0f,
-			1.0f
-		)
-	);
-	center4.scale(1.0f / center4.getW());
-
-	// so we get some contraints for the shadow map camera, TODO: improve me
-	Vector3 center(Vector3(center4.getX(), center4.getY(), center4.getZ()));
-	auto width = Vector3(right.getX(), right.getY(), right.getZ()).sub(Vector3(left.getX(), left.getY(), left.getZ())).computeLength() * shadowMapping->engine->getShadowMapLightEyeDistanceScale();
-
-	// viewers camera
-	Vector3 lightDirection;
-	Vector3 lightLookFrom;
-	// compute camera from view of light
-	lightDirection.set(light->getSpotDirection()).normalize();
-	lightLookFrom
-		.set(center)
-		.sub(lightDirection.clone().scale(width * 1.25f));
-	// set up light camera from view of light
-	Vector3 lightCameraUpVector;
-	Vector3 lightCameraSideVector;
-	lightCamera->setZNear(camera->getZNear());
-	lightCamera->setZFar(150.0f);
-	lightCamera->setLookFrom(lightLookFrom);
-	lightCamera->setForwardVector(lightDirection);
-	lightCamera->setSideVector(Vector3(1.0f, 0.0f, 0.0f));
-	// TODO: fix cross product NaN if side vector == forward vector
-	lightCameraUpVector = Vector3::computeCrossProduct(lightCamera->getForwardVector(), lightCamera->getSideVector());
-	lightCamera->setUpVector(lightCameraUpVector);
-	lightCameraSideVector = Vector3::computeCrossProduct(lightCamera->getForwardVector(), lightCamera->getUpVector());
-	lightCamera->setSideVector(lightCameraSideVector);
-	lightCamera->setUpVector(lightCameraUpVector);
-	lightCamera->update(context, frameBuffer->getWidth(), frameBuffer->getHeight());
 	// bind frame buffer
 	frameBuffer->enableFrameBuffer();
 	// clear depth buffer
diff --git a/src/tdme/engine/subsystems/shadowmapping/ShadowMapping.h b/src/tdme/engine/subsystems/shadowmapping/ShadowMapping.h
index f9985fee..f0f9077b 100644
--- a/src/tdme/engine/subsystems/shadowmapping/ShadowMapping.h
+++ b/src/tdme/engine/subsystems/shadowmapping/ShadowMapping.h
@@ -28,6 +28,7 @@ using tdme::math::Vector4;
  */
 class tdme::engine::subsystems::shadowmapping::ShadowMapping final
 {
+	friend class tdme::engine::Engine;
 	friend class ShadowMap;
 
 private:
