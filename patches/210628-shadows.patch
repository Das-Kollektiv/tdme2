diff --git a/Makefile b/Makefile
index 0d6fbac9..023759a1 100644
--- a/Makefile
+++ b/Makefile
@@ -884,51 +884,9 @@ else
 endif
 
 MAIN_SRCS = \
-	src/tdme/tests/AngleTest-main.cpp \
-	src/tdme/tests/AudioTest-main.cpp \
-	src/tdme/tests/CrashTest-main.cpp \
-	src/tdme/tests/EngineTest-main.cpp \
-	src/tdme/tests/EntityHierarchyTest-main.cpp \
-	src/tdme/tests/HashLinkTest-main.cpp \
-	src/tdme/tests/HTTPClientTest-main.cpp \
-	src/tdme/tests/HTTPDownloadClientTest-main.cpp \
-	src/tdme/tests/LODTest-main.cpp \
-	src/tdme/tests/FlowMapTest-main.cpp \
-	src/tdme/tests/FlowMapTest2-main.cpp \
-	src/tdme/tests/FoliageTest-main.cpp \
-	src/tdme/tests/MathOperatorTest-main.cpp \
-	src/tdme/tests/MiniScriptTest-main.cpp \
-	src/tdme/tests/PathFindingTest-main.cpp \
-	src/tdme/tests/PivotTest-main.cpp \
-	src/tdme/tests/PhysicsTest1-main.cpp \
-	src/tdme/tests/PhysicsTest2-main.cpp \
-	src/tdme/tests/PhysicsTest3-main.cpp \
-	src/tdme/tests/PhysicsTest4-main.cpp \
-	src/tdme/tests/RayTracingTest-main.cpp \
-	src/tdme/tests/SkinningTest-main.cpp \
-	src/tdme/tests/ThreadingTest-main.cpp \
 	src/tdme/tests/TreeTest-main.cpp \
-	src/tdme/tests/UDPClientTest-main.cpp \
-	src/tdme/tests/UDPServerTest-main.cpp \
-	src/tdme/tests/WaterTest-main.cpp \
-	src/tdme/tools/editor/TDMEEditor-main.cpp \
-	src/tdme/tools/gui/GUITest-main.cpp \
-	src/tdme/tools/installer/Installer-main.cpp \
-	src/tdme/tools/modeleditor/TDMEModelEditor-main.cpp \
-	src/tdme/tools/particlesystem/TDMEParticleSystem-main.cpp \
-	src/tdme/tools/sceneeditor/TDMESceneEditor-main.cpp \
-	src/tdme/tools/terraineditor/TDMETerrainEditor-main.cpp \
-	src/tdme/tools/cli/archive-main.cpp \
-	src/tdme/tools/cli/converttotm-main.cpp \
-	src/tdme/tools/cli/copyanimationsetups-main.cpp \
-	src/tdme/tools/cli/create-installer-main.cpp \
-	src/tdme/tools/cli/fixdoxygen-main.cpp \
-	src/tdme/tools/cli/generatelicenses-main.cpp \
-	src/tdme/tools/cli/importtmodel-main.cpp \
-	src/tdme/tools/cli/makefilegenerator-main.cpp \
-	src/tdme/tools/cli/optimizemodel-main.cpp \
-	src/tdme/tools/cli/scenefixmodelszup2yup-main.cpp \
-	src/tdme/tools/cli/sortincludes-main.cpp
+	src/tdme/tests/EngineTest-main.cpp
+
 
 MAINS = $(MAIN_SRCS:$(SRC)/%-main.cpp=$(BIN)/%)
 OBJS = $(SRCS:$(SRC)/%.cpp=$(OBJ)/%.o)
diff --git a/shader/gl3/shadowmapping/render_fragmentshader.frag b/shader/gl3/shadowmapping/render_fragmentshader.frag
index a22bea92..38a21ae1 100644
--- a/shader/gl3/shadowmapping/render_fragmentshader.frag
+++ b/shader/gl3/shadowmapping/render_fragmentshader.frag
@@ -92,7 +92,7 @@ void main() {
 		attenuation *= spotAttenuation;
 
 		// depth bias
-		float depthBias = 0.0;
+		float depthBias = 0.0002;
 
 		// determine visibility
 		float visibility = 0.0;
@@ -111,5 +111,14 @@ void main() {
 
 		// return color to be blended with framebuffer
 		outColor = vec4(0.0, 0.0, 0.0, visibility * vsShadowIntensity * attenuation * 0.5);
+		/*
+		outColor = outColor * 0.00000001 +
+			vec4( 
+				texture(textureUnit, vec2(vsPosition.x / 20.0f, vsPosition.z / 20.0f)).r < 1.0?1.0:0.0,
+				texture(textureUnit, vec2(vsPosition.x / 20.0f, vsPosition.z / 20.0f)).r < 1.0?1.0:0.0,
+				texture(textureUnit, vec2(vsPosition.x / 20.0f, vsPosition.z / 20.0f)).r < 1.0?1.0:0.0,
+				0.5
+			);
+		*/
 	}
 }
diff --git a/shader/gl3/shadowmapping/render_vertexshader.vert b/shader/gl3/shadowmapping/render_vertexshader.vert
index bcbeac6c..11e38288 100644
--- a/shader/gl3/shadowmapping/render_vertexshader.vert
+++ b/shader/gl3/shadowmapping/render_vertexshader.vert
@@ -80,5 +80,4 @@ void main() {
 
 	// compute gl position
 	gl_Position = mvpMatrix * vec4(inVertex, 1.0);
-	gl_Position.z-= 0.0001;
 }
diff --git a/src/tdme/engine/Camera.cpp b/src/tdme/engine/Camera.cpp
index 08102aa9..3f9ed1bc 100644
--- a/src/tdme/engine/Camera.cpp
+++ b/src/tdme/engine/Camera.cpp
@@ -131,6 +131,7 @@ Matrix4x4& Camera::computeModelViewMatrix()
 
 void Camera::update(void* context, int32_t width, int32_t height)
 {
+	Console::println("Camera::update(): " + to_string(width) + " x " + to_string(height));
 	auto reshaped = false;
 	auto _width = width;
 	auto _height = height;
diff --git a/src/tdme/engine/Engine.h b/src/tdme/engine/Engine.h
index f806644c..2044cb38 100644
--- a/src/tdme/engine/Engine.h
+++ b/src/tdme/engine/Engine.h
@@ -341,12 +341,14 @@ private:
 		return meshManager;
 	}
 
+public:
 	/**
 	 * @return shadow mapping or nullptr if disabled
 	 */
 	inline ShadowMapping* getShadowMapping() {
 		return shadowMapping;
 	}
+private:
 
 	/**
 	 * @return shadow mapping shader
diff --git a/src/tdme/engine/FrameBuffer.cpp b/src/tdme/engine/FrameBuffer.cpp
index 4f34869c..a1047362 100644
--- a/src/tdme/engine/FrameBuffer.cpp
+++ b/src/tdme/engine/FrameBuffer.cpp
@@ -86,6 +86,7 @@ void FrameBuffer::dispose()
 
 void FrameBuffer::enableFrameBuffer()
 {
+	Console::println("FrameBuffer::enableFrameBuffer(): " + to_string(frameBufferId) + ": " + to_string(colorBufferTextureId) + " / " + to_string(depthBufferTextureId));
 	Engine::renderer->bindFrameBuffer(frameBufferId);
 	Engine::renderer->setViewPort(0, 0, width, height);
 	Engine::renderer->updateViewPort();
@@ -93,6 +94,7 @@ void FrameBuffer::enableFrameBuffer()
 
 void FrameBuffer::disableFrameBuffer()
 {
+	Console::println("FrameBuffer::disableFrameBuffer()");
 	Engine::renderer->bindFrameBuffer(Engine::renderer->FRAMEBUFFER_DEFAULT);
 	Engine::renderer->setViewPort(0, 0, Engine::instance->width, Engine::instance->height);
 	Engine::renderer->updateViewPort();
@@ -100,6 +102,7 @@ void FrameBuffer::disableFrameBuffer()
 
 void FrameBuffer::bindDepthBufferTexture(void* context)
 {
+	Console::println("FrameBuffer::bindDepthBufferTexture(): " + to_string(Engine::renderer->getTextureUnit(Engine::renderer->getDefaultContext())) + ": " + to_string(depthBufferTextureId));
 	Engine::renderer->bindTexture(context, depthBufferTextureId);
 }
 
diff --git a/src/tdme/engine/subsystems/renderer/GL3Renderer.cpp b/src/tdme/engine/subsystems/renderer/GL3Renderer.cpp
index 35ac9ecf..6c7648b4 100644
--- a/src/tdme/engine/subsystems/renderer/GL3Renderer.cpp
+++ b/src/tdme/engine/subsystems/renderer/GL3Renderer.cpp
@@ -761,6 +761,7 @@ int32_t GL3Renderer::createCubeMapTexture(void* context, int32_t width, int32_t
 
 void GL3Renderer::resizeDepthBufferTexture(int32_t textureId, int32_t width, int32_t height)
 {
+	Console::println("GL3Renderer::resizeDepthBufferTexture(): " + to_string(getTextureUnit(nullptr)) + ": " + to_string(textureId));
 	glBindTexture(GL_TEXTURE_2D, textureId);
 	glTexImage2D(GL_TEXTURE_2D, 0, GL_DEPTH_COMPONENT, width, height, 0, GL_DEPTH_COMPONENT, GL_FLOAT, nullptr);
 	glBindTexture(GL_TEXTURE_2D, 0);
@@ -768,6 +769,7 @@ void GL3Renderer::resizeDepthBufferTexture(int32_t textureId, int32_t width, int
 
 void GL3Renderer::resizeColorBufferTexture(int32_t textureId, int32_t width, int32_t height)
 {
+	Console::println("GL3Renderer::resizeColorBufferTexture(): " + to_string(getTextureUnit(nullptr)) + ": " + to_string(textureId));
 	glBindTexture(GL_TEXTURE_2D, textureId);
 	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, nullptr);
 	glBindTexture(GL_TEXTURE_2D, 0);
@@ -775,6 +777,7 @@ void GL3Renderer::resizeColorBufferTexture(int32_t textureId, int32_t width, int
 
 void GL3Renderer::bindTexture(void* context, int32_t textureId)
 {
+	Console::println("GL3Renderer::bindTexture(): " + to_string(getTextureUnit(nullptr)) + ": " + to_string(textureId));
 	glBindTexture(GL_TEXTURE_2D, textureId);
 	onBindTexture(context, textureId);
 }
@@ -981,6 +984,7 @@ void GL3Renderer::bindSpriteSheetDimensionBufferObject(void* context, int32_t bu
 
 void GL3Renderer::drawInstancedIndexedTrianglesFromBufferObjects(void* context, int32_t triangles, int32_t trianglesOffset, int32_t instances)
 {
+	Console::println("GL3Renderer::drawInstancedIndexedTrianglesFromBufferObjects(): " + to_string(triangles) + " / " + to_string(trianglesOffset) + " / " + to_string(instances));
 	#define BUFFER_OFFSET(i) ((void*)(i))
 	glDrawElementsInstanced(GL_TRIANGLES, triangles * 3, GL_UNSIGNED_INT, BUFFER_OFFSET(static_cast< int64_t >(trianglesOffset) * 3LL * 4LL), instances);
 	statistics.renderCalls++;
diff --git a/src/tdme/engine/subsystems/rendering/EntityRenderer.cpp b/src/tdme/engine/subsystems/rendering/EntityRenderer.cpp
index 48f03137..84af8558 100644
--- a/src/tdme/engine/subsystems/rendering/EntityRenderer.cpp
+++ b/src/tdme/engine/subsystems/rendering/EntityRenderer.cpp
@@ -688,6 +688,7 @@ void EntityRenderer::renderObjectsOfSameTypeNonInstanced(const vector<Object3D*>
 
 void EntityRenderer::renderObjectsOfSameTypeInstanced(int threadIdx, const vector<Object3D*>& objects, bool collectTransparentFaces, int32_t renderTypes, TransparentRenderFacesPool* transparentRenderFacesPool)
 {
+	Console::println("EntityRenderer::renderObjectsOfSameTypeInstanced(): " + objects[0]->getModel()->getId() + ": " + to_string(objects.size()));
 	// contexts
 	auto& object3DRenderContext = contexts[threadIdx];
 	auto context = renderer->getContext(threadIdx);
@@ -847,6 +848,7 @@ void EntityRenderer::renderObjectsOfSameTypeInstanced(int threadIdx, const vecto
 							object->getDistanceShader();
 					if (hadShaderSetup == false) {
 						if (objectShader != renderer->getShader(context)) {
+							Console::println("yyy: " + objectShader);
 							renderer->setShader(context, objectShader);
 							renderer->onUpdateShader(context);
 							for (auto j = 0; j < engine->lights.size(); j++) engine->lights[j].update(context);
diff --git a/src/tdme/engine/subsystems/shadowmapping/ShadowMap.cpp b/src/tdme/engine/subsystems/shadowmapping/ShadowMap.cpp
index b63c738f..13e2ac0e 100644
--- a/src/tdme/engine/subsystems/shadowmapping/ShadowMap.cpp
+++ b/src/tdme/engine/subsystems/shadowmapping/ShadowMap.cpp
@@ -99,6 +99,7 @@ void ShadowMap::dispose()
 
 void ShadowMap::bindDepthBufferTexture(void* context)
 {
+	Console::println("ShadowMap::bindDepthBufferTexture(): " + to_string(frameBuffer->getColorBufferTextureId()) + ": " + to_string(frameBuffer->getDepthBufferTextureId()));
 	frameBuffer->bindDepthBufferTexture(context);
 }
 
@@ -109,6 +110,7 @@ Camera* ShadowMap::getCamera()
 
 void ShadowMap::createShadowMap(Light* light)
 {
+	Console::println("ShadowMap::createShadowMap(): " + to_string(light->getId()));
 	// use default context
 	// TODO: object->preRender only uses default context, lets see how to make this multithreaded
 	auto context = shadowMapping->renderer->getDefaultContext();
@@ -275,6 +277,32 @@ void ShadowMap::createShadowMap(Light* light)
 	lightCameraSideVector = Vector3::computeCrossProduct(lightCamera->getForwardVector(), lightCamera->getUpVector());
 	lightCamera->setSideVector(lightCameraSideVector);
 	lightCamera->setUpVector(lightCameraUpVector);
+	/*
+	lightCamera->setZNear(camera->getZNear());
+	lightCamera->setZFar(150.0f);
+	lightCamera->setCameraMode(Camera::CameraMode::CAMERAMODE_LOOKAT);
+	lightCamera->setLookFrom(lightLookFrom);
+	lightCamera->setLookAt(Vector3(0.0f, 0.0f, 0.0f));
+	*/
+	Console::println(
+		"LF: " +
+		to_string(lightLookFrom.getX()) + ", " +
+		to_string(lightLookFrom.getY()) + ", " +
+		to_string(lightLookFrom.getZ()) + "; " +
+		"LD: " +
+		to_string(lightDirection.getX()) + ", " +
+		to_string(lightDirection.getY()) + ", " +
+		to_string(lightDirection.getZ()) + "; F: " +
+		to_string(lightCamera->getForwardVector().getX()) + ", " +
+		to_string(lightCamera->getForwardVector().getY()) + ", " +
+		to_string(lightCamera->getForwardVector().getZ()) + ": S: " +
+		to_string(lightCamera->getSideVector().getX()) + ", " +
+		to_string(lightCamera->getSideVector().getY()) + ", " +
+		to_string(lightCamera->getSideVector().getZ()) + "; U: " +
+		to_string(lightCamera->getUpVector().getX()) + ", " +
+		to_string(lightCamera->getUpVector().getY()) + ", " +
+		to_string(lightCamera->getUpVector().getZ())
+	);
 	lightCamera->update(context, frameBuffer->getWidth(), frameBuffer->getHeight());
 	// bind frame buffer
 	frameBuffer->enableFrameBuffer();
@@ -297,6 +325,7 @@ void ShadowMap::createShadowMap(Light* light)
 
 void ShadowMap::computeDepthBiasMVPMatrix()
 {
+	Console::println("ShadowMap::computeDepthBiasMVPMatrix()");
 	// matrices
 	auto modelViewMatrix = shadowMapping->renderer->getModelViewMatrix();
 	auto projectionMatrix = shadowMapping->renderer->getProjectionMatrix();
@@ -306,6 +335,9 @@ void ShadowMap::computeDepthBiasMVPMatrix()
 
 void ShadowMap::updateDepthBiasMVPMatrix(void* context)
 {
+	Console::print("ShadowMap::updateDepthBiasMVPMatrix(): ");
+	for (auto& v: depthBiasMVPMatrix.getArray()) Console::print(to_string(v) + " ");
+	Console::println();
 	shadowMapping->updateDepthBiasMVPMatrix(context, depthBiasMVPMatrix);
 }
 
diff --git a/src/tdme/engine/subsystems/shadowmapping/ShadowMap.h b/src/tdme/engine/subsystems/shadowmapping/ShadowMap.h
index 8f09fdce..cf5f73cf 100644
--- a/src/tdme/engine/subsystems/shadowmapping/ShadowMap.h
+++ b/src/tdme/engine/subsystems/shadowmapping/ShadowMap.h
@@ -60,10 +60,12 @@ private:
 	 */
 	void bindDepthBufferTexture(void* context);
 
+public:
 	/**
 	 * @return light camera
 	 */
 	Camera* getCamera();
+private:
 
 	/**
 	 * Create shadow map
diff --git a/src/tdme/engine/subsystems/shadowmapping/ShadowMapRenderShader.cpp b/src/tdme/engine/subsystems/shadowmapping/ShadowMapRenderShader.cpp
index 9c32d650..b31c35f7 100644
--- a/src/tdme/engine/subsystems/shadowmapping/ShadowMapRenderShader.cpp
+++ b/src/tdme/engine/subsystems/shadowmapping/ShadowMapRenderShader.cpp
@@ -112,6 +112,9 @@ void ShadowMapRenderShader::bindTexture(void* context, int32_t textureId)
 
 void ShadowMapRenderShader::setDepthBiasMVPMatrix(void* context, const Matrix4x4& depthBiasMVPMatrix)
 {
+	Console::print("ShadowMapRenderShader::setDepthBiasMVPMatrix(): ");
+	for (auto& v: depthBiasMVPMatrix.getArray()) Console::print(to_string(v) + " ");
+	Console::println();
 	this->depthBiasMVPMatrix = depthBiasMVPMatrix;
 	auto& shadowMappingShaderRenderContext = contexts[renderer->getContextIndex(context)];
 	if (shadowMappingShaderRenderContext.implementation == nullptr) return;
@@ -123,6 +126,7 @@ void ShadowMapRenderShader::setRenderLightId(int32_t lightId) {
 }
 
 void ShadowMapRenderShader::setShader(void* context, const string& id) {
+	Console::println("ShadowMapRenderShader::setShader(): " + id);
 	auto& shadowMappingShaderRenderContext = contexts[renderer->getContextIndex(context)];
 	auto currentImplementation = shadowMappingShaderRenderContext.implementation;
 	auto shaderIt = shader.find(id);
diff --git a/src/tdme/engine/subsystems/shadowmapping/ShadowMapRenderShaderBaseImplementation.cpp b/src/tdme/engine/subsystems/shadowmapping/ShadowMapRenderShaderBaseImplementation.cpp
index 64fc3c3d..ae605365 100644
--- a/src/tdme/engine/subsystems/shadowmapping/ShadowMapRenderShaderBaseImplementation.cpp
+++ b/src/tdme/engine/subsystems/shadowmapping/ShadowMapRenderShaderBaseImplementation.cpp
@@ -129,6 +129,7 @@ void ShadowMapRenderShaderBaseImplementation::useProgram(Engine* engine, void* c
 {
 	renderer->useProgram(context, programId);
 	renderer->setLighting(context, renderer->LIGHTING_SPECULAR);
+	Console::println("ShadowMapRenderShaderBaseImplementation(): " + to_string(renderUniformTextureUnit) + " -> " + to_string(ShadowMap::TEXTUREUNIT));
 	renderer->setProgramUniformInteger(context, renderUniformTextureUnit, ShadowMap::TEXTUREUNIT);
 	if (renderUniformTime != -1) renderer->setProgramUniformFloat(context, renderUniformTime, static_cast<float>(engine->getTiming()->getTotalTime()) / 1000.0f);
 	if (renderUniformShadowMapLookUps != -1) renderer->setProgramUniformInteger(context, renderUniformShadowMapLookUps, Engine::getShadowMapRenderLookUps());
@@ -195,6 +196,7 @@ void ShadowMapRenderShaderBaseImplementation::updateLight(Renderer* renderer, vo
 		renderer->setProgramUniformFloatMatrix4x4(context, renderUniformProjectionMatrix, renderer->getProjectionMatrix().getArray());
 		renderer->setProgramUniformFloatMatrix4x4(context, renderUniformCameraMatrix, renderer->getCameraMatrix().getArray());
 	}
+	Console::println(to_string(Engine::getShadowMapWidth()) + " x " + to_string(Engine::getShadowMapHeight()));
 	renderer->setProgramUniformFloat(context, renderUniformTexturePixelWidth, 1.0f / static_cast<float>(Engine::getShadowMapWidth()));
 	renderer->setProgramUniformFloat(context, renderUniformTexturePixelHeight, 1.0f / static_cast<float>(Engine::getShadowMapHeight()));
 }
@@ -210,6 +212,9 @@ void ShadowMapRenderShaderBaseImplementation::bindTexture(Renderer* renderer, vo
 
 void ShadowMapRenderShaderBaseImplementation::setDepthBiasMVPMatrix(void* context, const Matrix4x4& depthBiasMVPMatrix)
 {
+	Console::print("ShadowMapRenderShaderBaseImplementation::setDepthBiasMVPMatrix(): " + to_string(renderUniformDepthBiasMVPMatrix) + ": ");
+	for (auto& v: depthBiasMVPMatrix.getArray()) Console::print(to_string(v) + " ");
+	Console::println();
 	renderer->setProgramUniformFloatMatrix4x4(context, renderUniformDepthBiasMVPMatrix, depthBiasMVPMatrix.getArray());
 }
 
diff --git a/src/tdme/engine/subsystems/shadowmapping/ShadowMapping.cpp b/src/tdme/engine/subsystems/shadowmapping/ShadowMapping.cpp
index b1e9b35a..c961b580 100644
--- a/src/tdme/engine/subsystems/shadowmapping/ShadowMapping.cpp
+++ b/src/tdme/engine/subsystems/shadowmapping/ShadowMapping.cpp
@@ -64,15 +64,17 @@ void ShadowMapping::reshape(int32_t width, int32_t height)
 
 void ShadowMapping::createShadowMaps()
 {
+	Console::println("ShadowMapping::createShadowMaps(): begin");
 	runState = ShadowMapping_RunState::CREATE;
 	// disable color rendering, we only want to write to the Z-Buffer
 	renderer->setColorMask(false, false, false, false);
 	// render backfaces only, avoid self-shadowing
-	renderer->setCullFace(renderer->CULLFACE_FRONT);
+	//renderer->setCullFace(renderer->CULLFACE_FRONT);
 	// render to shadow maps
 	for (auto i = 0; i < engine->getLightCount(); i++) {
 		auto light = engine->getLightAt(i);
 		if (light->isEnabled() == true) {
+			Console::println("ShadowMapping::createShadowMaps(): " + to_string(i));
 			// create shadow map for light, if required
 			if (shadowMaps[i] == nullptr) {
 				auto shadowMap = new ShadowMap(this, Engine::getShadowMapWidth(), Engine::getShadowMapHeight());
@@ -98,6 +100,7 @@ void ShadowMapping::createShadowMaps()
 	renderer->setCullFace(renderer->CULLFACE_BACK);
 	//
 	runState = ShadowMapping_RunState::NONE;
+	Console::println("ShadowMapping::createShadowMaps(): end");
 }
 
 ShadowMap* ShadowMapping::getShadowMap(int idx) {
@@ -106,6 +109,7 @@ ShadowMap* ShadowMapping::getShadowMap(int idx) {
 
 void ShadowMapping::renderShadowMaps(const vector<Object3D*>& visibleObjects)
 {
+	Console::println("ShadowMapping::renderShadowMaps(): begin: " + to_string(visibleObjects.size()));
 	// only render for objects that receives shadows
 	for (auto object: visibleObjects) {
 		if (object->isReceivesShadows() == false) continue;
@@ -114,6 +118,7 @@ void ShadowMapping::renderShadowMaps(const vector<Object3D*>& visibleObjects)
 
 	//
 	auto contextCount = renderer->isSupportingMultithreadedRendering() == true?Engine::getThreadCount():1;
+	//
 	runState = ShadowMapping_RunState::RENDER;
 	// render using shadow mapping program
 	auto shader = Engine::getShadowMapRenderShader();
@@ -122,10 +127,14 @@ void ShadowMapping::renderShadowMaps(const vector<Object3D*>& visibleObjects)
 	// user shader program
 	shader->useProgram(engine);
 	// render each shadow map
+	renderer->enableBlending();
+
 	for (auto i = 0; i < shadowMaps.size(); i++) {
 		// skip on unused shadow mapping
 		if (shadowMaps[i] == nullptr) continue;
 
+		Console::println("ShadowMapping::renderShadowMaps(): render: " + to_string(i));
+
 		//
 		auto shadowMap = shadowMaps[i];
 		// set light to render
@@ -133,10 +142,12 @@ void ShadowMapping::renderShadowMaps(const vector<Object3D*>& visibleObjects)
 
 		// setup depth textures to contexts
 		for (auto j = 0; j < contextCount; j++) {
+			Console::println("xxx: " + to_string(contextCount));
 			// use default context
 			auto context = renderer->getContext(j);
 			// set up light shader uniforms
 			shadowMap->updateDepthBiasMVPMatrix(context);
+			//
 			// bind shadow map texture on shadow map texture unit
 			auto textureUnit = renderer->getTextureUnit(context);
 			renderer->setTextureUnit(context, ShadowMap::TEXTUREUNIT);
@@ -145,9 +156,8 @@ void ShadowMapping::renderShadowMaps(const vector<Object3D*>& visibleObjects)
 			renderer->setTextureUnit(context, textureUnit);
 		}
 
-		// render objects, enable blending
-		//	will be disabled after rendering transparent faces
-		renderer->enableBlending();
+		Console::println("ShadowMapping::renderShadowMaps(): rendering: " + to_string(i));
+
 		// 	only opaque face entities as shadows will not be produced on transparent faces
 		for (auto i = 0; i < Entity::RENDERPASS_MAX; i++) {
 			auto renderPass = static_cast<Entity::RenderPass>(Math::pow(2, i));
@@ -161,10 +171,11 @@ void ShadowMapping::renderShadowMaps(const vector<Object3D*>& visibleObjects)
 				EntityRenderer::RENDERTYPE_SHADOWMAPPING
 			);
 		}
-		//	disable blending
-		renderer->disableBlending();
 	}
 
+	//
+	renderer->disableBlending();
+
 	// unuse shader program
 	shader->unUseProgram();
 
@@ -187,6 +198,8 @@ void ShadowMapping::renderShadowMaps(const vector<Object3D*>& visibleObjects)
 
 	//
 	runState = ShadowMapping_RunState::NONE;
+
+	Console::println("ShadowMapping::renderShadowMaps(): end: " + to_string(visibleObjects.size()));
 }
 
 void ShadowMapping::dispose()
@@ -303,6 +316,10 @@ void ShadowMapping::updateDepthBiasMVPMatrix(void* context, Matrix4x4& depthBias
 {
 	if (runState != ShadowMapping_RunState::RENDER)
 		return;
+	Console::print("ShadowMapping::updateDepthBiasMVPMatrix(): ");
+	for (auto& v: depthBiasMVPMatrix.getArray()) Console::print(to_string(v) + " ");
+	Console::println();
+
 	// copy matrix
 	this->depthBiasMVPMatrix.set(depthBiasMVPMatrix);
 	// upload
@@ -329,6 +346,7 @@ void ShadowMapping::setShader(void* context, const string& id) {
 			break;
 		case ShadowMapping_RunState::RENDER:
 			Engine::getShadowMapRenderShader()->setShader(context, id);
+			Engine::getShadowMapRenderShader()->setDepthBiasMVPMatrix(context, depthBiasMVPMatrix);
 			break;
 		default:
 			Console::println(string("ShadowMapping::setShader(): unsupported run state '" + to_string(runState)));
diff --git a/src/tdme/tests/EngineTest.cpp b/src/tdme/tests/EngineTest.cpp
index 7c4498f5..5f23b372 100644
--- a/src/tdme/tests/EngineTest.cpp
+++ b/src/tdme/tests/EngineTest.cpp
@@ -105,7 +105,7 @@ EngineTest::EngineTest()
 
 EngineTest::~EngineTest()
 {
-	delete osEngine;
+	//delete osEngine;
 }
 void EngineTest::main(int argc, char** argv)
 {
@@ -166,7 +166,7 @@ void EngineTest::display()
 	(dynamic_cast< ParticleSystemEntity* >(engine->getEntity("circle")))->fromTransformations(circleTransformations);
 	doPlayerControl(0, keyLeft, keyRight, keyUp);
 	doPlayerControl(1, keyA, keyD, keyW);
-	osEngine->display();
+	//osEngine->display();
 	engine->display();
 	if (mouseClicked == true) {
 		if (entityClicked != nullptr) {
@@ -222,13 +222,14 @@ void EngineTest::doPlayerControl(int32_t idx, bool keyLeft, bool keyRight, bool
 void EngineTest::dispose()
 {
 	engine->dispose();
-	osEngine->dispose();
+	//osEngine->dispose();
 }
 
 void EngineTest::initialize()
 {
 	engine->initialize();
 	engine->addPostProcessingProgram("ssao");
+	/*
 	if (osEngine == nullptr) {
 		osEngine = Engine::createOffScreenInstance(512, 512, false);
 		auto osLight0 = osEngine->getLightAt(0);
@@ -245,6 +246,7 @@ void EngineTest::initialize()
 		osCam->setUpVector(osCam->computeUpVector(osCam->getLookFrom(), osCam->getLookAt()));
 		osEngine->setSceneColor(Color4(0.5f, 0.0f, 0.0f, 1.0f));
 	}
+	*/
 	auto cam = engine->getCamera();
 	cam->setZNear(0.1f);
 	cam->setZFar(15.0f);
@@ -252,6 +254,7 @@ void EngineTest::initialize()
 	cam->setLookAt(Vector3(0.0f, 0.5f, 0.0f));
 	cam->setUpVector(cam->computeUpVector(cam->getLookFrom(), cam->getLookAt()));
 	auto light0 = engine->getLightAt(0);
+	/*
 	light0->setAmbient(Color4(0.5f, 0.5f, 0.5f, 1.0f));
 	light0->setSpecular(Color4(1.0f, 1.0f, 1.0f, 1.0f));
 	light0->setPosition(Vector4(0.0f, 20000.0f, 0.0f, 1.0f));
@@ -262,16 +265,19 @@ void EngineTest::initialize()
 	light0->setSpotExponent(0.0f);
 	light0->setSpotCutOff(180.0f);
 	light0->setEnabled(true);
-	auto light1 = engine->getLightAt(1);
-	light1->setDiffuse(Color4(0.0f, 0.0f, 0.5f, 1.0f));
-	light1->setPosition(Vector4(-4.0f, 5.0f, -5.0f, 1.0f));
+	*/
+	auto light1 = engine->getLightAt(0);
+	light1->setDiffuse(Color4(1.0f, 1.0f, 1.0f, 1.0f));
+	light1->setPosition(Vector4(-8.0f, 10.0f, -10.0f, 1.0f));
 	light1->setSpotDirection(Vector3(0.0f, 0.0f, 0.0f).sub(Vector3(light1->getPosition().getX(), light1->getPosition().getY(), light1->getPosition().getZ())));
 	light1->setEnabled(true);
+	/*
 	auto light2 = engine->getLightAt(2);
 	light2->setDiffuse(Color4(0.0f, 0.5f, 0.0f, 1.0f));
-	light2->setPosition(Vector4(+4.0f, 5.0f, 0.0f, 1.0f));
+	light2->setPosition(Vector4(+8.0f, 10.0f, 0.0f, 1.0f));
 	light2->setSpotDirection(Vector3(0.0f, 0.0f, 0.0f).sub(Vector3(light2->getPosition().getX(), light2->getPosition().getY(), light2->getPosition().getZ())));
 	light2->setEnabled(true);
+	*/
 	try {
 		auto _barrel = modelDeleter.add(ModelReader::read("resources/tests/models/barrel", "barrel.dae"));
 		auto barrel = new Object3D("barrel", _barrel);
@@ -289,7 +295,7 @@ void EngineTest::initialize()
 			"wall"
 		);
 
-		farPlane->bindDiffuseTexture(osEngine->getFrameBuffer(), "wall", "wall");
+		//farPlane->bindDiffuseTexture(osEngine->getFrameBuffer(), "wall", "wall");
 		engine->addEntity(farPlane);
 		auto _grass = modelDeleter.add(ModelReader::read("resources/tests/models/grass", "grass.dae"));
 		auto grass = new Object3D("ground", _grass);
@@ -353,7 +359,7 @@ void EngineTest::initialize()
 		osCube->setContributesShadows(true);
 		osCube->setReceivesShadows(true);
 		osCube->update();
-		osEngine->addEntity(osCube);
+		//osEngine->addEntity(osCube);
 		engine->addEntity(new PointsParticleSystem("circle", new CircleParticleEmitter(3000, 50, 50, Vector3(1.0f, 0.0f, 0.0f), Vector3(0.0f, 0.0f, 1.0f), Vector3(0.0f, 0.0f, 0.0f), 0.4f, 0.0f, 0.0f, Vector3(0.0f, 0.2f, 0.0f), Vector3(0.0f, 0.2f, 0.0f), Color4(1.0f, 1.0f, 1.0f, 0.3f), Color4(1.0f, 1.0f, 1.0f, 0.3f)), 1000, 0.1f, true));
 		engine->getEntity("circle")->setEnabled(true);
 		engine->addEntity(new PointsParticleSystem("water", new SphereParticleEmitter(4000, 1000, 0, 0.1f, 0.0f, new Sphere(Vector3(-1.0f, 1.0f, 0.0f), 0.05f), Vector3(-4.0f, 0.0f, 1.0f), Vector3(-1.0f, 0.0f, 0.0f), Color4(0.8f, 0.8f, 1.0f, 0.25f), Color4(0.8f, 0.8f, 1.0f, 0.25f)), 4000, 0.2f, true));
@@ -376,6 +382,29 @@ void EngineTest::initialize()
 		(dynamic_cast< ParticleSystemEntity* >(engine->getEntity("circle")))->setPickable(false);
 		(dynamic_cast< ParticleSystemEntity* >(engine->getEntity("snow")))->setPickable(false);
 		(dynamic_cast< ParticleSystemEntity* >(engine->getEntity("fire")))->setPickable(true);
+		{
+			auto treePine = modelDeleter.add(ModelReader::read("resources/tests/models/lod-tree", "Mesh_Environment_Tree_Pine_03.tm"));
+			auto entity = new Object3D(
+				"tree",
+				treePine
+			);
+			entity->addRotation(Vector3(0.0f, 1.0f, 0.0f), Math::random() * 360.0f);
+			float scale = (1.0f + Math::random() / 3.0f) * 0.25f;
+			entity->setScale(
+				Vector3(
+					Math::random() < 0.5f?scale:-scale,
+					scale,
+					Math::random() < 0.5f?scale:-scale
+				)
+			);
+			entity->setTranslation(Vector3(-2.0f, 0.0f, -2.0f));
+			entity->setContributesShadows(true);
+			entity->setReceivesShadows(true);
+			//entity->setShader("tree");
+			//entity->setShaderParameter("speed", ShaderParameter(0.5f));
+			entity->update();
+			engine->addEntity(entity);
+		}
 	} catch (Exception& exception) {
 		Console::print(string("EngineTest::initialize(): An error occurred: "));
 		Console::println(string(exception.what()));
diff --git a/src/tdme/tests/TreeTest.cpp b/src/tdme/tests/TreeTest.cpp
index 915f9a50..aa6acc4f 100644
--- a/src/tdme/tests/TreeTest.cpp
+++ b/src/tdme/tests/TreeTest.cpp
@@ -12,9 +12,12 @@
 #include <tdme/engine/model/SpecularMaterialProperties.h>
 #include <tdme/engine/primitives/BoundingVolume.h>
 #include <tdme/engine/primitives/OrientedBoundingBox.h>
+#include <tdme/engine/subsystems/shadowmapping/ShadowMapping.h>
+#include <tdme/engine/subsystems/shadowmapping/ShadowMap.h>
 #include <tdme/engine/Camera.h>
 #include <tdme/engine/Engine.h>
 #include <tdme/engine/Light.h>
+#include <tdme/engine/LinesObject3D.h>
 #include <tdme/engine/Object3D.h>
 #include <tdme/engine/Rotation.h>
 #include <tdme/engine/ShaderParameter.h>
@@ -42,9 +45,12 @@ using tdme::engine::model::Model;
 using tdme::engine::model::SpecularMaterialProperties;
 using tdme::engine::primitives::BoundingVolume;
 using tdme::engine::primitives::OrientedBoundingBox;
+using tdme::engine::subsystems::shadowmapping::ShadowMapping;
+using tdme::engine::subsystems::shadowmapping::ShadowMap;
 using tdme::engine::Camera;
 using tdme::engine::Engine;
 using tdme::engine::Light;
+using tdme::engine::LinesObject3D;
 using tdme::engine::Object3D;
 using tdme::engine::Rotation;
 using tdme::engine::ShaderParameter;
@@ -73,6 +79,33 @@ void TreeTest::main(int argc, char** argv)
 
 void TreeTest::display()
 {
+	if (keyComma == true) lightRotationX-= 0.5f;
+	if (keyDot == true) lightRotationX+= 0.5f;
+	auto shadowMapCamera = engine->getShadowMapping()->getShadowMap(0) != nullptr?engine->getShadowMapping()->getShadowMap(0)->getCamera():nullptr;
+	if (shadowMapCamera != nullptr) {
+		Quaternion lightRotation;
+		lightRotation.rotate(Vector3(1.0f, 0.0f, 0.0f), lightRotationX);
+		auto lightPosition = lightRotation.multiply(Vector3(0.0f, 20.0f, 0.0f));
+		auto light1 = engine->getLightAt(0);
+		light1->setPosition(Vector4(lightPosition.getX(), lightPosition.getY(), lightPosition.getZ(), 1.0f));
+		light1->setSpotDirection(Vector3(0.0f, 0.0f, 0.0f).sub(Vector3(light1->getPosition().getX(), light1->getPosition().getY(), light1->getPosition().getZ())));
+		auto suPosition = Vector3(0.0f, 5.0f, 0.0f);
+		auto linesObject3DForward = new LinesObject3D("rayF", 5.0f, { suPosition, suPosition - shadowMapCamera->getForwardVector() * 10000.0f}, { 1.0f, 1.0f, 1.0f, 1.0f});
+		linesObject3DForward->setEffectColorMul(Color4(1.0f, 0.0f, 0.0f, 1.0f));
+		engine->addEntity(linesObject3DForward);
+		auto linesObject3DSide = new LinesObject3D("rayS", 5.0f, { suPosition, suPosition + shadowMapCamera->getSideVector() * 10000.0f}, { 1.0f, 1.0f, 1.0f, 1.0f});
+		linesObject3DSide->setEffectColorMul(Color4(0.0f, 1.0f, 0.0f, 1.0f));
+		engine->addEntity(linesObject3DSide);
+		auto linesObject3DUp = new LinesObject3D("rayU", 5.0f, { suPosition, suPosition + shadowMapCamera->getUpVector() * 10000.0f}, { 1.0f, 1.0f, 1.0f, 1.0f});
+		linesObject3DUp->setEffectColorMul(Color4(0.0f, 0.0f, 1.0f, 1.0f));
+		engine->addEntity(linesObject3DUp);
+		auto lookFromObject = new Object3D("p", emptyModel);
+		lookFromObject->setTranslation(shadowMapCamera->getLookFrom());
+		lookFromObject->setScale(Vector3(10.0f, 10.0f, 10.0f));
+		lookFromObject->update();
+		engine->addEntity(lookFromObject);
+	}
+
 	// camera
 	auto camLookFrom = engine->getCamera()->getLookFrom();
 	if (keyMinus == true) camLookFrom.add(Vector3(0.0f, -20.0f / 60.0f, 0.0f));
@@ -107,20 +140,6 @@ void TreeTest::display()
 	engine->display();
 	auto end = Time::getCurrentMillis();
 	auto rendererStatistics = engine->getRendererStatistics();
-	Console::println(
-		string("TreeTest::display::") + to_string(end - start) + "ms; " +
-		"clear calls: " + to_string(rendererStatistics.clearCalls) + ", " +
-		"render calls: " + to_string(rendererStatistics.renderCalls) + ", " +
-		"compute calls: " + to_string(rendererStatistics.computeCalls) + ", " +
-		"tris: " + to_string(rendererStatistics.triangles) + ", " +
-		"points: " + to_string(rendererStatistics.points) + ", " +
-		"line points: " + to_string(rendererStatistics.linePoints) + ", " +
-		"buffer up: " + to_string(rendererStatistics.bufferUploads) + ", " +
-		"texture up: " + to_string(rendererStatistics.textureUploads) + ", " +
-		"render passes: " + to_string(rendererStatistics.renderPasses) + ", " +
-		"draw cmds: " + to_string(rendererStatistics.drawCommands) + ", " +
-		"submits: " + to_string(rendererStatistics.submits)
-	);
 }
 
 void TreeTest::dispose()
@@ -131,16 +150,26 @@ void TreeTest::dispose()
 void TreeTest::initialize()
 {
 	engine->initialize();
+	emptyModel = ModelReader::read("resources/engine/models", "empty.tm");
 	engine->addPostProcessingProgram("light_scattering");
 	engine->setShaderParameter("light_scattering", "intensity", ShaderParameter(1.0f));
 	engine->setSceneColor(Color4(0.2f, 0.2f, 0.8f, 1.0f));
 	Object3D* entity;
+	/*
 	auto cam = engine->getCamera();
 	cam->setZNear(0.1f);
-	cam->setZFar(150.0f);
+	cam->setZFar(15.0f);
 	cam->setLookFrom(Vector3(0.0f, 3.5f, 28.0f));
 	cam->setLookAt(Vector3(0.0f, 0.0f, 0.0f));
 	cam->setUpVector(cam->computeUpVector(cam->getLookFrom(), cam->getLookAt()));
+	*/
+	auto cam = engine->getCamera();
+	cam->setZNear(0.1f);
+	cam->setZFar(15.0f);
+	cam->setLookFrom(Vector3(0.0f, 3.0f, -8.0f));
+	cam->setLookAt(Vector3(0.0f, 0.5f, 0.0f));
+	cam->setUpVector(cam->computeUpVector(cam->getLookFrom(), cam->getLookAt()));
+	/*
 	auto light0 = engine->getLightAt(0);
 	light0->setAmbient(Color4(1.0f, 1.0f, 1.0f, 1.0f));
 	light0->setDiffuse(Color4(0.5f, 0.5f, 0.5f, 1.0f));
@@ -152,8 +181,40 @@ void TreeTest::initialize()
 	light0->setQuadraticAttenuation(0.0f);
 	light0->setSpotExponent(0.0f);
 	light0->setSpotCutOff(180.0f);
-	light0->setRenderLightSource(true);
+	light0->setRenderLightSource(false);
 	light0->setEnabled(true);
+	*/
+	auto light1 = engine->getLightAt(0);
+	light1->setDiffuse(Color4(1.0f, 1.0f, 1.0f, 1.0f));
+	light1->setPosition(Vector4(-8.0f, 10.0f, -10.0f, 1.0f));
+	light1->setSpotDirection(Vector3(0.0f, 0.0f, 0.0f).sub(Vector3(light1->getPosition().getX(), light1->getPosition().getY(), light1->getPosition().getZ())));
+	light1->setRenderLightSource(true);
+	light1->setEnabled(true);
+	/*
+	auto light2 = engine->getLightAt(2);
+	light2->setDiffuse(Color4(0.0f, 0.5f, 0.0f, 1.0f));
+	light2->setPosition(Vector4(+8.0f, 10.0f, 0.0f, 1.0f));
+	light2->setSpotDirection(Vector3(0.0f, 0.0f, 0.0f).sub(Vector3(light2->getPosition().getX(), light2->getPosition().getY(), light2->getPosition().getZ())));
+	light2->setEnabled(true);
+	*/
+	auto _barrel = modelDeleter.add(ModelReader::read("resources/tests/models/barrel", "barrel.dae"));
+	auto barrel = new Object3D("barrel", _barrel);
+	barrel->setTranslation(Vector3(1.5f, 0.35f, -2.0f));
+	barrel->setContributesShadows(true);
+	barrel->setReceivesShadows(true);
+	barrel->setEnabled(true);
+	barrel->update();
+	engine->addEntity(barrel);
+
+	auto _grass = modelDeleter.add(ModelReader::read("resources/tests/models/grass", "grass.dae"));
+	auto grass = new Object3D("ground", _grass);
+	grass->setEnabled(true);
+	grass->setScale(Vector3(16.0f, 1.0f, 16.0f));
+	grass->setReceivesShadows(true);
+	grass->update();
+	engine->addEntity(grass);
+
+	/*
 	auto ground = bvDeleter.add(new OrientedBoundingBox(Vector3(0.0f, 0.0f, 0.0f), OrientedBoundingBox::AABB_AXIS_X, OrientedBoundingBox::AABB_AXIS_Y, OrientedBoundingBox::AABB_AXIS_Z, Vector3(240.0f, 1.0f, 240.0f)));
 	auto groundModel = modelDeleter.add(Primitives::createModel(ground, "ground_model"));
 	groundModel->getMaterials()["primitive"]->getSpecularMaterialProperties()->setAmbientColor(Color4(0.8f, 0.8f, 0.8f, 1.0f));
@@ -163,17 +224,16 @@ void TreeTest::initialize()
 	entity->setReceivesShadows(true);
 	entity->update();
 	engine->addEntity(entity);
-	auto treePine = modelDeleter.add(ModelReader::read("resources/tests/models/lod-tree", "Mesh_Environment_Tree_Pine_03.tm"));
-	ModelTools::prepareForShader(treePine, "tree");
-	int treeIdx = 0;
-	for (float z = -20.0f; z < 20.0f; z+= 5.0f)
-	for (float x = -20.0f; x < 20.0f; x+= 5.0f) {
+	*/
+
+	{
+		auto treePine = modelDeleter.add(ModelReader::read("resources/tests/models/lod-tree", "Mesh_Environment_Tree_Pine_03.tm"));
 		auto entity = new Object3D(
-			"tree." + to_string(treeIdx++),
+			"tree",
 			treePine
 		);
 		entity->addRotation(Vector3(0.0f, 1.0f, 0.0f), Math::random() * 360.0f);
-		float scale = 1.0f + Math::random() / 3.0f;
+		float scale = (1.0f + Math::random() / 3.0f) * 0.25f;
 		entity->setScale(
 			Vector3(
 				Math::random() < 0.5f?scale:-scale,
@@ -181,11 +241,11 @@ void TreeTest::initialize()
 				Math::random() < 0.5f?scale:-scale
 			)
 		);
-		entity->setTranslation(Vector3(x, 0.0f, z));
+		entity->setTranslation(Vector3(-2.0f, 0.0f, -2.0f));
 		entity->setContributesShadows(true);
 		entity->setReceivesShadows(true);
-		entity->setShader("tree");
-		entity->setShaderParameter("speed", ShaderParameter(0.5f));
+		//entity->setShader("tree");
+		//entity->setShaderParameter("speed", ShaderParameter(0.5f));
 		entity->update();
 		engine->addEntity(entity);
 	}
@@ -206,7 +266,10 @@ void TreeTest::onKeyDown (unsigned char key, int x, int y) {
 	if (keyChar == 's') keyS = true;
 	if (keyChar == 'd') keyD = true;
 	if (keyChar == '-') keyMinus = true;
-	if (keyChar == '+') keyPlus = true;}
+	if (keyChar == '+') keyPlus = true;
+	if (keyChar == ',') keyComma = true;
+	if (keyChar == '.') keyDot = true;
+}
 
 void TreeTest::onKeyUp(unsigned char key, int x, int y) {
 	auto keyChar = Character::toLowerCase(key);
@@ -216,6 +279,8 @@ void TreeTest::onKeyUp(unsigned char key, int x, int y) {
 	if (keyChar == 'd') keyD = false;
 	if (keyChar == '-') keyMinus = false;
 	if (keyChar == '+') keyPlus = false;
+	if (keyChar == ',') keyComma = false;
+	if (keyChar == '.') keyDot = false;
 }
 
 void TreeTest::onSpecialKeyDown (int key, int x, int y) {
diff --git a/src/tdme/tests/TreeTest.h b/src/tdme/tests/TreeTest.h
index 7bf965f3..85144a4a 100644
--- a/src/tdme/tests/TreeTest.h
+++ b/src/tdme/tests/TreeTest.h
@@ -36,8 +36,12 @@ private:
 	bool keyD { false };
 	bool keyMinus { false };
 	bool keyPlus { false };
+	bool keyComma { false };
+	bool keyDot { false };
 	float camRotationY { 0.0f };
 	float camRotationX { 0.0f };
+	float lightRotationX { 0.0f };
+	Model* emptyModel { nullptr };
 
 	ObjectDeleter<Model> modelDeleter;
 	ObjectDeleter<BoundingVolume> bvDeleter;
