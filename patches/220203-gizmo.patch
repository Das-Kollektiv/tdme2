diff --git a/src/tdme/engine/Camera.cpp b/src/tdme/engine/Camera.cpp
index ab4d49ce..8ec56695 100644
--- a/src/tdme/engine/Camera.cpp
+++ b/src/tdme/engine/Camera.cpp
@@ -28,7 +28,7 @@ Camera::Camera(Renderer* renderer)
 	frustumMode = FRUSTUMMODE_PERSPECTIVE;
 	orthographicFrustumScale = 1.0f;
 	upVector.set(0.0f, 1.0f, 0.0f);
-	forwardVector.set(0.0f, 0.0f, 1.0f);
+	forwardVector.set(0.0f, 0.0f, -1.0f);
 	sideVector.set(1.0f, 0.0f, 0.0f);
 	lookFrom.set(0.0f, 50.0f, 400.0f);
 	lookAt.set(0.0f, 50.0f, 0.0f);
@@ -123,7 +123,7 @@ Matrix4x4& Camera::computeModelViewMatrix()
 		sideVector = Vector3::computeCrossProduct(forwardVector, upVector).normalize();
 		tmpUp = Vector3::computeCrossProduct(sideVector, forwardVector);
 	}
-	modelViewMatrix.
+	cameraMatrix.
 		identity().
 		translate(
 			lookFrom.clone().scale(-1.0f)
@@ -148,7 +148,7 @@ Matrix4x4& Camera::computeModelViewMatrix()
 				1.0f
 			)
 		);
-	return modelViewMatrix;
+	return cameraMatrix;
 }
 
 void Camera::update(int contextIdx, int32_t width, int32_t height)
@@ -193,8 +193,8 @@ void Camera::update(int contextIdx, int32_t width, int32_t height)
 	renderer->onUpdateCameraMatrix(contextIdx);
 
 	//
-	mvpInvertedMatrix.set(modelViewMatrix).multiply(projectionMatrix).invert();
-	mvpMatrix.set(modelViewMatrix).multiply(projectionMatrix);
+	mvpInvertedMatrix.set(cameraMatrix).multiply(projectionMatrix).invert();
+	mvpMatrix.set(cameraMatrix).multiply(projectionMatrix);
 
 	// viewport
 	renderer->setViewPort(width, height);
diff --git a/src/tdme/engine/Camera.h b/src/tdme/engine/Camera.h
index a9071513..e4e66f39 100644
--- a/src/tdme/engine/Camera.h
+++ b/src/tdme/engine/Camera.h
@@ -41,7 +41,7 @@ private:
 	Vector3 forwardVector;
 	Vector3 sideVector;
 	Matrix4x4 projectionMatrix;
-	Matrix4x4 modelViewMatrix;
+	Matrix4x4 cameraMatrix;
 	Matrix4x4 mvpMatrix;
 	Matrix4x4 mvpInvertedMatrix;
 	Frustum* frustum { nullptr };
@@ -238,10 +238,10 @@ public:
 	}
 
 	/**
-	 * @return model view matrix or camera matrix
+	 * @return camera matrix
 	 */
-	inline const Matrix4x4& getModelViewMatrix() const {
-		return modelViewMatrix;
+	inline const Matrix4x4& getCameraMatrix() const {
+		return cameraMatrix;
 	}
 
 	/**
diff --git a/src/tdme/engine/Engine.cpp b/src/tdme/engine/Engine.cpp
index 19acb46a..cb3d6526 100644
--- a/src/tdme/engine/Engine.cpp
+++ b/src/tdme/engine/Engine.cpp
@@ -252,8 +252,10 @@ void Engine::EngineThread::run() {
 Engine::Engine() {
 	timing = new Timing();
 	camera = nullptr;
+	gizmoCamera = nullptr;
 	sceneColor.set(0.0f, 0.0f, 0.0f, 1.0f);
 	frameBuffer = nullptr;
+	gizmoFrameBuffer = nullptr;
 	// shadow mapping
 	shadowMappingEnabled = false;
 	shadowMapping = nullptr;
@@ -276,9 +278,11 @@ Engine::Engine() {
 Engine::~Engine() {
 	delete timing;
 	delete camera;
+	delete gizmoCamera;
 	delete gui;
 	delete partition;
 	if (frameBuffer != nullptr) delete frameBuffer;
+	if (gizmoFrameBuffer != nullptr) delete gizmoFrameBuffer;
 	if (postProcessingFrameBuffer1 != nullptr) delete postProcessingFrameBuffer1;
 	if (postProcessingFrameBuffer2 != nullptr) delete postProcessingFrameBuffer2;
 	if (postProcessingTemporaryFrameBuffer != nullptr) delete postProcessingTemporaryFrameBuffer;
@@ -327,6 +331,14 @@ Engine* Engine::createOffScreenInstance(int32_t width, int32_t height, bool enab
 	offScreenEngine->frameBuffer->initialize();
 	// create camera, frustum partition
 	offScreenEngine->camera = new Camera(renderer);
+	offScreenEngine->gizmoCamera = new Camera(renderer);
+	offScreenEngine->gizmoCamera->setFrustumMode(Camera::FRUSTUMMODE_ORTHOGRAPHIC);
+	offScreenEngine->gizmoCamera->setCameraMode(Camera::CAMERAMODE_NONE);
+	offScreenEngine->gizmoCamera->setForwardVector(Vector3(0.0f, 0.0f, -1.0f));
+	offScreenEngine->gizmoCamera->setSideVector(Vector3(1.0f, 0.0f, 0.0f));
+	offScreenEngine->gizmoCamera->setUpVector(Vector3(0.0f, 1.0f, 0.0f));
+	offScreenEngine->gizmoCamera->setZNear(1.0f);
+	offScreenEngine->gizmoCamera->setZFar(400.0f);
 	offScreenEngine->partition = new OctTreePartition();
 	// create lights
 	for (auto i = 0; i < offScreenEngine->lights.size(); i++) {
@@ -432,12 +444,13 @@ void Engine::registerEntity(Entity* entity) {
 	// decompose to Object3D instances to do pre render
 	DecomposedEntities decomposedEntities;
 	decomposeEntityType(entity, decomposedEntities, true);
-	array<vector<Object3D*>, 5> objectsArray = {
+	array<vector<Object3D*>, 6> objectsArray = {
 		decomposedEntities.ezrObjects,
 		decomposedEntities.objects,
 		decomposedEntities.objectsForwardShading,
 		decomposedEntities.objectsNoDepthTest,
 		decomposedEntities.objectsPostPostProcessing,
+		decomposedEntities.objectsGizmo,
 	};
 	for (auto& objects: objectsArray) {
 		for (auto object3D: objects) {
@@ -514,6 +527,14 @@ inline void Engine::removeFromDecomposedEntities(DecomposedEntities& decomposedE
 		),
 		decomposedEntities.objectsNoDepthTest.end()
 	);
+	decomposedEntities.objectsGizmo.erase(
+		remove(
+			decomposedEntities.objectsGizmo.begin(),
+			decomposedEntities.objectsGizmo.end(),
+			entity
+		),
+		decomposedEntities.objectsGizmo.end()
+	);
 	decomposedEntities.lodObjects.erase(
 		remove(
 			decomposedEntities.lodObjects.begin(),
@@ -732,6 +753,14 @@ void Engine::initialize()
 
 	// create camera
 	camera = new Camera(renderer);
+	gizmoCamera = new Camera(renderer);
+	gizmoCamera->setFrustumMode(Camera::FRUSTUMMODE_ORTHOGRAPHIC);
+	gizmoCamera->setCameraMode(Camera::CAMERAMODE_NONE);
+	gizmoCamera->setForwardVector(Vector3(0.0f, 0.0f, -1.0f));
+	gizmoCamera->setSideVector(Vector3(1.0f, 0.0f, 0.0f));
+	gizmoCamera->setUpVector(Vector3(0.0f, 1.0f, 0.0f));
+	gizmoCamera->setZNear(1.0f);
+	gizmoCamera->setZFar(300.0f);
 
 	// create lights
 	for (auto i = 0; i < lights.size(); i++) {
@@ -973,6 +1002,7 @@ void Engine::resetLists(DecomposedEntities& decomposedEntites) {
 	decomposedEntites.objectsForwardShading.clear();
 	decomposedEntites.objectsPostPostProcessing.clear();
 	decomposedEntites.objectsNoDepthTest.clear();
+	decomposedEntites.objectsGizmo.clear();
 	decomposedEntites.lodObjects.clear();
 	decomposedEntites.opses.clear();
 	decomposedEntites.ppses.clear();
@@ -1012,12 +1042,16 @@ inline void Engine::decomposeEntityType(Entity* entity, DecomposedEntities& deco
 		case Entity::ENTITYTYPE_OBJECT3D:
 			{
 				auto object = static_cast<Object3D*>(entity);
+
 				if (object->isDisableDepthTest() == true) {
 					decomposedEntities.objectsNoDepthTest.push_back(object);
 				} else
 				if (object->getRenderPass() == Entity::RENDERPASS_POST_POSTPROCESSING) {
 					decomposedEntities.objectsPostPostProcessing.push_back(object);
 				} else
+				if (object->getRenderPass() == Entity::RENDERPASS_GIZMO) {
+					decomposedEntities.objectsGizmo.push_back(object);
+				} else
 				if (object->isNeedsForwardShading() == true &&
 					(object->getRenderPass() == Entity::RENDERPASS_TERRAIN || object->getRenderPass() == Entity::RENDERPASS_STANDARD) &&
 					renderer->isDeferredShadingAvailable() == true) {
@@ -1356,6 +1390,7 @@ void Engine::display()
 				render(
 					effectPassFrameBuffers[frameBufferIdx],
 					nullptr, // TODO: we might want to use a deferred shading here for further effects
+					camera,
 					visibleDecomposedEntities,
 					effectPassIdx,
 					Entity::RENDERPASS_ALL,
@@ -1426,6 +1461,7 @@ void Engine::display()
 	render(
 		renderFrameBuffer,
 		geometryBuffer,
+		camera,
 		visibleDecomposedEntities,
 		EFFECTPASS_NONE,
 		Entity::RENDERPASS_ALL,
@@ -1466,14 +1502,14 @@ void Engine::display()
 	camera->update(renderer->CONTEXTINDEX_DEFAULT, _width, _height);
 }
 
-void Engine::computeWorldCoordinateByMousePosition(int32_t mouseX, int32_t mouseY, float z, Vector3& worldCoordinate)
+void Engine::computeWorldCoordinateByMousePosition(int32_t mouseX, int32_t mouseY, float z, Vector3& worldCoordinate, Camera* camera)
 {
 	auto scaleFactorWidth = static_cast<float>(scaledWidth != -1?scaledWidth:width) / static_cast<float>(width);
 	auto scaleFactorHeight = static_cast<float>(scaledHeight != -1?scaledHeight:height) / static_cast<float>(height);
 	auto _width = scaledWidth != -1?scaledWidth:width;
 	auto _height = scaledHeight != -1?scaledHeight:height;
 	// see: http://stackoverflow.com/questions/7692988/opengl-math-projecting-screen-space-to-world-space-coords-solved
-	auto worldCoordinate4 = camera->getModelViewProjectionInvertedMatrix().multiply(
+	auto worldCoordinate4 = (camera == nullptr?this->camera:camera)->getModelViewProjectionInvertedMatrix().multiply(
 		Vector4(
 			(2.0f * (mouseX * scaleFactorWidth) / _width) - 1.0f,
 			1.0f - (2.0f * (mouseY * scaleFactorHeight) / _height),
@@ -1489,7 +1525,7 @@ void Engine::computeWorldCoordinateByMousePosition(int32_t mouseX, int32_t mouse
 	);
 }
 
-void Engine::computeWorldCoordinateByMousePosition(int32_t mouseX, int32_t mouseY, Vector3& worldCoordinate)
+void Engine::computeWorldCoordinateByMousePosition(int32_t mouseX, int32_t mouseY, Vector3& worldCoordinate, Camera* camera)
 {
 	// use framebuffer if we have one
 	if (frameBuffer != nullptr)
@@ -1507,7 +1543,7 @@ void Engine::computeWorldCoordinateByMousePosition(int32_t mouseX, int32_t mouse
 		FrameBuffer::disableFrameBuffer();
 
 	//
-	computeWorldCoordinateByMousePosition(mouseX, mouseY, z, worldCoordinate);
+	computeWorldCoordinateByMousePosition(mouseX, mouseY, z, worldCoordinate, camera);
 }
 
 Entity* Engine::getEntityByMousePosition(
@@ -1525,8 +1561,6 @@ Entity* Engine::getEntityByMousePosition(
 	Vector3 tmpVector3c;
 	Vector3 tmpVector3d;
 	Vector3 tmpVector3e;
-	computeWorldCoordinateByMousePosition(mouseX, mouseY, 0.0f, tmpVector3a);
-	computeWorldCoordinateByMousePosition(mouseX, mouseY, 1.0f, tmpVector3b);
 
 	// selected entity
 	auto selectedEntityDistance = Float::MAX_VALUE;
@@ -1534,6 +1568,50 @@ Entity* Engine::getEntityByMousePosition(
 	Node* selectedObject3DNode = nullptr;
 	ParticleSystemEntity* selectedParticleSystem = nullptr;
 
+	//
+	// iterate gizmo objects that have no depth test, check if ray with given mouse position from near plane to far plane collides with each object's triangles
+	if (decomposedEntities.objectsGizmo.empty() == false) {
+		//
+		computeWorldCoordinateByMousePosition(mouseX, mouseY, 0.0f, tmpVector3a, gizmoCamera);
+		computeWorldCoordinateByMousePosition(mouseX, mouseY, 1.0f, tmpVector3b, gizmoCamera);
+
+		//
+		for (auto entity: decomposedEntities.objectsGizmo) {
+			// skip if not pickable or ignored by filter
+			if (forcePicking == false && entity->isPickable() == false) continue;
+			if (filter != nullptr && filter->filterEntity(entity) == false) continue;
+			// do the collision test
+			for (auto it = entity->getTransformedFacesIterator()->iterator(); it->hasNext();) {
+				auto& vertices = it->next();
+				if (LineSegment::doesLineSegmentCollideWithTriangle(vertices[0], vertices[1], vertices[2], tmpVector3a, tmpVector3b, tmpVector3e) == true) {
+					auto entityDistance = tmpVector3e.sub(tmpVector3a).computeLengthSquared();
+					// check if match or better match
+					if (selectedEntity == nullptr || entityDistance < selectedEntityDistance) {
+						selectedEntity = entity;
+						selectedEntityDistance = entityDistance;
+						selectedObject3DNode = it->getNode();
+						selectedParticleSystem = nullptr;
+					}
+				}
+			}
+		}
+
+		// they have first priority right now
+		if (selectedEntity != nullptr) {
+			if (object3DNode != nullptr) *object3DNode = selectedObject3DNode;
+			for (auto _entity = selectedEntity; _entity != nullptr; _entity = _entity->getParentEntity()) {
+				if (_entity->getParentEntity() == nullptr) {
+					return _entity;
+				}
+			}
+			return nullptr;
+		}
+	}
+
+	//
+	computeWorldCoordinateByMousePosition(mouseX, mouseY, 0.0f, tmpVector3a);
+	computeWorldCoordinateByMousePosition(mouseX, mouseY, 1.0f, tmpVector3b);
+
 	// iterate visible objects that have no depth test, check if ray with given mouse position from near plane to far plane collides with each object's triangles
 	for (auto entity: decomposedEntities.objectsNoDepthTest) {
 		// skip if not pickable or ignored by filter
@@ -1905,7 +1983,7 @@ bool Engine::computeScreenCoordinateByWorldCoordinate(const Vector3& worldCoordi
 	// convert to screen coordinate
 	screenCoordinate.setX((screenCoordinate4[0] + 1.0f) * _width / 2.0f);
 	screenCoordinate.setY(_height - ((screenCoordinate4[1] + 1.0f) * _height / 2.0f));
-	return camera->getModelViewMatrix().multiply(worldCoordinate).getZ() <= 0.0f;
+	return camera->getCameraMatrix().multiply(worldCoordinate).getZ() <= 0.0f;
 }
 
 void Engine::dispose()
@@ -2144,7 +2222,7 @@ const map<string, ShaderParameter> Engine::getShaderParameterDefaults(const stri
 	return shaderIt->second.parameterDefaults;
 }
 
-void Engine::render(FrameBuffer* renderFrameBuffer, GeometryBuffer* renderGeometryBuffer, DecomposedEntities& visibleDecomposedEntities, int32_t effectPass, int32_t renderPassMask, const string& shaderPrefix, bool useEZR, bool applyShadowMapping, bool applyPostProcessing, bool doRenderLightSource, bool doRenderParticleSystems, int32_t renderTypes) {
+void Engine::render(FrameBuffer* renderFrameBuffer, GeometryBuffer* renderGeometryBuffer, Camera* rendererCamera, DecomposedEntities& visibleDecomposedEntities, int32_t effectPass, int32_t renderPassMask, const string& shaderPrefix, bool useEZR, bool applyShadowMapping, bool applyPostProcessing, bool doRenderLightSource, bool doRenderParticleSystems, int32_t renderTypes) {
 	//
 	Engine::renderer->setEffectPass(effectPass);
 	Engine::renderer->setShaderPrefix(shaderPrefix);
@@ -2406,6 +2484,66 @@ void Engine::render(FrameBuffer* renderFrameBuffer, GeometryBuffer* renderGeomet
 		}
 	}
 
+	// render gizmo objects
+	if (visibleDecomposedEntities.objectsGizmo.size() > 0) {
+		// default context
+		auto _width = renderFrameBuffer != nullptr?renderFrameBuffer->getWidth():(scaledWidth != -1?scaledWidth:width);
+		auto _height = renderFrameBuffer != nullptr?renderFrameBuffer->getHeight():(scaledHeight != -1?scaledHeight:height);
+
+		if (gizmoFrameBuffer == nullptr) {
+			gizmoFrameBuffer = new FrameBuffer(_width, _height, FrameBuffer::FRAMEBUFFER_DEPTHBUFFER | FrameBuffer::FRAMEBUFFER_COLORBUFFER);
+			gizmoFrameBuffer->setColorBufferTextureId(frameBuffer->getColorBufferTextureId());
+		} else
+		if (gizmoFrameBuffer->getWidth() != _width || gizmoFrameBuffer->getHeight() != _height) {
+			gizmoFrameBuffer->reshape(_width, _height);
+		}
+
+		//
+		gizmoCamera->setLookFrom(rendererCamera->getLookFrom());
+		gizmoCamera->update(renderer->CONTEXTINDEX_DEFAULT, _width, _height);
+
+		gizmoFrameBuffer->enableFrameBuffer();
+		renderer->clear(renderer->CLEAR_DEPTH_BUFFER_BIT);
+
+		// use lighting shader
+		if (lightingShader != nullptr) {
+			lightingShader->useProgram(this);
+		}
+
+		// render
+		entityRenderer->render(
+			Entity::RENDERPASS_GIZMO,
+			visibleDecomposedEntities.objectsGizmo,
+			true,
+			((renderTypes & EntityRenderer::RENDERTYPE_NORMALS) == EntityRenderer::RENDERTYPE_NORMALS?EntityRenderer::RENDERTYPE_NORMALS:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_TEXTUREARRAYS) == EntityRenderer::RENDERTYPE_TEXTUREARRAYS?EntityRenderer::RENDERTYPE_TEXTUREARRAYS:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_TEXTUREARRAYS_DIFFUSEMASKEDTRANSPARENCY) == EntityRenderer::RENDERTYPE_TEXTUREARRAYS_DIFFUSEMASKEDTRANSPARENCY?EntityRenderer::RENDERTYPE_TEXTUREARRAYS_DIFFUSEMASKEDTRANSPARENCY:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_EFFECTCOLORS) == EntityRenderer::RENDERTYPE_EFFECTCOLORS?EntityRenderer::RENDERTYPE_EFFECTCOLORS:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_MATERIALS) == EntityRenderer::RENDERTYPE_MATERIALS?EntityRenderer::RENDERTYPE_MATERIALS:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_MATERIALS_DIFFUSEMASKEDTRANSPARENCY) == EntityRenderer::RENDERTYPE_MATERIALS_DIFFUSEMASKEDTRANSPARENCY?EntityRenderer::RENDERTYPE_MATERIALS_DIFFUSEMASKEDTRANSPARENCY:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_TEXTURES) == EntityRenderer::RENDERTYPE_TEXTURES?EntityRenderer::RENDERTYPE_TEXTURES:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_TEXTURES_DIFFUSEMASKEDTRANSPARENCY) == EntityRenderer::RENDERTYPE_TEXTURES_DIFFUSEMASKEDTRANSPARENCY?EntityRenderer::RENDERTYPE_TEXTURES_DIFFUSEMASKEDTRANSPARENCY:0)|
+			((renderTypes & EntityRenderer::RENDERTYPE_LIGHTS) == EntityRenderer::RENDERTYPE_LIGHTS?EntityRenderer::RENDERTYPE_LIGHTS:0)
+		);
+
+		// render transparent faces
+		entityRenderer->renderTransparentFaces();
+
+		//
+		if (renderFrameBuffer != nullptr) {
+			renderFrameBuffer->enableFrameBuffer();
+		} else {
+			FrameBuffer::disableFrameBuffer();
+		}
+
+		// unuse lighting shader
+		if (lightingShader != nullptr) lightingShader->unUseProgram();
+
+		//
+		rendererCamera->update(renderer->CONTEXTINDEX_DEFAULT, _width, _height);
+	}
+
+	// light sources
 	if (doRenderLightSource == true) {
 		auto _width = scaledWidth != -1?scaledWidth:width;
 		auto _height = scaledHeight != -1?scaledHeight:height;
diff --git a/src/tdme/engine/Engine.h b/src/tdme/engine/Engine.h
index de663cbf..afb3a5e1 100644
--- a/src/tdme/engine/Engine.h
+++ b/src/tdme/engine/Engine.h
@@ -228,6 +228,7 @@ private:
 		vector<Object3D*> objectsForwardShading;
 		vector<Object3D*> objectsPostPostProcessing;
 		vector<Object3D*> objectsNoDepthTest;
+		vector<Object3D*> objectsGizmo;
 		vector<LODObject3D*> lodObjects;
 		vector<LODObject3DImposter*> lodObjectsImposter;
 		vector<ObjectParticleSystem*> opses;
@@ -251,6 +252,7 @@ private:
 	GUI* gui { nullptr };
 	Timing* timing { nullptr };
 	Camera* camera { nullptr };
+	Camera* gizmoCamera { nullptr };
 
 	Partition* partition { nullptr };
 
@@ -258,6 +260,7 @@ private:
 	Color4 sceneColor;
 	GeometryBuffer* geometryBuffer { nullptr };
 	FrameBuffer* frameBuffer { nullptr };
+	FrameBuffer* gizmoFrameBuffer { nullptr };
 	FrameBuffer* postProcessingFrameBuffer1 { nullptr };
 	FrameBuffer* postProcessingFrameBuffer2{ nullptr };
 	FrameBuffer* postProcessingTemporaryFrameBuffer { nullptr };
@@ -1038,14 +1041,26 @@ public:
 	 */
 	void display();
 
+	/**
+	 * Compute gizmo coordinate from mouse position and z value
+	 * @param mouseX mouse x
+	 * @param mouseY mouse y
+	 * @param z z
+	 * @param gizmoCoordinate gizmo coordinate
+	 */
+	inline void computeGizmoCoordinateByMousePosition(int32_t mouseX, int32_t mouseY, float z, Vector3& gizmoCoordinate) {
+		return computeWorldCoordinateByMousePosition(mouseX, mouseY, z, gizmoCoordinate, gizmoCamera);
+	}
+
 	/**
 	 * Compute world coordinate from mouse position and z value
 	 * @param mouseX mouse x
 	 * @param mouseY mouse y
 	 * @param z z
 	 * @param worldCoordinate world coordinate
+	 * @param camera camera or engine camera
 	 */
-	void computeWorldCoordinateByMousePosition(int32_t mouseX, int32_t mouseY, float z, Vector3& worldCoordinate);
+	void computeWorldCoordinateByMousePosition(int32_t mouseX, int32_t mouseY, float z, Vector3& worldCoordinate, Camera* camera = nullptr);
 
 	/**
 	 * Compute world coordinate from mouse position
@@ -1054,8 +1069,9 @@ public:
 	 * @param mouseX mouse x
 	 * @param mouseY mouse y
 	 * @param worldCoordinate world coordinate
+	 * @param camera camera or engine camera
 	 */
-	void computeWorldCoordinateByMousePosition(int32_t mouseX, int32_t mouseY, Vector3& worldCoordinate);
+	void computeWorldCoordinateByMousePosition(int32_t mouseX, int32_t mouseY, Vector3& worldCoordinate, Camera* camera = nullptr);
 
 	/**
 	 * Retrieves entity by mouse position
@@ -1254,6 +1270,7 @@ private:
 	 * Do a render/effect pass
 	 * @param renderFrameBuffer render frame buffer
 	 * @param renderGeometryBuffer render geometry buffer
+	 * @param rendererCamera renderer camera
 	 * @param visibleDecomposedEntities visible decomposed entities
 	 * @param effectPass effect pass
 	 * @param renderPassMask render pass mask
@@ -1265,7 +1282,7 @@ private:
 	 * @param doRenderParticleSystems if to render particle systems
 	 * @param renderTypes render types
 	 */
-	void render(FrameBuffer* renderFrameBuffer, GeometryBuffer* renderGeometryBuffer, DecomposedEntities& visibleDecomposedEntities, int32_t effectPass, int32_t renderPassMask, const string& shaderPrefix, bool useEZR, bool applyShadowMapping, bool applyPostProcessing, bool doRenderLightSource, bool doRenderParticleSystems, int32_t renderTypes);
+	void render(FrameBuffer* renderFrameBuffer, GeometryBuffer* renderGeometryBuffer, Camera* rendererCamera, DecomposedEntities& visibleDecomposedEntities, int32_t effectPass, int32_t renderPassMask, const string& shaderPrefix, bool useEZR, bool applyShadowMapping, bool applyPostProcessing, bool doRenderLightSource, bool doRenderParticleSystems, int32_t renderTypes);
 
 	/**
 	 * Render light sources
diff --git a/src/tdme/engine/Entity.h b/src/tdme/engine/Entity.h
index e4bab5fe..651aae8f 100644
--- a/src/tdme/engine/Entity.h
+++ b/src/tdme/engine/Entity.h
@@ -54,8 +54,8 @@ private:
 
 public:
 	static constexpr int RENDERPASS_MAX { 5 };
-	static constexpr int RENDERPASS_ALL { 1 + 2 + 4 + 8 + 16 };
-	enum RenderPass { RENDERPASS_NONE = 0, RENDERPASS_SKY = 1, RENDERPASS_NOFRUSTUMCULLING = 1, RENDERPASS_TERRAIN = 2, RENDERPASS_STANDARD = 4, RENDERPASS_WATER = 8, RENDERPASS_POST_POSTPROCESSING = 16 };
+	static constexpr int RENDERPASS_ALL { 1 + 2 + 4 + 8 + 16 + 32 };
+	enum RenderPass { RENDERPASS_NONE = 0, RENDERPASS_SKY = 1, RENDERPASS_NOFRUSTUMCULLING = 1, RENDERPASS_TERRAIN = 2, RENDERPASS_STANDARD = 4, RENDERPASS_WATER = 8, RENDERPASS_POST_POSTPROCESSING = 16, RENDERPASS_GIZMO = 32 };
 
 	enum EntityType {
 		ENTITYTYPE_ENTITYHIERARCHY,
diff --git a/src/tdme/engine/FrameBuffer.cpp b/src/tdme/engine/FrameBuffer.cpp
index e2ddfaec..f4744b96 100644
--- a/src/tdme/engine/FrameBuffer.cpp
+++ b/src/tdme/engine/FrameBuffer.cpp
@@ -32,11 +32,17 @@ FrameBuffer::FrameBuffer(int32_t width, int32_t height, int32_t buffers, int32_t
 
 void FrameBuffer::initialize()
 {
-	if ((buffers & FRAMEBUFFER_DEPTHBUFFER) == FRAMEBUFFER_DEPTHBUFFER)
-		depthBufferTextureId = Engine::renderer->createDepthBufferTexture(width, height, cubeMapTextureId, cubeMapTextureIndex);
+	if ((buffers & FRAMEBUFFER_DEPTHBUFFER) == FRAMEBUFFER_DEPTHBUFFER) {
+		if (depthBufferTextureId == Engine::renderer->ID_NONE) {
+			depthBufferTextureId = Engine::renderer->createDepthBufferTexture(width, height, cubeMapTextureId, cubeMapTextureIndex);
+		}
+	}
 
-	if ((buffers & FRAMEBUFFER_COLORBUFFER) == FRAMEBUFFER_COLORBUFFER && (Engine::renderer->getRendererType() == Renderer::RENDERERTYPE_VULKAN || cubeMapTextureId == CUBEMAPTEXTUREID_NONE))
-		colorBufferTextureId = Engine::renderer->createColorBufferTexture(width, height, cubeMapTextureId, cubeMapTextureIndex);
+	if ((buffers & FRAMEBUFFER_COLORBUFFER) == FRAMEBUFFER_COLORBUFFER && (Engine::renderer->getRendererType() == Renderer::RENDERERTYPE_VULKAN || cubeMapTextureId == TEXTUREID_NONE)) {
+		if (colorBufferTextureId == Engine::renderer->ID_NONE) {
+			colorBufferTextureId = Engine::renderer->createColorBufferTexture(width, height, cubeMapTextureId, cubeMapTextureIndex);
+		}
+	}
 
 	auto rendererCubeMapTextureIndex = -1;
 	switch(cubeMapTextureIndex) {
@@ -57,7 +63,7 @@ void FrameBuffer::reshape(int32_t width, int32_t height)
 	if ((buffers & FRAMEBUFFER_DEPTHBUFFER) == FRAMEBUFFER_DEPTHBUFFER)
 		Engine::renderer->resizeDepthBufferTexture(depthBufferTextureId, width, height);
 
-	if ((buffers & FRAMEBUFFER_COLORBUFFER) == FRAMEBUFFER_COLORBUFFER && cubeMapTextureId == CUBEMAPTEXTUREID_NONE)
+	if ((buffers & FRAMEBUFFER_COLORBUFFER) == FRAMEBUFFER_COLORBUFFER && cubeMapTextureId == TEXTUREID_NONE)
 		Engine::renderer->resizeColorBufferTexture(colorBufferTextureId, width, height);
 
 	this->width = width;
@@ -69,7 +75,7 @@ void FrameBuffer::dispose()
 	if ((buffers & FRAMEBUFFER_DEPTHBUFFER) == FRAMEBUFFER_DEPTHBUFFER)
 		Engine::renderer->disposeTexture(depthBufferTextureId);
 
-	if ((buffers & FRAMEBUFFER_COLORBUFFER) == FRAMEBUFFER_COLORBUFFER && cubeMapTextureId == CUBEMAPTEXTUREID_NONE)
+	if ((buffers & FRAMEBUFFER_COLORBUFFER) == FRAMEBUFFER_COLORBUFFER && cubeMapTextureId == TEXTUREID_NONE)
 		Engine::renderer->disposeTexture(colorBufferTextureId);
 
 	Engine::renderer->disposeFrameBufferObject(frameBufferId);
diff --git a/src/tdme/engine/FrameBuffer.h b/src/tdme/engine/FrameBuffer.h
index 00f63e3a..2daf367d 100644
--- a/src/tdme/engine/FrameBuffer.h
+++ b/src/tdme/engine/FrameBuffer.h
@@ -24,7 +24,7 @@ public:
 	static constexpr int32_t FRAMEBUFFER_DEPTHBUFFER { 1 };
 	static constexpr int32_t FRAMEBUFFER_COLORBUFFER { 2 };
 
-	static constexpr int32_t CUBEMAPTEXTUREID_NONE { 0 };
+	static constexpr int32_t TEXTUREID_NONE { 0 };
 
 	static constexpr int32_t CUBEMAPTEXTUREINDEX_NONE { 0 };
 	static constexpr int32_t CUBEMAPTEXTUREINDEX_NEGATIVE_X { 1 };
@@ -61,7 +61,7 @@ public:
 	 * @param cubeMapTextureId cube map texture id
 	 * @param cubeMapTextureIndex cube map texture index
 	 */
-	FrameBuffer(int32_t width, int32_t height, int32_t buffers, int32_t cubeMapTextureId = CUBEMAPTEXTUREID_NONE, int32_t cubeMapTextureIndex = CUBEMAPTEXTUREINDEX_NONE);
+	FrameBuffer(int32_t width, int32_t height, int32_t buffers, int32_t cubeMapTextureId = TEXTUREID_NONE, int32_t cubeMapTextureIndex = TEXTUREID_NONE);
 
 	/**
 	 * @return width
@@ -91,6 +91,14 @@ public:
 		return depthBufferTextureId;
 	}
 
+	/**
+	 * Set depth buffer texture id
+	 * @param texture id depth buffer texture id
+	 */
+	inline void setDepthBufferTextureId(int32_t textureId) {
+		depthBufferTextureId = textureId;
+	}
+
 	/**
 	 * @return color buffer texture id
 	 */
@@ -98,6 +106,14 @@ public:
 		return colorBufferTextureId;
 	}
 
+	/**
+	 * Set color buffer texture id
+	 * @param textureId color buffer texture id
+	 */
+	inline void setColorBufferTextureId(int32_t textureId) {
+		colorBufferTextureId = textureId;
+	}
+
 	/**
 	 * Initialize the frame buffer
 	 */
diff --git a/src/tdme/engine/subsystems/environmentmapping/EnvironmentMappingRenderer.cpp b/src/tdme/engine/subsystems/environmentmapping/EnvironmentMappingRenderer.cpp
index aace997f..2a245c46 100644
--- a/src/tdme/engine/subsystems/environmentmapping/EnvironmentMappingRenderer.cpp
+++ b/src/tdme/engine/subsystems/environmentmapping/EnvironmentMappingRenderer.cpp
@@ -184,6 +184,7 @@ void EnvironmentMappingRenderer::render(const Vector3& position)
 			engine->render(
 				frameBuffers[renderCubeMapTextureIdx][i],
 				geometryBuffer,
+				camera,
 				visibleDecomposedEntities,
 				Engine::EFFECTPASS_NONE,
 				renderPassMask,
diff --git a/src/tdme/engine/subsystems/framebuffer/DeferredLightingRenderShader.cpp b/src/tdme/engine/subsystems/framebuffer/DeferredLightingRenderShader.cpp
index b71d7740..6fc35047 100644
--- a/src/tdme/engine/subsystems/framebuffer/DeferredLightingRenderShader.cpp
+++ b/src/tdme/engine/subsystems/framebuffer/DeferredLightingRenderShader.cpp
@@ -249,7 +249,7 @@ void DeferredLightingRenderShader::useProgram(Engine* engine)
 		renderer->setProgramUniformFloat(contextIdx, uniformSpecularLightQuadraticAttenuation[lightId], light->getQuadraticAttenuation());
 		renderer->setProgramUniformFloat(contextIdx, uniformSpecularLightRadius[lightId], light->getRadius());
 	}
-	renderer->setProgramUniformFloatMatrix4x4(contextIdx, uniformCameraMatrix, engine->getCamera()->getModelViewMatrix().getArray());
+	renderer->setProgramUniformFloatMatrix4x4(contextIdx, uniformCameraMatrix, engine->getCamera()->getCameraMatrix().getArray());
 
 	// PBR
 	renderer->setProgramUniformFloatVec3(contextIdx, uniformCamera, renderer->getCameraPosition().getArray());
diff --git a/src/tdme/engine/subsystems/rendering/EntityRenderer.cpp b/src/tdme/engine/subsystems/rendering/EntityRenderer.cpp
index dea03b9e..93907804 100644
--- a/src/tdme/engine/subsystems/rendering/EntityRenderer.cpp
+++ b/src/tdme/engine/subsystems/rendering/EntityRenderer.cpp
@@ -442,6 +442,8 @@ void EntityRenderer::renderObjectsOfSameTypeNonInstanced(const vector<Object3D*>
 	Vector3 boundEnvironmentMappingCubeMapPosition;
 	for (auto object3DNodeIdx = 0; object3DNodeIdx < firstObject->object3dNodes.size(); object3DNodeIdx++) {
 		auto object3DNode = firstObject->object3dNodes[object3DNodeIdx];
+		// TODO: check me to remove this update here later
+		if (object3DNode->nodeTransformationsMatrixUpdate == true) object3DNode->updateNodeTransformationsMatrix();
 		// render each faces entity
 		auto& facesEntities = object3DNode->node->getFacesEntities();
 		auto faceIdx = 0;
@@ -727,6 +729,8 @@ void EntityRenderer::renderObjectsOfSameTypeInstanced(int threadIdx, const vecto
 	// all objects share the same object 3d node structure, so we just take the first one
 	for (auto object3DNodeIdx = 0; object3DNodeIdx < firstObject->object3dNodes.size(); object3DNodeIdx++) {
 		auto object3DNode = firstObject->object3dNodes[object3DNodeIdx];
+		// TODO: check me to remove this update here later
+		if (object3DNode->nodeTransformationsMatrixUpdate == true) object3DNode->updateNodeTransformationsMatrix();
 		// render each faces entity
 		auto& facesEntities = object3DNode->node->getFacesEntities();
 		auto faceIdx = 0;
diff --git a/src/tdme/engine/subsystems/rendering/Object3DBase.h b/src/tdme/engine/subsystems/rendering/Object3DBase.h
index fd65e992..54585167 100644
--- a/src/tdme/engine/subsystems/rendering/Object3DBase.h
+++ b/src/tdme/engine/subsystems/rendering/Object3DBase.h
@@ -263,6 +263,7 @@ public:
 	 */
 	inline void setNodeTransformationsMatrix(const string& id, const Matrix4x4& matrix) {
 		instanceAnimations[currentInstance]->setNodeTransformationsMatrix(id, matrix);
+		for (auto object3dNode: object3dNodes) object3dNode->nodeTransformationsMatrixUpdate = true;
 	}
 
 	/**
@@ -271,6 +272,7 @@ public:
 	 */
 	inline void unsetNodeTransformationsMatrix(const string& id) {
 		instanceAnimations[currentInstance]->unsetNodeTransformationsMatrix(id);
+		for (auto object3dNode: object3dNodes) object3dNode->nodeTransformationsMatrixUpdate = true;
 	}
 
 	/**
diff --git a/src/tdme/engine/subsystems/rendering/Object3DNode.cpp b/src/tdme/engine/subsystems/rendering/Object3DNode.cpp
index 84e44687..159f996e 100644
--- a/src/tdme/engine/subsystems/rendering/Object3DNode.cpp
+++ b/src/tdme/engine/subsystems/rendering/Object3DNode.cpp
@@ -62,6 +62,20 @@ Object3DNode::~Object3DNode()
 	delete renderer;
 }
 
+void Object3DNode::updateNodeTransformationsMatrix() {
+	nodeTransformationsMatrix = nullptr;
+	auto overriddenTransformationsMatricesIt = object->instanceAnimations[0]->overriddenTransformationsMatrices.find(node->getId());
+	if (overriddenTransformationsMatricesIt != object->instanceAnimations[0]->overriddenTransformationsMatrices.end()) {
+		nodeTransformationsMatrix = overriddenTransformationsMatricesIt->second;
+	} else {
+		auto transformationsMatricesIt = object->instanceAnimations[0]->transformationsMatrices[0].find(node->getId());
+		if (transformationsMatricesIt != object->instanceAnimations[0]->transformationsMatrices[0].end()) {
+			nodeTransformationsMatrix = transformationsMatricesIt->second;
+		}
+	}
+	nodeTransformationsMatrixUpdate = false;
+}
+
 void Object3DNode::createNodes(Object3DBase* object, bool useManagers, Engine::AnimationProcessingTarget animationProcessingTarget, vector<Object3DNode*>& object3DNodes)
 {
 	auto model = object->getModel();
@@ -158,8 +172,8 @@ void Object3DNode::createNodes(Object3DBase* object3D, const map<string, Node*>&
 				object3DNode->pbrMaterialMetallicRoughnessTextureIdsByEntities[j] = TEXTUREID_NONE;
 				object3DNode->pbrMaterialNormalTextureIdsByEntities[j] = TEXTUREID_NONE;
 			}
-			// determine node transformations matrix
-			object3DNode->nodeTransformationsMatrix = object3D->instanceAnimations[0]->transformationsMatrices[0].find(node->getId())->second;
+			// update node transformations matrix
+			object3DNode->updateNodeTransformationsMatrix();
 		}
 		// but still check sub nodes
 		createNodes(object3D, node->getSubNodes(), animated, useManagers, animationProcessingTarget, object3DNodes);
diff --git a/src/tdme/engine/subsystems/rendering/Object3DNode.h b/src/tdme/engine/subsystems/rendering/Object3DNode.h
index 1c88b635..4d9823c4 100644
--- a/src/tdme/engine/subsystems/rendering/Object3DNode.h
+++ b/src/tdme/engine/subsystems/rendering/Object3DNode.h
@@ -69,6 +69,7 @@ private:
 	vector<int32_t> pbrMaterialNormalTextureIdsByEntities;
 	Object3DNodeRenderer* renderer { nullptr };
 	Object3DNodeMesh* mesh { nullptr };
+	bool nodeTransformationsMatrixUpdate { false };
 	Matrix4x4* nodeTransformationsMatrix { nullptr };
 
 	/**
@@ -123,4 +124,17 @@ public:
 	 * Destructor
 	 */
 	~Object3DNode();
+
+	/**
+	 * @return needs node transformations matrix
+	 */
+	inline bool needsNodeTransformationsMatrix() {
+		return nodeTransformationsMatrixUpdate == true;
+	}
+
+	/**
+	 * Update node transformations matrix
+	 */
+	void updateNodeTransformationsMatrix();
+
 };
diff --git a/src/tdme/tools/editor/misc/Gizmo.cpp b/src/tdme/tools/editor/misc/Gizmo.cpp
index def49fcd..cd356630 100644
--- a/src/tdme/tools/editor/misc/Gizmo.cpp
+++ b/src/tdme/tools/editor/misc/Gizmo.cpp
@@ -9,6 +9,7 @@
 #include <tdme/engine/Entity.h>
 #include <tdme/engine/Frustum.h>
 #include <tdme/engine/Object3D.h>
+#include <tdme/engine/Transformations.h>
 #include <tdme/math/Matrix4x4.h>
 #include <tdme/math/Quaternion.h>
 #include <tdme/math/Vector3.h>
@@ -27,6 +28,7 @@ using tdme::engine::Engine;
 using tdme::engine::Entity;
 using tdme::engine::Frustum;
 using tdme::engine::Object3D;
+using tdme::engine::Transformations;
 using tdme::math::Matrix4x4;
 using tdme::math::Quaternion;
 using tdme::math::Vector3;
@@ -49,34 +51,15 @@ Gizmo::~Gizmo() {
 }
 
 void Gizmo::updateGizmo(const Vector3& gizmoCenter, const Transformations& transformations) {
+	this->gizmoTranslation = gizmoCenter;
 	Object3D* gizmoEntity = nullptr;
-	auto zNearNormal = engine->getCamera()->getFrustum()->getPlanes()[Frustum::PLANE_NEAR].getNormal();
-	auto lookFrom = engine->getCamera()->getLookFrom();
-	auto zNearDistance = engine->getCamera()->getFrustum()->getPlanes()[Frustum::PLANE_NEAR].computeDistance(gizmoCenter);
-	Vector3 a,b,c,d;
-	Vector4 e;
-	Quaternion q1, q2;
-	q1.rotate(zNearNormal, -45.0f);
-	q2.rotate(zNearNormal, 135.0f);
-	e = engine->getCamera()->getModelViewProjectionMatrix().multiply(Vector4(lookFrom + zNearNormal * 1.0f + q1.multiply(Vector3(0.0f, -0.5f, 0.0f)), 1.0f));
-	e.scale(1.0f / e.getW());
-	a.set(e.getX(), e.getY(), e.getZ());
-	e = engine->getCamera()->getModelViewProjectionMatrix().multiply(Vector4(lookFrom + zNearNormal * 1.0f + q2.multiply(Vector3(0.0f, -0.5f, 0.0f)), 1.0f));
-	e.scale(1.0f / e.getW());
-	b.set(e.getX(), e.getY(), e.getZ());
-	e = engine->getCamera()->getModelViewProjectionMatrix().multiply(Vector4(lookFrom + zNearNormal * zNearDistance + q1.multiply(Vector3(0.0f, -0.5f, 0.0f)), 1.0f));
-	e.scale(1.0f / e.getW());
-	c.set(e.getX(), e.getY(), e.getZ());
-	e = engine->getCamera()->getModelViewProjectionMatrix().multiply(Vector4(lookFrom + zNearNormal * zNearDistance + q2.multiply(Vector3(0.0f, -0.5f, 0.0f)), 1.0f));
-	e.scale(1.0f / e.getW());
-	d.set(e.getX(), e.getY(), e.getZ());
-	auto baX = b.getX() - a.getX();
-	auto baY = b.getY() - a.getY();
-	auto dcX = d.getX() - c.getX();
-	auto dcY = d.getY() - c.getY();
-	auto baXDivdcX = baX / dcX;
-	auto baYDivdcY = baY / dcY;
-	auto scale = baXDivdcX / 3.0f ;
+	auto scale = 150.0f;
+	Vector4 orthogonalGizmoCenterNDC = engine->getCamera()->getModelViewProjectionMatrix().multiply(Vector4(gizmoCenter, 1.0f));
+	orthogonalGizmoCenterNDC.scale(1.0f / orthogonalGizmoCenterNDC.getW());
+	Vector3 orthogonalGizmoCenter;
+	orthogonalGizmoCenter.setX(orthogonalGizmoCenterNDC.getX() * (engine->getWidth() * 0.5f));
+	orthogonalGizmoCenter.setY(orthogonalGizmoCenterNDC.getY() * (engine->getHeight() * 0.5f));
+	orthogonalGizmoCenter.setZ(-200.0f);
 	switch (getGizmoType()) {
 		case GIZMOTYPE_ALL:
 			{
@@ -88,15 +71,17 @@ void Gizmo::updateGizmo(const Vector3& gizmoCenter, const Transformations& trans
 					gizmoEntity = dynamic_cast<Object3D*>(engine->getEntity(id + ".tdme.gizmo.all"));
 					if (gizmoEntity == nullptr) engine->addEntity(gizmoEntity = new Object3D(id + ".tdme.gizmo.all", Tools::getGizmoAll()));
 					gizmoEntity->setPickable(true);
-					gizmoEntity->setDisableDepthTest(true);
-					gizmoEntity->setTranslation(gizmoCenter);
+					gizmoEntity->setFrustumCulling(false);
+					gizmoEntity->setRenderPass(Entity::RENDERPASS_GIZMO);
+					gizmoEntity->setTranslation(orthogonalGizmoCenter);
 					gizmoEntity->setScale(Vector3(scale, scale, scale));
 					gizmoEntity->update();
 					gizmoEntity = dynamic_cast<Object3D*>(engine->getEntity(id + ".tdme.gizmo.rotations"));
 					if (gizmoEntity == nullptr) engine->addEntity(gizmoEntity = new Object3D(id + ".tdme.gizmo.rotations", Tools::getGizmoRotations()));
 					gizmoEntity->setPickable(true);
-					gizmoEntity->setDisableDepthTest(true);
-					gizmoEntity->setTranslation(gizmoCenter);
+					gizmoEntity->setFrustumCulling(false);
+					gizmoEntity->setRenderPass(Entity::RENDERPASS_GIZMO);
+					gizmoEntity->setTranslation(orthogonalGizmoCenter);
 					gizmoEntity->setScale(Vector3(scale, scale, scale));
 					gizmoEntity->update();
 				} else
@@ -108,8 +93,9 @@ void Gizmo::updateGizmo(const Vector3& gizmoCenter, const Transformations& trans
 					gizmoEntity = dynamic_cast<Object3D*>(engine->getEntity(id + ".tdme.gizmo.all"));
 					if (gizmoEntity == nullptr) engine->addEntity(gizmoEntity = new Object3D(id + ".tdme.gizmo.all", Tools::getGizmoTranslationScale()));
 					gizmoEntity->setPickable(true);
-					gizmoEntity->setDisableDepthTest(true);
-					gizmoEntity->setTranslation(gizmoCenter);
+					gizmoEntity->setFrustumCulling(false);
+					gizmoEntity->setRenderPass(Entity::RENDERPASS_GIZMO);
+					gizmoEntity->setTranslation(orthogonalGizmoCenter);
 					gizmoEntity->setScale(Vector3(scale, scale, scale));
 					gizmoEntity->update();
 				} else {
@@ -120,8 +106,9 @@ void Gizmo::updateGizmo(const Vector3& gizmoCenter, const Transformations& trans
 						gizmoEntity = dynamic_cast<Object3D*>(engine->getEntity(id + ".tdme.gizmo.translation"));
 						if (gizmoEntity == nullptr) engine->addEntity(gizmoEntity = new Object3D(id + ".tdme.gizmo.translation", Tools::getGizmoTranslation()));
 						gizmoEntity->setPickable(true);
-						gizmoEntity->setDisableDepthTest(true);
-						gizmoEntity->setTranslation(gizmoCenter);
+						gizmoEntity->setFrustumCulling(false);
+						gizmoEntity->setRenderPass(Entity::RENDERPASS_GIZMO);
+						gizmoEntity->setTranslation(orthogonalGizmoCenter);
 						gizmoEntity->setScale(Vector3(scale, scale, scale));
 						gizmoEntity->update();
 					}
@@ -132,8 +119,8 @@ void Gizmo::updateGizmo(const Vector3& gizmoCenter, const Transformations& trans
 						gizmoEntity = dynamic_cast<Object3D*>(engine->getEntity(id + ".tdme.gizmo.rotations"));
 						if (gizmoEntity == nullptr) engine->addEntity(gizmoEntity = new Object3D(id + ".tdme.gizmo.rotations", Tools::getGizmoRotations()));
 						gizmoEntity->setPickable(true);
-						gizmoEntity->setDisableDepthTest(true);
-						gizmoEntity->setTranslation(gizmoCenter);
+						gizmoEntity->setRenderPass(Entity::RENDERPASS_GIZMO);
+						gizmoEntity->setTranslation(orthogonalGizmoCenter);
 						gizmoEntity->setScale(Vector3(scale, scale, scale));
 						gizmoEntity->update();
 					}
@@ -144,8 +131,9 @@ void Gizmo::updateGizmo(const Vector3& gizmoCenter, const Transformations& trans
 						gizmoEntity = dynamic_cast<Object3D*>(engine->getEntity(id + ".tdme.gizmo.scale"));
 						if (gizmoEntity == nullptr) engine->addEntity(gizmoEntity = new Object3D(id + ".tdme.gizmo.scale", Tools::getGizmoScale()));
 						gizmoEntity->setPickable(true);
-						gizmoEntity->setDisableDepthTest(true);
-						gizmoEntity->setTranslation(gizmoCenter);
+						gizmoEntity->setFrustumCulling(false);
+						gizmoEntity->setRenderPass(Entity::RENDERPASS_GIZMO);
+						gizmoEntity->setTranslation(orthogonalGizmoCenter);
 						gizmoEntity->setScale(Vector3(scale, scale, scale));
 						gizmoEntity->update();
 					}
@@ -160,8 +148,9 @@ void Gizmo::updateGizmo(const Vector3& gizmoCenter, const Transformations& trans
 				gizmoEntity = dynamic_cast<Object3D*>(engine->getEntity(id + ".tdme.gizmo.translation"));
 				if (gizmoEntity == nullptr) engine->addEntity(gizmoEntity = new Object3D(id + ".tdme.gizmo.translation", Tools::getGizmoTranslation()));
 				gizmoEntity->setPickable(true);
-				gizmoEntity->setDisableDepthTest(true);
-				gizmoEntity->setTranslation(gizmoCenter);
+				gizmoEntity->setFrustumCulling(false);
+				gizmoEntity->setRenderPass(Entity::RENDERPASS_GIZMO);
+				gizmoEntity->setTranslation(orthogonalGizmoCenter);
 				gizmoEntity->setScale(Vector3(scale, scale, scale));
 				gizmoEntity->update();
 				break;
@@ -174,8 +163,9 @@ void Gizmo::updateGizmo(const Vector3& gizmoCenter, const Transformations& trans
 				gizmoEntity = dynamic_cast<Object3D*>(engine->getEntity(id + ".tdme.gizmo.rotations"));
 				if (gizmoEntity == nullptr) engine->addEntity(gizmoEntity = new Object3D(id + ".tdme.gizmo.rotations", Tools::getGizmoRotations()));
 				gizmoEntity->setPickable(true);
-				gizmoEntity->setDisableDepthTest(true);
-				gizmoEntity->setTranslation(gizmoCenter);
+				gizmoEntity->setFrustumCulling(false);
+				gizmoEntity->setRenderPass(Entity::RENDERPASS_GIZMO);
+				gizmoEntity->setTranslation(orthogonalGizmoCenter);
 				gizmoEntity->setScale(Vector3(scale, scale, scale));
 				gizmoEntity->update();
 				break;
@@ -188,8 +178,9 @@ void Gizmo::updateGizmo(const Vector3& gizmoCenter, const Transformations& trans
 				gizmoEntity = dynamic_cast<Object3D*>(engine->getEntity(id + ".tdme.gizmo.scale"));
 				if (gizmoEntity == nullptr) engine->addEntity(gizmoEntity = new Object3D(id + ".tdme.gizmo.scale", Tools::getGizmoScale()));
 				gizmoEntity->setPickable(true);
-				gizmoEntity->setDisableDepthTest(true);
-				gizmoEntity->setTranslation(gizmoCenter);
+				gizmoEntity->setFrustumCulling(false);
+				gizmoEntity->setRenderPass(Entity::RENDERPASS_GIZMO);
+				gizmoEntity->setTranslation(orthogonalGizmoCenter);
 				gizmoEntity->setScale(Vector3(scale, scale, scale));
 				gizmoEntity->update();
 				break;
@@ -217,15 +208,13 @@ void Gizmo::removeGizmo() {
 }
 
 bool Gizmo::determineGizmoMovement(int mouseX, int mouseY, vector<Vector3> vertices, Vector3& deltaMovement) {
-	auto gizmoEntity = getGizmoObject3D();
-	if (gizmoEntity == nullptr) return false;
 	Vector3 tmpVector3a;
 	Vector3 tmpVector3b;
 	Vector3 tmpVector3e;
 	engine->computeWorldCoordinateByMousePosition(mouseX, mouseY, 0.0f, tmpVector3a);
 	engine->computeWorldCoordinateByMousePosition(mouseX, mouseY, 1.0f, tmpVector3b);
 	for (auto& vertex: vertices) {
-		vertex.add(gizmoEntity->getTranslation());
+		vertex.add(gizmoTranslation);
 	}
 	if (LineSegment::doesLineSegmentCollideWithTriangle(
 		vertices[0],
@@ -426,44 +415,81 @@ bool Gizmo::determineGizmoMode(Entity* selectedEntity, Node* selectedEntityNode)
 }
 
 void Gizmo::setGizmoRotation(const Transformations& transformations) {
-	auto rotationsMatrix = transformations.getRotationsQuaternion().computeMatrix();
+	auto cameraMatrixEuler = engine->getCamera()->getCameraMatrix().computeEulerAngles();
+	Transformations cameraRotationTransformations;
+	cameraRotationTransformations.addRotation(Vector3(0.0f, 0.0f, -1.0f), cameraMatrixEuler.getZ());
+	cameraRotationTransformations.addRotation(Vector3(0.0f, 1.0f, 0.0f), cameraMatrixEuler.getY());
+	cameraRotationTransformations.addRotation(Vector3(1.0f, 0.0f, 0.0f), cameraMatrixEuler.getX());
+	cameraRotationTransformations.update();
+	auto _transformations = transformations;
+	// auto _scale = _transformations.getScale();
+	auto rotationY = _transformations.getRotationAngle(1);
+	auto rotationZ = _transformations.getRotationAngle(0);
+	// do not do negative scale on gizmo
+	// if (_scale.getX() < 0.0f) _scale.setX(-_scale.getX());
+	// if (_scale.getY() < 0.0f) _scale.setY(-_scale.getY());
+	// if (_scale.getZ() < 0.0f) _scale.setZ(-_scale.getZ());
+	// swap Y and Z
+	_transformations.setRotationAngle(1, rotationZ);
+	_transformations.setRotationAngle(0, rotationY);
+	//_transformations.setScale(_scale);
+	_transformations.update();
+	//
+	auto rotationsMatrix = _transformations.getRotationsQuaternion().computeMatrix();
 	{
-		auto gizmoEntity = dynamic_cast<Object3D*>(engine->getEntity(id + ".tdme.gizmo.scale"));
+		auto gizmoEntity = dynamic_cast<Object3D*>(engine->getEntity(id + ".tdme.gizmo.translation"));
 		if (gizmoEntity != nullptr) {
-			gizmoEntity->setNodeTransformationsMatrix("scale_x", gizmoEntity->getModel()->getNodeById("scale_x")->getTransformationsMatrix().clone().multiply(rotationsMatrix));
-			gizmoEntity->setNodeTransformationsMatrix("scale_y", gizmoEntity->getModel()->getNodeById("scale_y")->getTransformationsMatrix().clone().multiply(rotationsMatrix));
-			gizmoEntity->setNodeTransformationsMatrix("scale_z", gizmoEntity->getModel()->getNodeById("scale_z")->getTransformationsMatrix().clone().multiply(rotationsMatrix));
-			gizmoEntity->setNodeTransformationsMatrix("scale_x_plane", gizmoEntity->getModel()->getNodeById("scale_x_plane")->getTransformationsMatrix().clone().multiply(rotationsMatrix));
-			gizmoEntity->setNodeTransformationsMatrix("scale_y_plane", gizmoEntity->getModel()->getNodeById("scale_y_plane")->getTransformationsMatrix().clone().multiply(rotationsMatrix));
-			gizmoEntity->setNodeTransformationsMatrix("scale_z_plane", gizmoEntity->getModel()->getNodeById("scale_x_plane")->getTransformationsMatrix().clone().multiply(rotationsMatrix));
+			cameraRotationTransformations.setTranslation(gizmoEntity->getTranslation());
+			cameraRotationTransformations.setScale(gizmoEntity->getScale());
+			cameraRotationTransformations.update();
+			gizmoEntity->fromTransformations(cameraRotationTransformations);
 			gizmoEntity->update();
+			Console::println("translation");
 		}
 	}
 	{
 		auto gizmoEntity = dynamic_cast<Object3D*>(engine->getEntity(id + ".tdme.gizmo.rotations"));
 		if (gizmoEntity != nullptr) {
-			gizmoEntity->setNodeTransformationsMatrix("rotate_x", gizmoEntity->getModel()->getNodeById("rotate_x")->getTransformationsMatrix().clone().multiply(rotationsMatrix));
-			gizmoEntity->setNodeTransformationsMatrix("rotate_y", gizmoEntity->getModel()->getNodeById("rotate_y")->getTransformationsMatrix().clone().multiply(rotationsMatrix));
-			gizmoEntity->setNodeTransformationsMatrix("rotate_z", gizmoEntity->getModel()->getNodeById("rotate_z")->getTransformationsMatrix().clone().multiply(rotationsMatrix));
+			cameraRotationTransformations.setTranslation(gizmoEntity->getTranslation());
+			cameraRotationTransformations.setScale(gizmoEntity->getScale());
+			cameraRotationTransformations.update();
+			gizmoEntity->fromTransformations(cameraRotationTransformations);
+			gizmoEntity->setNodeTransformationsMatrix("rotate_x", rotationsMatrix);
+			gizmoEntity->setNodeTransformationsMatrix("rotate_y", rotationsMatrix);
+			gizmoEntity->setNodeTransformationsMatrix("rotate_z", rotationsMatrix);
+			gizmoEntity->update();
+			Console::println("rotations");
+		}
+	}
+	{
+		auto gizmoEntity = dynamic_cast<Object3D*>(engine->getEntity(id + ".tdme.gizmo.scale"));
+		if (gizmoEntity != nullptr) {
+			cameraRotationTransformations.setTranslation(gizmoEntity->getTranslation());
+			cameraRotationTransformations.setScale(gizmoEntity->getScale());
+			cameraRotationTransformations.update();
+			gizmoEntity->fromTransformations(cameraRotationTransformations);
+			gizmoEntity->setNodeTransformationsMatrix("scale_x", rotationsMatrix);
+			gizmoEntity->setNodeTransformationsMatrix("scale_y", rotationsMatrix);
+			gizmoEntity->setNodeTransformationsMatrix("scale_z", rotationsMatrix);
+			gizmoEntity->setNodeTransformationsMatrix("scale_x_plane", rotationsMatrix);
+			gizmoEntity->setNodeTransformationsMatrix("scale_y_plane", rotationsMatrix);
+			gizmoEntity->setNodeTransformationsMatrix("scale_z_plane", rotationsMatrix);
 			gizmoEntity->update();
+			Console::println("scale");
 		}
 	}
 	{
 		auto gizmoEntity = dynamic_cast<Object3D*>(engine->getEntity(id + ".tdme.gizmo.all"));
 		if (gizmoEntity != nullptr) {
-			if (gizmoEntity->getModel()->getNodeById("all_scale_x") != nullptr) gizmoEntity->setNodeTransformationsMatrix("all_scale_x", gizmoEntity->getModel()->getNodeById("all_scale_x")->getTransformationsMatrix().clone().multiply(rotationsMatrix));
-			if (gizmoEntity->getModel()->getNodeById("all_scale_y") != nullptr) gizmoEntity->setNodeTransformationsMatrix("all_scale_y", gizmoEntity->getModel()->getNodeById("all_scale_y")->getTransformationsMatrix().clone().multiply(rotationsMatrix));
-			if (gizmoEntity->getModel()->getNodeById("all_scale_z") != nullptr) gizmoEntity->setNodeTransformationsMatrix("all_scale_z", gizmoEntity->getModel()->getNodeById("all_scale_z")->getTransformationsMatrix().clone().multiply(rotationsMatrix));
-			if (gizmoEntity->getModel()->getNodeById("scale_x") != nullptr) gizmoEntity->setNodeTransformationsMatrix("scale_x", gizmoEntity->getModel()->getNodeById("scale_x")->getTransformationsMatrix().clone().multiply(rotationsMatrix));
-			if (gizmoEntity->getModel()->getNodeById("scale_y") != nullptr) gizmoEntity->setNodeTransformationsMatrix("scale_y", gizmoEntity->getModel()->getNodeById("scale_y")->getTransformationsMatrix().clone().multiply(rotationsMatrix));
-			if (gizmoEntity->getModel()->getNodeById("scale_z") != nullptr) gizmoEntity->setNodeTransformationsMatrix("scale_z", gizmoEntity->getModel()->getNodeById("scale_z")->getTransformationsMatrix().clone().multiply(rotationsMatrix));
-			if (gizmoEntity->getModel()->getNodeById("scale_x_plane") != nullptr) gizmoEntity->setNodeTransformationsMatrix("scale_x_plane", gizmoEntity->getModel()->getNodeById("scale_x_plane")->getTransformationsMatrix().clone().multiply(rotationsMatrix));
-			if (gizmoEntity->getModel()->getNodeById("scale_y_plane") != nullptr) gizmoEntity->setNodeTransformationsMatrix("scale_y_plane", gizmoEntity->getModel()->getNodeById("scale_y_plane")->getTransformationsMatrix().clone().multiply(rotationsMatrix));
-			if (gizmoEntity->getModel()->getNodeById("scale_z_plane") != nullptr) gizmoEntity->setNodeTransformationsMatrix("scale_z_plane", gizmoEntity->getModel()->getNodeById("scale_x_plane")->getTransformationsMatrix().clone().multiply(rotationsMatrix));
-			if (gizmoEntity->getModel()->getNodeById("rotate_x") != nullptr) gizmoEntity->setNodeTransformationsMatrix("rotate_x", gizmoEntity->getModel()->getNodeById("rotate_x")->getTransformationsMatrix().clone().multiply(rotationsMatrix));
-			if (gizmoEntity->getModel()->getNodeById("rotate_y") != nullptr) gizmoEntity->setNodeTransformationsMatrix("rotate_y", gizmoEntity->getModel()->getNodeById("rotate_y")->getTransformationsMatrix().clone().multiply(rotationsMatrix));
-			if (gizmoEntity->getModel()->getNodeById("rotate_z") != nullptr) gizmoEntity->setNodeTransformationsMatrix("rotate_z", gizmoEntity->getModel()->getNodeById("rotate_z")->getTransformationsMatrix().clone().multiply(rotationsMatrix));
+			cameraRotationTransformations.setTranslation(gizmoEntity->getTranslation());
+			cameraRotationTransformations.setScale(gizmoEntity->getScale());
+			cameraRotationTransformations.update();
+			gizmoEntity->fromTransformations(cameraRotationTransformations);
+			gizmoEntity->setNodeTransformationsMatrix("all_scale_x", rotationsMatrix);
+			gizmoEntity->setNodeTransformationsMatrix("all_scale_y", rotationsMatrix);
+			gizmoEntity->setNodeTransformationsMatrix("all_scale_z", rotationsMatrix);
 			gizmoEntity->update();
+			Console::println("all");
 		}
 	}
 }
diff --git a/src/tdme/tools/editor/misc/Gizmo.h b/src/tdme/tools/editor/misc/Gizmo.h
index 99674269..cfb4d87f 100644
--- a/src/tdme/tools/editor/misc/Gizmo.h
+++ b/src/tdme/tools/editor/misc/Gizmo.h
@@ -56,6 +56,7 @@ private:
 	string id;
 	GizmoType gizmoType;
 	GizmoMode gizmoMode;
+	Vector3 gizmoTranslation;
 	Vector3 gizmoLastResult;
 	bool gizmoLastResultAvailable;
 	int32_t gizmoTypeMask;
@@ -176,6 +177,13 @@ public:
 	 */
 	bool determineGizmoMode(Entity* selectedEntity, Node* selectedEntityNode);
 
+	/**
+	 * @return gizmo translation
+	 */
+	inline Vector3 getGizmoTranslation() {
+		return gizmoTranslation;
+	}
+
 	/**
 	 * Set gizmo rotation
 	 * @param transformations transformations containing rotations
diff --git a/src/tdme/tools/editor/misc/Tools.cpp b/src/tdme/tools/editor/misc/Tools.cpp
index cbe5aa8c..df99a58a 100644
--- a/src/tdme/tools/editor/misc/Tools.cpp
+++ b/src/tdme/tools/editor/misc/Tools.cpp
@@ -607,6 +607,7 @@ Model* Tools::getGizmoAll() {
 Model* Tools::getGizmoTranslationScale() {
 	if (gizmoTranslationScale == nullptr) {
 		gizmoTranslationScale = ModelReader::read("resources/engine/models", "gizmo_transscale.tm");
+		ModelTools::prepareForShader(gizmoTranslationScale);
 	}
 	return gizmoTranslationScale;
 }
@@ -614,6 +615,7 @@ Model* Tools::getGizmoTranslationScale() {
 Model* Tools::getGizmoTranslation() {
 	if (gizmoTranslation == nullptr) {
 		gizmoTranslation = ModelReader::read("resources/engine/models", "gizmo_translate.tm");
+		ModelTools::prepareForShader(gizmoTranslation);
 	}
 	return gizmoTranslation;
 }
@@ -621,6 +623,7 @@ Model* Tools::getGizmoTranslation() {
 Model* Tools::getGizmoScale() {
 	if (gizmoScale == nullptr) {
 		gizmoScale = ModelReader::read("resources/engine/models", "gizmo_scale.tm");
+		ModelTools::prepareForShader(gizmoScale);
 	}
 	return gizmoScale;
 }
@@ -628,6 +631,7 @@ Model* Tools::getGizmoScale() {
 Model* Tools::getGizmoRotations() {
 	if (gizmoRotations == nullptr) {
 		gizmoRotations = ModelReader::read("resources/engine/models", "gizmo_rotate.tm");
+		ModelTools::prepareForShader(gizmoRotations);
 	}
 	return gizmoRotations;
 }
diff --git a/src/tdme/tools/editor/tabviews/SceneEditorTabView.cpp b/src/tdme/tools/editor/tabviews/SceneEditorTabView.cpp
index 22757136..c16489b6 100644
--- a/src/tdme/tools/editor/tabviews/SceneEditorTabView.cpp
+++ b/src/tdme/tools/editor/tabviews/SceneEditorTabView.cpp
@@ -165,6 +165,10 @@ SceneEditorTabView::SceneEditorTabView(EditorView* editorView, const string& tab
 		entityPickingFilterPlacing = new PrototypePickingFilterPlacing(this);
 	}
 
+	//
+	Console::println(scene->getRotationOrder()->getName());
+
+
 	//
 	outlinerState.expandedOutlinerParentOptionValues.push_back("scene");
 }
@@ -324,7 +328,7 @@ void SceneEditorTabView::handleInputEvents()
 									auto sceneEntity = scene->getEntity(_selectedEntity->getId());
 									if (sceneEntity == nullptr) continue;
 									auto translation = sceneEntity->getTransformations().getTranslation();
-									translation = gizmoEntity->getTranslation().clone().add(rotations.getRotationsQuaternion().multiply(translation.clone().sub(gizmoEntity->getTranslation())));
+									translation = getGizmoTranslation().clone().add(rotations.getRotationsQuaternion().multiply(translation.clone().sub(getGizmoTranslation())));
 									sceneEntity->getTransformations().setTranslation(translation.clone().add(deltaTranslation));
 									auto scale = sceneEntity->getTransformations().getScale().clone().scale(absoluteScale);
 									if (Math::abs(scale.getX()) < 0.01f) scale.setX(Math::sign(scale.getX()) * 0.01f);
@@ -1114,7 +1118,7 @@ void SceneEditorTabView::updateGizmo() {
 		if (selectedEntity != nullptr && StringTools::startsWith(selectedEntity->getId(), "tdme.sceneeditor.") == false) {
 			auto sceneEntity = scene->getEntity(selectedEntity->getId());
 			if (sceneEntity == nullptr) continue;
-			gizmoCenter.add(sceneEntity->getTransformations().getTranslation());
+			gizmoCenter.add(selectedEntity->getBoundingBoxTransformed()->getCenter());
 			entityCount++;
 		}
 	}
diff --git a/src/tdme/utilities/ModelTools.cpp b/src/tdme/utilities/ModelTools.cpp
index fc159012..c6b467ed 100644
--- a/src/tdme/utilities/ModelTools.cpp
+++ b/src/tdme/utilities/ModelTools.cpp
@@ -716,16 +716,13 @@ int ModelTools::determineFaceCount(Node* node) {
 
 void ModelTools::prepareForShader(Model* model, const string& shader) {
 	if (shader == "foliage" || shader == "pbr-foliage" || shader == "tree" || shader == "pbr-tree") {
-		for (auto nodeIt: model->getSubNodes()) prepareForFoliageTreeShader(nodeIt.second, model->getImportTransformationsMatrix(), shader);
+		for (auto nodeIt: model->getSubNodes()) prepareForFoliageShader(nodeIt.second, model->getImportTransformationsMatrix(), shader);
 		model->setImportTransformationsMatrix(Matrix4x4().identity());
 		model->setUpVector(UpVector::Y_UP);
-	} else
-	if (shader == "water") {
-		for (auto nodeIt: model->getSubNodes()) prepareForWaterShader(nodeIt.second, model->getImportTransformationsMatrix());
+	} else {
+		for (auto nodeIt: model->getSubNodes()) prepareForStandardShader(nodeIt.second, model->getImportTransformationsMatrix());
 		model->setImportTransformationsMatrix(Matrix4x4().identity());
 		model->setUpVector(UpVector::Y_UP);
-	} else {
-		for (auto nodeIt: model->getSubNodes()) prepareForDefaultShader(nodeIt.second);
 	}
 }
 
@@ -737,7 +734,7 @@ void ModelTools::prepareForDefaultShader(Node* node) {
 	}
 }
 
-void ModelTools::prepareForFoliageTreeShader(Node* node, const Matrix4x4& parentTransformationsMatrix, const string& shader) {
+void ModelTools::prepareForFoliageShader(Node* node, const Matrix4x4& parentTransformationsMatrix, const string& shader) {
 	vector<Vector3> objectOrigins;
 	objectOrigins.resize(node->getVertices().size());
 	auto transformationsMatrix = node->getTransformationsMatrix().clone().multiply(parentTransformationsMatrix);
@@ -778,11 +775,11 @@ void ModelTools::prepareForFoliageTreeShader(Node* node, const Matrix4x4& parent
 	node->setTransformationsMatrix(Matrix4x4().identity());
 	node->setOrigins(objectOrigins);
 	for (auto nodeIt: node->getSubNodes()) {
-		prepareForFoliageTreeShader(nodeIt.second, transformationsMatrix, shader);
+		prepareForFoliageShader(nodeIt.second, transformationsMatrix, shader);
 	}
 }
 
-void ModelTools::prepareForWaterShader(Node* node, const Matrix4x4& parentTransformationsMatrix) {
+void ModelTools::prepareForStandardShader(Node* node, const Matrix4x4& parentTransformationsMatrix) {
 	auto transformationsMatrix = node->getTransformationsMatrix().clone().multiply(parentTransformationsMatrix);
 	{
 		auto vertices = node->getVertices();
@@ -818,7 +815,7 @@ void ModelTools::prepareForWaterShader(Node* node, const Matrix4x4& parentTransf
 	}
 	node->setTransformationsMatrix(Matrix4x4().identity());
 	for (auto nodeIt: node->getSubNodes()) {
-		prepareForWaterShader(nodeIt.second, transformationsMatrix);
+		prepareForStandardShader(nodeIt.second, transformationsMatrix);
 	}
 }
 
diff --git a/src/tdme/utilities/ModelTools.h b/src/tdme/utilities/ModelTools.h
index 48c7a8a7..11ced8ee 100644
--- a/src/tdme/utilities/ModelTools.h
+++ b/src/tdme/utilities/ModelTools.h
@@ -261,11 +261,11 @@ public:
 	static void computeNormals(Model* model, ProgressCallback* progressCallback = nullptr);
 
 	/**
-	 * Prepare model for foliage shader
+	 * Prepare model for specific shader
 	 * @param model model
-	 * @param shader shader
+	 * @param shader optional shader
 	 */
-	static void prepareForShader(Model* model, const string& shader);
+	static void prepareForShader(Model* model, const string& shader = string());
 
 	/**
 	 * @returns if model has been optimized
@@ -300,14 +300,14 @@ private:
 	 * @param parentTransformationsMatrix parent transformations matrix
 	 * @param shader shader
 	 */
-	static void prepareForFoliageTreeShader(Node* node, const Matrix4x4& parentTransformationsMatrix, const string& shader);
+	static void prepareForFoliageShader(Node* node, const Matrix4x4& parentTransformationsMatrix, const string& shader);
 
 	/**
 	 * Prepare node for water shader
 	 * @param node node
 	 * @param parentTransformationsMatrix parent transformations matrix
 	 */
-	static void prepareForWaterShader(Node* node, const Matrix4x4& parentTransformationsMatrix);
+	static void prepareForStandardShader(Node* node, const Matrix4x4& parentTransformationsMatrix);
 
 	/**
 	 * Check for optimization
