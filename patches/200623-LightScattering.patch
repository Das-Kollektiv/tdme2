diff --git a/README-WebReferences.md b/README-WebReferences.md
index c02063c6..caaa6122 100644
--- a/README-WebReferences.md
+++ b/README-WebReferences.md
@@ -6,6 +6,7 @@
   - http://chilliant.blogspot.com/2012/08/srgb-approximations-for-hlsl.html
   - http://db-in.com/blog/2011/04/cameras-on-opengl-es-2-x/
   - http://devcry.heiho.net/html/2015/20150517-libpng.html
+  - http://fabiensanglard.net/lightScattering/index.php
   - http://fabiensanglard.net/shadowmapping/index.php
   - http://filmicworlds.com/blog/filmic-tonemapping-operators/
   - http://learnwebgl.brown37.net/10_surface_properties/texture_mapping_transforms.html
diff --git a/README.md b/README.md
index 238f7154..e5fce4b7 100644
--- a/README.md
+++ b/README.md
@@ -216,6 +216,8 @@
     - documentation
 
 - What is WIP or planned
+    - Light scattering effect / effects
+    - Simple script language
     - Shader parameters
     - PBR lighting shader for GL3/CORE+
     - Makefile generator for TDME2 based projects
diff --git a/src/tdme/engine/Engine.cpp b/src/tdme/engine/Engine.cpp
index 389227dc..0e07ac97 100644
--- a/src/tdme/engine/Engine.cpp
+++ b/src/tdme/engine/Engine.cpp
@@ -677,13 +677,20 @@ void Engine::reshape(int32_t width, int32_t height)
 	this->width = width;
 	this->height = height;
 
+	//
+	int _width = scaledWidth != -1?scaledWidth:width;
+	int _height = scaledHeight != -1?scaledHeight:height;
+
 	// update frame buffer if we have one
-	if (frameBuffer != nullptr) frameBuffer->reshape(scaledWidth != -1?scaledWidth:width, scaledHeight != -1?scaledHeight:height);
+	if (frameBuffer != nullptr) frameBuffer->reshape(_width, _height);
 
 	// update post processing frame buffer if we have one
-	if (postProcessingFrameBuffer1 != nullptr) postProcessingFrameBuffer1->reshape(scaledWidth != -1?scaledWidth:width, scaledHeight != -1?scaledHeight:height);
-	if (postProcessingFrameBuffer2 != nullptr) postProcessingFrameBuffer2->reshape(scaledWidth != -1?scaledWidth:width, scaledHeight != -1?scaledHeight:height);
-	if (postProcessingTemporaryFrameBuffer != nullptr) postProcessingTemporaryFrameBuffer->reshape(scaledWidth != -1?scaledWidth:width, scaledHeight != -1?scaledHeight:height);
+	if (postProcessingFrameBuffer1 != nullptr) postProcessingFrameBuffer1->reshape(_width, _height);
+	if (postProcessingFrameBuffer2 != nullptr) postProcessingFrameBuffer2->reshape(_width, _height);
+	if (postProcessingTemporaryFrameBuffer != nullptr) postProcessingTemporaryFrameBuffer->reshape(_width, _height);
+	if (postProcessingTemporaryFrameBuffer != nullptr) postProcessingTemporaryFrameBuffer->reshape(_width, _height);
+	if (postProcessingTemporaryFrameBuffer != nullptr) postProcessingTemporaryFrameBuffer->reshape(_width, _height);
+	if (lightScatteringFrameBuffer != nullptr) lightScatteringFrameBuffer->reshape(_width, _height);
 
 	// update shadow mapping
 	if (shadowMapping != nullptr) shadowMapping->reshape(width, height);
@@ -1004,14 +1011,55 @@ void Engine::display()
 	// create shadow maps
 	if (shadowMapping != nullptr) shadowMapping->createShadowMaps();
 
+	//
+	auto _width = scaledWidth != -1?scaledWidth:width;
+	auto _height = scaledHeight != -1?scaledHeight:height;
+
+	// set up clear color
+	Engine::renderer->setClearColor(sceneColor.getRed(), sceneColor.getGreen(), sceneColor.getBlue(), sceneColor.getAlpha());
+
+	// light scattering frame buffer
+	if (lightScatteringEnabled == true) {
+		if (lightScatteringFrameBuffer == nullptr) {
+			lightScatteringFrameBuffer = new FrameBuffer(_width / 2, _height / 2, FrameBuffer::FRAMEBUFFER_COLORBUFFER);
+			lightScatteringFrameBuffer->initialize();
+		}
+		//
+		renderer->clear(renderer->CLEAR_DEPTH_BUFFER_BIT | renderer->CLEAR_COLOR_BUFFER_BIT);
+
+		// render to light scattering framebuffer
+		lightScatteringFrameBuffer->enableFrameBuffer();
+
+		// camera
+		camera->update(context, _width / 2, _height / 2);
+
+		// Do a render pass
+		render(
+			EFFECTPASS_LIGHTSCATTERING,
+			"ls_",
+			false,
+			false,
+			false,
+			EntityRenderer::RENDERTYPE_TEXTUREARRAYS_DIFFUSEMASKEDTRANSPARENCY |
+			EntityRenderer::RENDERTYPE_MATERIALS_DIFFUSEMASKEDTRANSPARENCY |
+			EntityRenderer::RENDERTYPE_TEXTURES_DIFFUSEMASKEDTRANSPARENCY
+		);
+	} else {
+		if (lightScatteringFrameBuffer != nullptr) {
+			lightScatteringFrameBuffer->dispose();
+			delete lightScatteringFrameBuffer;
+			lightScatteringFrameBuffer = nullptr;
+		}
+	}
+
 	// create post processing frame buffers if having post processing
 	if (postProcessingPrograms.size() > 0) {
 		if (postProcessingFrameBuffer1 == nullptr) {
-			postProcessingFrameBuffer1 = new FrameBuffer(scaledWidth != -1?scaledWidth:width, scaledHeight != -1?scaledHeight:height, FrameBuffer::FRAMEBUFFER_DEPTHBUFFER | FrameBuffer::FRAMEBUFFER_COLORBUFFER);
+			postProcessingFrameBuffer1 = new FrameBuffer(_width, _height, FrameBuffer::FRAMEBUFFER_DEPTHBUFFER | FrameBuffer::FRAMEBUFFER_COLORBUFFER);
 			postProcessingFrameBuffer1->initialize();
 		}
 		if (postProcessingFrameBuffer2 == nullptr) {
-			postProcessingFrameBuffer2 = new FrameBuffer(scaledWidth != -1?scaledWidth:width, scaledHeight != -1?scaledHeight:height, FrameBuffer::FRAMEBUFFER_DEPTHBUFFER | FrameBuffer::FRAMEBUFFER_COLORBUFFER);
+			postProcessingFrameBuffer2 = new FrameBuffer(_width, _height, FrameBuffer::FRAMEBUFFER_DEPTHBUFFER | FrameBuffer::FRAMEBUFFER_COLORBUFFER);
 			postProcessingFrameBuffer2->initialize();
 		}
 		postProcessingFrameBuffer1->enableFrameBuffer();
@@ -1034,141 +1082,20 @@ void Engine::display()
 		}
 	}
 
-	// set up clear color
-	Engine::renderer->setClearColor(sceneColor.getRed(), sceneColor.getGreen(), sceneColor.getBlue(), sceneColor.getAlpha());
-
 	// clear previous frame values
 	renderer->clear(renderer->CLEAR_DEPTH_BUFFER_BIT | renderer->CLEAR_COLOR_BUFFER_BIT);
 
-	// restore camera from shadow map rendering
-	camera->update(context, scaledWidth != -1?scaledWidth:width, scaledHeight != -1?scaledHeight:height);
-
-	// render lines objects
-	if (visibleLinesObjects.size() > 0) {
-		// use particle shader
-		if (linesShader != nullptr) linesShader->useProgram(context);
-
-		// render points based particle systems
-		object3DRenderer->render(visibleLinesObjects);
-
-		// unuse particle shader
-		if (linesShader != nullptr) linesShader->unUseProgram(context);
-	}
-
-	// do depth buffer writing aka early z rejection
-	if (ezrShaderPre != nullptr && visibleEZRObjects.size() > 0) {
-		// disable color rendering, we only want to write to the Z-Buffer
-		renderer->setColorMask(false, false, false, false);
-		// render
-		ezrShaderPre->useProgram(this);
-		// only draw opaque face entities of objects marked as EZR objects
-		object3DRenderer->render(
-			visibleEZRObjects,
-			false,
-			EntityRenderer::RENDERTYPE_TEXTUREARRAYS_DIFFUSEMASKEDTRANSPARENCY |
-			EntityRenderer::RENDERTYPE_TEXTURES_DIFFUSEMASKEDTRANSPARENCY
-		);
-		// done
-		ezrShaderPre->unUseProgram();
-		// restore disable color rendering
-		renderer->setColorMask(true, true, true, true);
-	}
-
-	// use lighting shader
-	if (visibleObjects.size() > 0) {
-		//
-		if (lightingShader != nullptr) lightingShader->useProgram(this);
-
-		// render objects
-		object3DRenderer->render(
-			visibleObjects,
-			true,
-			EntityRenderer::RENDERTYPE_NORMALS |
-			EntityRenderer::RENDERTYPE_TEXTUREARRAYS |
-			EntityRenderer::RENDERTYPE_TEXTUREARRAYS_DIFFUSEMASKEDTRANSPARENCY |
-			EntityRenderer::RENDERTYPE_EFFECTCOLORS |
-			EntityRenderer::RENDERTYPE_MATERIALS |
-			EntityRenderer::RENDERTYPE_MATERIALS_DIFFUSEMASKEDTRANSPARENCY |
-			EntityRenderer::RENDERTYPE_TEXTURES |
-			EntityRenderer::RENDERTYPE_TEXTURES_DIFFUSEMASKEDTRANSPARENCY |
-			EntityRenderer::RENDERTYPE_LIGHTS
-		);
-
-		// unuse lighting shader
-		if (lightingShader != nullptr) lightingShader->unUseProgram();
-
-		// render shadows if required
-		if (shadowMapping != nullptr) shadowMapping->renderShadowMaps(visibleObjects);
-	}
-
-	// do post processing
-	isUsingPostProcessingTemporaryFrameBuffer = false;
-	if (postProcessingPrograms.size() > 0) {
-		doPostProcessing(PostProcessingProgram::RENDERPASS_OBJECTS, {{postProcessingFrameBuffer1, postProcessingFrameBuffer2 }}, postProcessingFrameBuffer1);
-		postProcessingFrameBuffer1->enableFrameBuffer();
-	}
-
-	// render point particle systems
-	if (visiblePpses.size() > 0) {
-		// use particle shader
-		if (particlesShader != nullptr) particlesShader->useProgram(context);
-
-		// render points based particle systems
-		if (visiblePpses.size() > 0) object3DRenderer->render(visiblePpses);
-
-		// unuse particle shader
-		if (particlesShader != nullptr) particlesShader->unUseProgram(context);
-	}
-
-	// render objects and particles together
-	if (postProcessingPrograms.size() > 0) {
-		doPostProcessing(PostProcessingProgram::RENDERPASS_FINAL, {{postProcessingFrameBuffer1, postProcessingFrameBuffer2 }}, frameBuffer);
-	}
-
-	// render objects that are have post post processing render pass
-	if (visibleObjectsPostPostProcessing.size() > 0) {
-		// use lighting shader
-		if (lightingShader != nullptr) {
-			lightingShader->useProgram(this);
-		}
-
-		// render post processing objects
-		object3DRenderer->render(
-			visibleObjectsPostPostProcessing,
-			true,
-			EntityRenderer::RENDERTYPE_NORMALS |
-			EntityRenderer::RENDERTYPE_TEXTUREARRAYS |
-			EntityRenderer::RENDERTYPE_TEXTUREARRAYS_DIFFUSEMASKEDTRANSPARENCY |
-			EntityRenderer::RENDERTYPE_EFFECTCOLORS |
-			EntityRenderer::RENDERTYPE_MATERIALS |
-			EntityRenderer::RENDERTYPE_MATERIALS_DIFFUSEMASKEDTRANSPARENCY |
-			EntityRenderer::RENDERTYPE_TEXTURES |
-			EntityRenderer::RENDERTYPE_TEXTURES_DIFFUSEMASKEDTRANSPARENCY |
-			EntityRenderer::RENDERTYPE_LIGHTS
-		);
-
-		// unuse lighting shader
-		if (lightingShader != nullptr) lightingShader->unUseProgram();
-
-		// render shadows if required
-		if (shadowMapping != nullptr) shadowMapping->renderShadowMaps(visibleObjectsPostPostProcessing);
-	}
-
-	// render objects that are have post post processing render pass
-	if (visibleObjectsNoDepthTest.size() > 0) {
-		// use lighting shader
-		if (lightingShader != nullptr) {
-			lightingShader->useProgram(this);
-		}
-
-		//
-		renderer->disableDepthBufferTest();
-
-		// render post processing objects
-		object3DRenderer->render(
-			visibleObjectsNoDepthTest,
-			true,
-			EntityRenderer::RENDERTYPE_NORMALS |
+	// camera
+	camera->update(context, _width, _height);
+
+	// Do a render pass
+	render(
+		EFFECTPASS_NONE,
+		string(),
+		true,
+		true,
+		true,
+		EntityRenderer::RENDERTYPE_NORMALS |
 			EntityRenderer::RENDERTYPE_TEXTUREARRAYS |
 			EntityRenderer::RENDERTYPE_TEXTUREARRAYS_DIFFUSEMASKEDTRANSPARENCY |
 			EntityRenderer::RENDERTYPE_EFFECTCOLORS |
@@ -1177,17 +1104,7 @@ void Engine::display()
 			EntityRenderer::RENDERTYPE_TEXTURES |
 			EntityRenderer::RENDERTYPE_TEXTURES_DIFFUSEMASKEDTRANSPARENCY |
 			EntityRenderer::RENDERTYPE_LIGHTS
-		);
-
-		//
-		renderer->enableDepthBufferTest();
-
-		// unuse lighting shader
-		if (lightingShader != nullptr) lightingShader->unUseProgram();
-
-		// render shadows if required
-		if (shadowMapping != nullptr) shadowMapping->renderShadowMaps(visibleObjectsNoDepthTest);
-	}
+	);
 
 	// delete post processing termporary buffer if not required anymore
 	if (isUsingPostProcessingTemporaryFrameBuffer == false && postProcessingTemporaryFrameBuffer != nullptr) {
@@ -1970,3 +1887,166 @@ const map<string, string> Engine::getShaderParameterTypes(const string& shaderId
 const map<string, string> Engine::getShaderParameterDefaults(const string& shaderId) {
 	return shaders.find(shaderId)->second.parameterDefaults;
 }
+
+void Engine::render(int32_t effectPass, const string& shaderPrefix, bool useEZR, bool applyShadowMapping, bool applyPostProcessing, int32_t renderTypes) {
+	//
+	Engine::renderer->setEffectPass(effectPass);
+	Engine::renderer->setShaderPrefix(shaderPrefix);
+
+	// default context
+	auto context = Engine::renderer->getDefaultContext();
+
+	// render lines objects
+	if (visibleLinesObjects.size() > 0) {
+		// use particle shader
+		if (linesShader != nullptr) linesShader->useProgram(context);
+
+		// render points based particle systems
+		object3DRenderer->render(visibleLinesObjects);
+
+		// unuse particle shader
+		if (linesShader != nullptr) linesShader->unUseProgram(context);
+	}
+
+	// do depth buffer writing aka early z rejection
+	if (useEZR == true && ezrShaderPre != nullptr && visibleEZRObjects.size() > 0) {
+		// disable color rendering, we only want to write to the Z-Buffer
+		renderer->setColorMask(false, false, false, false);
+		// render
+		ezrShaderPre->useProgram(this);
+		// only draw opaque face entities of objects marked as EZR objects
+		object3DRenderer->render(
+			visibleEZRObjects,
+			false,
+			((renderTypes & EntityRenderer::RENDERTYPE_TEXTUREARRAYS_DIFFUSEMASKEDTRANSPARENCY) == EntityRenderer::RENDERTYPE_TEXTUREARRAYS_DIFFUSEMASKEDTRANSPARENCY?EntityRenderer::RENDERTYPE_TEXTUREARRAYS_DIFFUSEMASKEDTRANSPARENCY:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_TEXTURES_DIFFUSEMASKEDTRANSPARENCY) == EntityRenderer::RENDERTYPE_TEXTURES_DIFFUSEMASKEDTRANSPARENCY?EntityRenderer::RENDERTYPE_TEXTURES_DIFFUSEMASKEDTRANSPARENCY:0)
+		);
+		// done
+		ezrShaderPre->unUseProgram();
+		// restore disable color rendering
+		renderer->setColorMask(true, true, true, true);
+	}
+
+	// use lighting shader
+	if (visibleObjects.size() > 0) {
+		//
+		if (lightingShader != nullptr) lightingShader->useProgram(this);
+
+		// render objects
+		object3DRenderer->render(
+			visibleObjects,
+			true,
+			((renderTypes & EntityRenderer::RENDERTYPE_NORMALS) == EntityRenderer::RENDERTYPE_NORMALS?EntityRenderer::RENDERTYPE_NORMALS:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_TEXTUREARRAYS) == EntityRenderer::RENDERTYPE_TEXTUREARRAYS?EntityRenderer::RENDERTYPE_TEXTUREARRAYS:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_TEXTUREARRAYS_DIFFUSEMASKEDTRANSPARENCY) == EntityRenderer::RENDERTYPE_TEXTUREARRAYS_DIFFUSEMASKEDTRANSPARENCY?EntityRenderer::RENDERTYPE_TEXTUREARRAYS_DIFFUSEMASKEDTRANSPARENCY:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_EFFECTCOLORS) == EntityRenderer::RENDERTYPE_EFFECTCOLORS?EntityRenderer::RENDERTYPE_EFFECTCOLORS:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_MATERIALS) == EntityRenderer::RENDERTYPE_MATERIALS?EntityRenderer::RENDERTYPE_MATERIALS:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_MATERIALS_DIFFUSEMASKEDTRANSPARENCY) == EntityRenderer::RENDERTYPE_MATERIALS_DIFFUSEMASKEDTRANSPARENCY?EntityRenderer::RENDERTYPE_MATERIALS_DIFFUSEMASKEDTRANSPARENCY:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_TEXTURES) == EntityRenderer::RENDERTYPE_TEXTURES?EntityRenderer::RENDERTYPE_TEXTURES:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_TEXTURES_DIFFUSEMASKEDTRANSPARENCY) == EntityRenderer::RENDERTYPE_TEXTURES_DIFFUSEMASKEDTRANSPARENCY?EntityRenderer::RENDERTYPE_TEXTURES_DIFFUSEMASKEDTRANSPARENCY:0)|
+			((renderTypes & EntityRenderer::RENDERTYPE_LIGHTS) == EntityRenderer::RENDERTYPE_LIGHTS?EntityRenderer::RENDERTYPE_LIGHTS:0)
+		);
+
+		// unuse lighting shader
+		if (lightingShader != nullptr) lightingShader->unUseProgram();
+
+		// render shadows if required
+		if (applyShadowMapping == true && shadowMapping != nullptr) shadowMapping->renderShadowMaps(visibleObjects);
+	}
+
+	// do post processing
+	if (applyPostProcessing == true) {
+		isUsingPostProcessingTemporaryFrameBuffer = false;
+		if (postProcessingPrograms.size() > 0) {
+			doPostProcessing(PostProcessingProgram::RENDERPASS_OBJECTS, {{postProcessingFrameBuffer1, postProcessingFrameBuffer2 }}, postProcessingFrameBuffer1);
+			postProcessingFrameBuffer1->enableFrameBuffer();
+		}
+	}
+
+	// render point particle systems
+	if (visiblePpses.size() > 0) {
+		// use particle shader
+		if (particlesShader != nullptr) particlesShader->useProgram(context);
+
+		// render points based particle systems
+		if (visiblePpses.size() > 0) object3DRenderer->render(visiblePpses);
+
+		// unuse particle shader
+		if (particlesShader != nullptr) particlesShader->unUseProgram(context);
+	}
+
+	// render objects and particles together
+	if (applyPostProcessing == true) {
+		if (postProcessingPrograms.size() > 0) {
+			doPostProcessing(PostProcessingProgram::RENDERPASS_FINAL, {{postProcessingFrameBuffer1, postProcessingFrameBuffer2 }}, frameBuffer);
+		}
+	}
+
+	// render objects that are have post post processing render pass
+	if (visibleObjectsPostPostProcessing.size() > 0) {
+		// use lighting shader
+		if (lightingShader != nullptr) {
+			lightingShader->useProgram(this);
+		}
+
+		// render post processing objects
+		object3DRenderer->render(
+			visibleObjectsPostPostProcessing,
+			true,
+			((renderTypes & EntityRenderer::RENDERTYPE_NORMALS) == EntityRenderer::RENDERTYPE_NORMALS?EntityRenderer::RENDERTYPE_NORMALS:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_TEXTUREARRAYS) == EntityRenderer::RENDERTYPE_TEXTUREARRAYS?EntityRenderer::RENDERTYPE_TEXTUREARRAYS:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_TEXTUREARRAYS_DIFFUSEMASKEDTRANSPARENCY) == EntityRenderer::RENDERTYPE_TEXTUREARRAYS_DIFFUSEMASKEDTRANSPARENCY?EntityRenderer::RENDERTYPE_TEXTUREARRAYS_DIFFUSEMASKEDTRANSPARENCY:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_EFFECTCOLORS) == EntityRenderer::RENDERTYPE_EFFECTCOLORS?EntityRenderer::RENDERTYPE_EFFECTCOLORS:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_MATERIALS) == EntityRenderer::RENDERTYPE_MATERIALS?EntityRenderer::RENDERTYPE_MATERIALS:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_MATERIALS_DIFFUSEMASKEDTRANSPARENCY) == EntityRenderer::RENDERTYPE_MATERIALS_DIFFUSEMASKEDTRANSPARENCY?EntityRenderer::RENDERTYPE_MATERIALS_DIFFUSEMASKEDTRANSPARENCY:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_TEXTURES) == EntityRenderer::RENDERTYPE_TEXTURES?EntityRenderer::RENDERTYPE_TEXTURES:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_TEXTURES_DIFFUSEMASKEDTRANSPARENCY) == EntityRenderer::RENDERTYPE_TEXTURES_DIFFUSEMASKEDTRANSPARENCY?EntityRenderer::RENDERTYPE_TEXTURES_DIFFUSEMASKEDTRANSPARENCY:0)|
+			((renderTypes & EntityRenderer::RENDERTYPE_LIGHTS) == EntityRenderer::RENDERTYPE_LIGHTS?EntityRenderer::RENDERTYPE_LIGHTS:0)
+		);
+
+		// unuse lighting shader
+		if (lightingShader != nullptr) lightingShader->unUseProgram();
+
+		// render shadows if required
+		if (applyShadowMapping == true && shadowMapping != nullptr) shadowMapping->renderShadowMaps(visibleObjectsPostPostProcessing);
+	}
+
+	// render objects that are have post post processing render pass
+	if (visibleObjectsNoDepthTest.size() > 0) {
+		// use lighting shader
+		if (lightingShader != nullptr) {
+			lightingShader->useProgram(this);
+		}
+
+		//
+		renderer->disableDepthBufferTest();
+
+		// render post processing objects
+		object3DRenderer->render(
+			visibleObjectsNoDepthTest,
+			true,
+			((renderTypes & EntityRenderer::RENDERTYPE_NORMALS) == EntityRenderer::RENDERTYPE_NORMALS?EntityRenderer::RENDERTYPE_NORMALS:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_TEXTUREARRAYS) == EntityRenderer::RENDERTYPE_TEXTUREARRAYS?EntityRenderer::RENDERTYPE_TEXTUREARRAYS:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_TEXTUREARRAYS_DIFFUSEMASKEDTRANSPARENCY) == EntityRenderer::RENDERTYPE_TEXTUREARRAYS_DIFFUSEMASKEDTRANSPARENCY?EntityRenderer::RENDERTYPE_TEXTUREARRAYS_DIFFUSEMASKEDTRANSPARENCY:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_EFFECTCOLORS) == EntityRenderer::RENDERTYPE_EFFECTCOLORS?EntityRenderer::RENDERTYPE_EFFECTCOLORS:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_MATERIALS) == EntityRenderer::RENDERTYPE_MATERIALS?EntityRenderer::RENDERTYPE_MATERIALS:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_MATERIALS_DIFFUSEMASKEDTRANSPARENCY) == EntityRenderer::RENDERTYPE_MATERIALS_DIFFUSEMASKEDTRANSPARENCY?EntityRenderer::RENDERTYPE_MATERIALS_DIFFUSEMASKEDTRANSPARENCY:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_TEXTURES) == EntityRenderer::RENDERTYPE_TEXTURES?EntityRenderer::RENDERTYPE_TEXTURES:0) |
+			((renderTypes & EntityRenderer::RENDERTYPE_TEXTURES_DIFFUSEMASKEDTRANSPARENCY) == EntityRenderer::RENDERTYPE_TEXTURES_DIFFUSEMASKEDTRANSPARENCY?EntityRenderer::RENDERTYPE_TEXTURES_DIFFUSEMASKEDTRANSPARENCY:0)|
+			((renderTypes & EntityRenderer::RENDERTYPE_LIGHTS) == EntityRenderer::RENDERTYPE_LIGHTS?EntityRenderer::RENDERTYPE_LIGHTS:0)
+		);
+
+		//
+		renderer->enableDepthBufferTest();
+
+		// unuse lighting shader
+		if (lightingShader != nullptr) lightingShader->unUseProgram();
+
+		// render shadows if required
+		if (applyShadowMapping == true && shadowMapping != nullptr) shadowMapping->renderShadowMaps(visibleObjectsNoDepthTest);
+	}
+
+	//
+	Engine::renderer->setShaderPrefix(string());
+	Engine::renderer->setEffectPass(0);
+}
\ No newline at end of file
diff --git a/src/tdme/engine/Engine.h b/src/tdme/engine/Engine.h
index 45bc40d0..cc412d8f 100644
--- a/src/tdme/engine/Engine.h
+++ b/src/tdme/engine/Engine.h
@@ -138,6 +138,7 @@ class tdme::engine::Engine final
 public:
 	enum AnimationProcessingTarget { NONE, CPU, CPU_NORENDERING, GPU };
 	enum ShaderType { OBJECT3D };
+	enum EffectPass { EFFECTPASS_NONE, EFFECTPASS_LIGHTSCATTERING };
 	static constexpr int LIGHTS_MAX { 8 };
 
 protected:
@@ -201,6 +202,7 @@ private:
 	FrameBuffer* postProcessingFrameBuffer1 { nullptr };
 	FrameBuffer* postProcessingFrameBuffer2{ nullptr };
 	FrameBuffer* postProcessingTemporaryFrameBuffer { nullptr };
+	FrameBuffer* lightScatteringFrameBuffer { nullptr };
 	ShadowMapping* shadowMapping { nullptr };
 
 	map<string, Entity*> entitiesById;
@@ -229,6 +231,7 @@ private:
 	bool renderingComputedTransformations;
 
 	vector<string> postProcessingPrograms;
+	bool lightScatteringEnabled;
 
 	bool initialized;
 
@@ -902,6 +905,22 @@ public:
 	 */
 	bool makeScreenshot(const string& pathName, const string& fileName);
 
+	/**
+	 * Returns if light scattering enabled
+	 * @return is light scattering enabled
+	 */
+	inline bool isLightScatteringEnabled() {
+		return lightScatteringEnabled;
+	}
+
+	/**
+	 * Set light scattering enabled
+	 * @param lightScatteringEnabled light scattering enabled
+	 */
+	inline void setLightScatteringEnabled(bool lightScatteringEnabled) {
+		this->lightScatteringEnabled = true;
+	}
+
 	/**
 	 * Clear post processing programs
 	 */
@@ -1003,4 +1022,15 @@ private:
 	 */
 	void doPostProcessing(PostProcessingProgram::RenderPass renderPass, const array<FrameBuffer*, 2> postProcessingFrameBuffers, FrameBuffer* targetFrameBuffer);
 
+	/**
+	 * Do a render/effect pass
+	 * @param effectPass effect pass
+	 * @param shaderPrefix shader prefix
+	 * @param useEZR if to use early Z rejection
+	 * @param doShadowMapping if to apply shadow mapping
+	 * @param applyPostProcessing if to apply post processing
+	 * @param renderTypes render types
+	 */
+	void render(int32_t effectPass, const string& shaderPrefix, bool useEZR, bool applyShadowMapping, bool applyPostProcessing, int32_t renderTypes);
+
 };
diff --git a/src/tdme/engine/Object3D.h b/src/tdme/engine/Object3D.h
index c48baac7..9ce206d0 100644
--- a/src/tdme/engine/Object3D.h
+++ b/src/tdme/engine/Object3D.h
@@ -6,6 +6,7 @@
 #include <tdme/tdme.h>
 #include <tdme/engine/fwd-tdme.h>
 #include <tdme/engine/Camera.h>
+#include <tdme/engine/Engine.h>
 #include <tdme/engine/Timing.h>
 #include <tdme/engine/Transformations.h>
 #include <tdme/engine/Entity.h>
@@ -36,6 +37,7 @@ using tdme::engine::model::Color4;
 using tdme::engine::model::Model;
 using tdme::engine::primitives::BoundingBox;
 using tdme::engine::subsystems::renderer::Renderer;
+using tdme::engine::subsystems::rendering::EntityRenderer;
 using tdme::engine::subsystems::rendering::Object3DAnimation;
 using tdme::engine::subsystems::rendering::Object3DGroup;
 using tdme::engine::subsystems::rendering::Object3DGroupRenderer;
@@ -56,7 +58,7 @@ class tdme::engine::Object3D final
 {
 
 public:
-	enum RenderPass { RENDERPASS_OBJECTS, RENDERPASS_POST_POSTPROCESSING };
+	enum RenderPass { RENDERPASS_NONE, RENDERPASS_OBJECTS, RENDERPASS_POST_POSTPROCESSING };
 
 private:
 	friend class Engine;
@@ -64,6 +66,7 @@ private:
 	friend class Object3DRenderGroup;
 	friend class ObjectParticleSystem;
 	friend class SkinnedObject3DRenderGroup;
+	friend class tdme::engine::subsystems::rendering::EntityRenderer;
 	friend class tdme::engine::subsystems::shadowmapping::ShadowMap;
 
 	Engine* engine { nullptr };
@@ -73,6 +76,7 @@ private:
 	string distanceShaderId { "" };
 	float distanceShaderDistance { 50.0f };
 	RenderPass renderPass { RENDERPASS_OBJECTS };
+	Engine::EffectPass excludeFromEffectPass { Engine::EFFECTPASS_NONE };
 	bool enableEarlyZRejection { false };
 	bool disableDepthTest { false };
 	int64_t frameTransformationsLast { -1LL };
@@ -360,6 +364,21 @@ public:
 		this->renderPass = renderPass;
 	}
 
+	/**
+	 * @return if to exclude from a certain effect pass
+	 */
+	inline Engine::EffectPass getExcludeFromEffectPass() const {
+		return excludeFromEffectPass;
+	}
+
+	/**
+	 * Set exclude from effect pass
+	 * @param effectPass effect pass
+	 */
+	inline void setExcludeEffectPass(Engine::EffectPass effectPass) {
+		this->excludeFromEffectPass = effectPass;
+	}
+
 	/**
 	 * @return If early z rejection is enabled
 	 */
diff --git a/src/tdme/engine/subsystems/lighting/LightingShader.cpp b/src/tdme/engine/subsystems/lighting/LightingShader.cpp
index 64612288..9ff6fb1b 100644
--- a/src/tdme/engine/subsystems/lighting/LightingShader.cpp
+++ b/src/tdme/engine/subsystems/lighting/LightingShader.cpp
@@ -121,12 +121,10 @@ void LightingShader::setShader(void* context, const string& id) {
 	if (running == false) return;
 
 	auto& lightingShaderContext = contexts[renderer->getContextIndex(context)];
-
 	auto currentImplementation = lightingShaderContext.implementation;
-	auto shaderIt = shader.find(id);
-	if (shaderIt == shader.end()) {
-		shaderIt = shader.find("default");
-	}
+	auto shaderIt = shader.find(renderer->getShaderPrefix() + id);
+	if (shaderIt == shader.end()) shaderIt = shader.find(renderer->getShaderPrefix() + "default");
+	if (shaderIt == shader.end()) shaderIt = shader.find("default");
 	lightingShaderContext.implementation = shaderIt->second;
 
 	if (currentImplementation != lightingShaderContext.implementation) {
diff --git a/src/tdme/engine/subsystems/renderer/Renderer.cpp b/src/tdme/engine/subsystems/renderer/Renderer.cpp
index 88b6bd64..3123e6c3 100644
--- a/src/tdme/engine/subsystems/renderer/Renderer.cpp
+++ b/src/tdme/engine/subsystems/renderer/Renderer.cpp
@@ -47,6 +47,7 @@ Renderer::Renderer()
 	cameraMatrix.identity();
 	modelViewMatrix.identity();
 	viewportMatrix.identity();
+	effectPass = 0;
 }
 
 Renderer::~Renderer() {
@@ -98,3 +99,19 @@ int32_t Renderer::getViewPortHeight() {
 
 void Renderer::initializeFrame() {
 }
+
+int32_t Renderer::getEffectPass() {
+	return effectPass;
+}
+
+void Renderer::setEffectPass(int32_t effectPass) {
+	this->effectPass = effectPass;
+}
+
+const string& Renderer::getShaderPrefix() {
+	return shaderPrefix;
+}
+
+void Renderer::setShaderPrefix(const string& shaderPrefix) {
+	this->shaderPrefix = shaderPrefix;
+}
diff --git a/src/tdme/engine/subsystems/renderer/Renderer.h b/src/tdme/engine/subsystems/renderer/Renderer.h
index 6e82fec9..a58bcc58 100644
--- a/src/tdme/engine/subsystems/renderer/Renderer.h
+++ b/src/tdme/engine/subsystems/renderer/Renderer.h
@@ -71,14 +71,14 @@ protected:
 	int32_t viewPortY;
 	int32_t viewPortWidth;
 	int32_t viewPortHeight;
-
 private:
 	Vector3 cameraPosition;
 	Matrix4x4 projectionMatrix;
 	Matrix4x4 cameraMatrix;
 	Matrix4x4 modelViewMatrix;
 	Matrix4x4 viewportMatrix;
-
+	int32_t effectPass;
+	string shaderPrefix;
 public:
 	/**
 	 * @return default context
@@ -314,6 +314,30 @@ public:
 	 */
 	virtual void setProgramAttributeLocation(int32_t programId, int32_t location, const string& name) = 0;
 
+	/**
+	 * Get effect pass
+	 * @return effect pass
+	 */
+	virtual int32_t getEffectPass();
+
+	/**
+	 * Set effect pass
+	 * @param effectPass effect pass
+	 */
+	virtual void setEffectPass(int32_t effectPass);
+
+	/**
+	 * Get shader prefix
+	 * @return shader prefix
+	 */
+	virtual const string& getShaderPrefix();
+
+	/**
+	 * Set shader prefix
+	 * @param shaderPrefix shader prefix
+	 */
+	virtual void setShaderPrefix(const string& shaderPrefix);
+
 	/**
 	 * Get current lighting model
 	 * @param context context
diff --git a/src/tdme/engine/subsystems/rendering/EntityRenderer.h b/src/tdme/engine/subsystems/rendering/EntityRenderer.h
index f7a244b6..fe46ee35 100644
--- a/src/tdme/engine/subsystems/rendering/EntityRenderer.h
+++ b/src/tdme/engine/subsystems/rendering/EntityRenderer.h
@@ -191,6 +191,7 @@ private:
 		TransparentRenderFacesPool* transparentRenderFacesPool) {
 		// reset shader
 		renderer->setShader(renderer->getContext(threadIdx), string());
+		auto effectPass = renderer->getEffectPass();
 
 		// sort objects by model
 		Vector3 objectCamFromAxis;
@@ -199,6 +200,7 @@ private:
 			if (threadCount > 1 && objectIdx % threadCount != threadIdx) continue;
 			auto object = objects[objectIdx];
 			if (object->enabledInstances == 0) continue;
+			if (effectPass != 0 && object->excludeFromEffectPass == effectPass) continue;
 			auto objectShader = object->getDistanceShader().length() == 0?
 				object->getShader():
 				objectCamFromAxis.set(object->getBoundingBoxTransformed()->getCenter()).sub(camera->getLookFrom()).computeLengthSquared() < Math::square(object->getDistanceShaderDistance())?
