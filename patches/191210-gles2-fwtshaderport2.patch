diff --git a/shader/gl3/lighting/render_vertexshader.c b/shader/gl3/lighting/render_vertexshader.c
index b9555d8a..10a02ebd 100644
--- a/shader/gl3/lighting/render_vertexshader.c
+++ b/shader/gl3/lighting/render_vertexshader.c
@@ -24,8 +24,6 @@ uniform mat3 textureMatrix;
 uniform int normalTextureAvailable;
 uniform int frame;
 
-{$DEFINITIONS}
-
 uniform mat4 projectionMatrix;
 uniform mat4 cameraMatrix;
 
@@ -38,6 +36,8 @@ out vec3 vsBitangent;
 out vec4 vsEffectColorMul;
 out vec4 vsEffectColorAdd;
 
+{$DEFINITIONS}
+
 #if defined(HAVE_TERRAIN_SHADER)
 	out vec3 vertex;
 	out vec3 normal;
diff --git a/shader/gles2/functions/create_foliage_transform_matrix.inc.c b/shader/gles2/functions/create_foliage_transform_matrix.inc.c
index 780b6af1..72ac4843 100644
--- a/shader/gles2/functions/create_foliage_transform_matrix.inc.c
+++ b/shader/gles2/functions/create_foliage_transform_matrix.inc.c
@@ -1,6 +1,6 @@
 mat4 createFoliageTransformMatrix(vec3 origin, vec3 vertex, vec3 translation) {
-	float zAxisRotation = (frame + int((origin.x + translation.x) * 8.0 * (translation.x + origin.x < 0.0?-1.0:1.0))) % 160;
-	zAxisRotation = sin((clamp((((zAxisRotation < 160.0 / 2?zAxisRotation:160.0 - zAxisRotation) - (160.0 / 4.0)) * 1.0 / 8.0) * ((vertex.y - origin.y) * 2.0), -20.0, +20.0)) / 20.0 * 3.14) * 20.0;
+	float zAxisRotation = mod((float(frame) + (origin.x + translation.x) * 8.0 * (translation.x + origin.x < 0.0?-1.0:1.0)), 160.0);
+	zAxisRotation = sin((clamp((((zAxisRotation < 160.0 / 2.0?zAxisRotation:160.0 - zAxisRotation) - (160.0 / 4.0)) * 1.0 / 8.0) * ((vertex.y - origin.y) * 2.0), -20.0, +20.0)) / 20.0 * 3.14) * 20.0;
 	return
 		createTranslationMatrix(vec3(origin.x, origin.y, origin.z)) *
 		createRotationMatrix(vec3(0.0, 0.0, 1.0), zAxisRotation) *
diff --git a/shader/gles2/functions/create_tree_transform_matrix.inc.c b/shader/gles2/functions/create_tree_transform_matrix.inc.c
index 97785695..b8b3e7cb 100644
--- a/shader/gles2/functions/create_tree_transform_matrix.inc.c
+++ b/shader/gles2/functions/create_tree_transform_matrix.inc.c
@@ -1,6 +1,6 @@
 mat4 createTreeTransformMatrix(vec3 origin, vec3 vertex, vec3 translation) {
 	if (abs(vertex.x - origin.x) < 0.25 || abs(vertex.z - origin.z) < 0.25) return mat4(1.0);
-	float zAxisRotation = sin((int((translation.x * 50.0 + translation.z * 50.0 + vertex.y * 50.0 + frame) / 2.0) % 160) / 160.0 * 3.14) * 5.0;
+	float zAxisRotation = sin(mod(((translation.x * 50.0 + translation.z * 50.0 + vertex.y * 50.0 + float(frame)) / 2.0), 160.0) / 160.0 * 3.14) * 5.0;
 	if (vertex.x > 0.0) zAxisRotation*= -1.0;
 	return
 		createTranslationMatrix(vec3(origin.x, origin.y, origin.z)) *
diff --git a/shader/gles2/lighting/render_vertexshader.c b/shader/gles2/lighting/render_vertexshader.c
index bd62818c..dd2d4e10 100644
--- a/shader/gles2/lighting/render_vertexshader.c
+++ b/shader/gles2/lighting/render_vertexshader.c
@@ -70,11 +70,13 @@ struct Light {
 attribute vec3 inVertex;
 attribute vec3 inNormal;
 attribute vec2 inTextureUV;
+attribute vec3 inOrigin;
 
 // uniforms
 uniform mat4 mvpMatrix;
 uniform mat4 mvMatrix;
 uniform mat4 normalMatrix;
+uniform vec3 modelTranslation;
 uniform mat3 textureMatrix;
 
 uniform vec4 sceneColor;
@@ -82,10 +84,16 @@ uniform vec4 effectColorMul;
 uniform Material material;
 uniform Light lights[MAX_LIGHTS];
 
+uniform int frame;
+
 // will be passed to fragment shader
 varying vec2 vsFragTextureUV;
 varying vec4 vsFragColor;
 
+{$DEFINITIONS}
+
+{$FUNCTIONS}
+
 void computeLight(in int i, in vec3 normal, in vec3 position) {
 	vec3 lightDirection = lights[i].position.xyz - position.xyz;
 	float lightDistance = length(lightDirection);
@@ -132,6 +140,14 @@ void computeLights(in vec3 normal, in vec3 position) {
  
  
 void main(void) {
+	#if defined(HAVE_TREE)
+		mat4 shaderTransformMatrix = createTreeTransformMatrix(inOrigin, inVertex, modelTranslation);
+	#elif defined(HAVE_FOLIAGE)
+		mat4 shaderTransformMatrix = createFoliageTransformMatrix(inOrigin, inVertex, modelTranslation);
+	#else
+		mat4 shaderTransformMatrix = mat4(1.0);
+	#endif
+
 	// pass texture uv to fragment shader
 	vsFragTextureUV = vec2(textureMatrix * vec3(inTextureUV, 1.0));
 
@@ -141,14 +157,14 @@ void main(void) {
 	vsFragColor+= clamp(material.emission, 0.0, 1.0);
 
 	// compute gl position
-	gl_Position = mvpMatrix * vec4(inVertex, 1.0);
+	gl_Position = mvpMatrix * shaderTransformMatrix * vec4(inVertex, 1.0);
 
 	// Eye-coordinate position of vertex, needed in various calculations
 	vec4 position4 = mvMatrix * vec4(inVertex, 1.0);
 	vec3 position = position4.xyz / position4.w;
 
 	// compute the normal
-	vec3 normal = normalize(vec3(normalMatrix * vec4(inNormal, 0.0)));
+	vec3 normal = normalize(vec3(normalMatrix * shaderTransformMatrix * vec4(inNormal, 0.0)));
  
 	// compute lights
 	computeLights(normal, position);
diff --git a/shader/gles2/shadowmapping/pre_vertexshader.c b/shader/gles2/shadowmapping/pre_vertexshader.c
index 1f312b60..cb2fadf3 100644
--- a/shader/gles2/shadowmapping/pre_vertexshader.c
+++ b/shader/gles2/shadowmapping/pre_vertexshader.c
@@ -5,17 +5,33 @@ precision highp float;
 attribute vec3 inVertex;
 attribute vec3 inNormal;
 attribute vec2 inTextureUV;
+attribute vec3 inOrigin;
 
 uniform mat4 mvpMatrix;
+uniform vec3 modelTranslation;
 uniform mat3 textureMatrix;
 
+uniform int frame;
+
 // will be passed to fragment shader
 varying vec2 vsFragTextureUV;
 
+{$DEFINITIONS}
+
+{$FUNCTIONS}
+
 void main(){
+	#if defined(HAVE_TREE)
+		mat4 shaderTransformMatrix = createTreeTransformMatrix(inOrigin, inVertex, modelTranslation);
+	#elif defined(HAVE_FOLIAGE)
+		mat4 shaderTransformMatrix = createFoliageTransformMatrix(inOrigin, inVertex, modelTranslation);
+	#else
+		mat4 shaderTransformMatrix = mat4(1.0);
+	#endif
+
 	// pass texture uv to fragment shader
 	vsFragTextureUV = vec2(textureMatrix * vec3(inTextureUV, 1.0));
 
-	// position
-	gl_Position = mvpMatrix * vec4(inVertex, 1.0);
+	// compute gl position
+	gl_Position = mvpMatrix * shaderTransformMatrix * vec4(inVertex, 1.0);
 }
diff --git a/shader/gles2/shadowmapping/render_vertexshader.c b/shader/gles2/shadowmapping/render_vertexshader.c
index cffc2ad7..9024707c 100644
--- a/shader/gles2/shadowmapping/render_vertexshader.c
+++ b/shader/gles2/shadowmapping/render_vertexshader.c
@@ -7,20 +7,36 @@ precision highp float;
 attribute vec3 inVertex;
 attribute vec3 inNormal;
 attribute vec2 inTextureUV;
+attribute vec3 inOrigin;
 
 uniform mat4 depthBiasMVPMatrix;
 uniform mat4 mvpMatrix;
 uniform mat4 normalMatrix;
+uniform vec3 modelTranslation;
 uniform mat3 textureMatrix;
 uniform vec3 lightDirection;
 
+uniform int frame;
+
 // will be passed to fragment shader
 varying vec2 vsFragTextureUV;
 varying vec4 vsShadowCoord;
 varying float vsShadowIntensity;
 varying vec3 vsPosition;
 
+{$DEFINITIONS}
+
+{$FUNCTIONS}
+
 void main() {
+	#if defined(HAVE_TREE)
+		mat4 shaderTransformMatrix = createTreeTransformMatrix(inOrigin, inVertex, modelTranslation);
+	#elif defined(HAVE_FOLIAGE)
+		mat4 shaderTransformMatrix = createFoliageTransformMatrix(inOrigin, inVertex, modelTranslation);
+	#else
+		mat4 shaderTransformMatrix = mat4(1.0);
+	#endif
+
 	// pass texture uv to fragment shader
 	vsFragTextureUV = vec2(textureMatrix * vec3(inTextureUV, 1.0));
 
@@ -29,9 +45,9 @@ void main() {
 	vsShadowCoord = vsShadowCoord / vsShadowCoord.w;
 
 	// shadow intensity 
-	vec3 normal = normalize(vec3(normalMatrix * vec4(inNormal, 0.0)));
+	vec3 normal = normalize(vec3(normalMatrix * shaderTransformMatrix * vec4(inNormal, 0.0)));
 	vsShadowIntensity = clamp(abs(dot(normalize(lightDirection.xyz), normal)), 0.0, 1.0);
 
 	// compute gl position
-	gl_Position = mvpMatrix * vec4(inVertex, 1.0);
+	gl_Position = mvpMatrix * shaderTransformMatrix * vec4(inVertex, 1.0);
 }
diff --git a/src/tdme/engine/EngineGLES2Renderer.cpp b/src/tdme/engine/EngineGLES2Renderer.cpp
index c12e9493..a1f8a666 100644
--- a/src/tdme/engine/EngineGLES2Renderer.cpp
+++ b/src/tdme/engine/EngineGLES2Renderer.cpp
@@ -33,7 +33,7 @@ void EngineGLES2Renderer::onUpdateProjectionMatrix(void* context)
 		Engine::linesShader->updateMatrices(this, context);
 
 	if (Engine::currentEngine->shadowMapping != nullptr)
-		Engine::currentEngine->shadowMapping->updateMatrices(this, context);
+		Engine::currentEngine->shadowMapping->updateMatrices(context);
 
 	if (Engine::ezrShaderPre != nullptr)
 		Engine::ezrShaderPre->updateMatrices(this, context);
@@ -51,7 +51,7 @@ void EngineGLES2Renderer::onUpdateCameraMatrix(void* context)
 		Engine::linesShader->updateMatrices(this, context);
 
 	if (Engine::currentEngine->shadowMapping != nullptr)
-		Engine::currentEngine->shadowMapping->updateMatrices(this, context);
+		Engine::currentEngine->shadowMapping->updateMatrices(context);
 
 	if (Engine::ezrShaderPre != nullptr)
 		Engine::ezrShaderPre->updateMatrices(this, context);
@@ -69,7 +69,7 @@ void EngineGLES2Renderer::onUpdateModelViewMatrix(void* context)
 		Engine::linesShader->updateMatrices(this, context);
 
 	if (Engine::currentEngine->shadowMapping != nullptr)
-		Engine::currentEngine->shadowMapping->updateMatrices(this, context);
+		Engine::currentEngine->shadowMapping->updateMatrices(context);
 
 	if (Engine::ezrShaderPre != nullptr)
 		Engine::ezrShaderPre->updateMatrices(this, context);
@@ -84,7 +84,7 @@ void EngineGLES2Renderer::onBindTexture(void* context, int32_t textureId)
 		Engine::guiShader->bindTexture(this, textureId);
 
 	if (Engine::currentEngine->shadowMapping != nullptr)
-		Engine::currentEngine->shadowMapping->bindTexture(this, context, textureId);
+		Engine::currentEngine->shadowMapping->bindTexture(context, textureId);
 
 	if (Engine::ezrShaderPre != nullptr)
 		Engine::ezrShaderPre->bindTexture(this, context, textureId);
@@ -96,7 +96,7 @@ void EngineGLES2Renderer::onUpdateTextureMatrix(void* context)
 		Engine::lightingShader->updateTextureMatrix(this, context);
 
 	if (Engine::currentEngine->shadowMapping != nullptr)
-		Engine::currentEngine->shadowMapping->updateTextureMatrix(this, context);
+		Engine::currentEngine->shadowMapping->updateTextureMatrix(context);
 
 	if (Engine::guiShader != nullptr)
 		Engine::guiShader->updateTextureMatrix(this);
@@ -127,7 +127,7 @@ void EngineGLES2Renderer::onUpdateLight(void* context, int32_t lightId)
 		Engine::lightingShader->updateLight(this, context, lightId);
 
 	if (Engine::currentEngine->shadowMapping != nullptr)
-		Engine::currentEngine->shadowMapping->updateLight(this, context, lightId);
+		Engine::currentEngine->shadowMapping->updateLight(context, lightId);
 }
 
 void EngineGLES2Renderer::onUpdateMaterial(void* context)
@@ -136,7 +136,7 @@ void EngineGLES2Renderer::onUpdateMaterial(void* context)
 		Engine::lightingShader->updateMaterial(this, context);
 
 	if (Engine::currentEngine->shadowMapping != nullptr)
-		Engine::currentEngine->shadowMapping->updateMaterial(this, context);
+		Engine::currentEngine->shadowMapping->updateMaterial(context);
 
 	if (Engine::ezrShaderPre != nullptr)
 		Engine::ezrShaderPre->updateMaterial(this, context);
diff --git a/src/tdme/engine/subsystems/lighting/LightingShaderBaseImplementation.cpp b/src/tdme/engine/subsystems/lighting/LightingShaderBaseImplementation.cpp
index d924032b..4f72ecfa 100644
--- a/src/tdme/engine/subsystems/lighting/LightingShaderBaseImplementation.cpp
+++ b/src/tdme/engine/subsystems/lighting/LightingShaderBaseImplementation.cpp
@@ -88,6 +88,8 @@ void LightingShaderBaseImplementation::initialize()
 		uniformNormalMatrix = renderer->getProgramUniformLocation(renderLightingProgramId, "normalMatrix");
 		if (uniformNormalMatrix == -1) return;
 
+		uniformModelTranslation = renderer->getProgramUniformLocation(renderLightingProgramId, "modelTranslation");
+
 		uniformEffectColorMul = renderer->getProgramUniformLocation(renderLightingProgramId, "effectColorMul");
 		if (uniformEffectColorMul == -1) return;
 
@@ -244,17 +246,21 @@ void LightingShaderBaseImplementation::updateMatrices(Renderer* renderer, void*
 		Matrix4x4 mvMatrix;
 		Matrix4x4 mvpMatrix;
 		Matrix4x4 normalMatrix;
+		Vector3 modelTranslation;
 
 		// model view matrix
-		mvMatrix.set(renderer->getModelViewMatrix());
+		mvMatrix.set(renderer->getModelViewMatrix()).multiply(renderer->getCameraMatrix());
 		// object to screen matrix
 		mvpMatrix.set(mvMatrix).multiply(renderer->getProjectionMatrix());
 		// normal matrix
 		normalMatrix.set(mvMatrix).invert().transpose();
+		// model translation
+		renderer->getModelViewMatrix().getTranslation(modelTranslation);
 		// upload matrices
 		renderer->setProgramUniformFloatMatrix4x4(context, uniformMVPMatrix, mvpMatrix.getArray());
 		renderer->setProgramUniformFloatMatrix4x4(context, uniformMVMatrix, mvMatrix.getArray());
 		renderer->setProgramUniformFloatMatrix4x4(context, uniformNormalMatrix, normalMatrix.getArray());
+		if (uniformModelTranslation != -1) renderer->setProgramUniformFloatVec3(context, uniformModelTranslation, modelTranslation.getArray());
 	}
 }
 
diff --git a/src/tdme/engine/subsystems/lighting/LightingShaderBaseImplementation.h b/src/tdme/engine/subsystems/lighting/LightingShaderBaseImplementation.h
index e87de7cc..8c42079a 100644
--- a/src/tdme/engine/subsystems/lighting/LightingShaderBaseImplementation.h
+++ b/src/tdme/engine/subsystems/lighting/LightingShaderBaseImplementation.h
@@ -46,6 +46,7 @@ protected:
 	int32_t uniformMVPMatrix { -1 };
 	int32_t uniformMVMatrix { -1 };
 	int32_t uniformNormalMatrix { -1 };
+	int32_t uniformModelTranslation { -1 };
 	int32_t uniformTextureMatrix { -1 };
 	int32_t uniformEffectColorMul { -1 };
 	int32_t uniformEffectColorAdd { -1 };
diff --git a/src/tdme/engine/subsystems/renderer/Renderer.h b/src/tdme/engine/subsystems/renderer/Renderer.h
index 7ca96b4f..78a51f9b 100644
--- a/src/tdme/engine/subsystems/renderer/Renderer.h
+++ b/src/tdme/engine/subsystems/renderer/Renderer.h
@@ -334,7 +334,7 @@ public:
 	virtual void onUpdateCameraMatrix(void* context) = 0;
 
 	/** 
-	 * @return model view matrix
+	 * @return model view matrix or in some cases the model matrix
 	 */
 	virtual Matrix4x4& getModelViewMatrix();
 
diff --git a/src/tdme/engine/subsystems/rendering/Object3DGroupMesh.cpp b/src/tdme/engine/subsystems/rendering/Object3DGroupMesh.cpp
index fdf236ee..c6e60b7f 100644
--- a/src/tdme/engine/subsystems/rendering/Object3DGroupMesh.cpp
+++ b/src/tdme/engine/subsystems/rendering/Object3DGroupMesh.cpp
@@ -306,7 +306,8 @@ void Object3DGroupMesh::setupVertexIndicesBuffer(Renderer *renderer, void *conte
 				"Object3DGroupMesh::setupVertexIndicesBuffer(): " +
 				group->getModel()->getName() + ":" +
 				group->getName() + ":" +
-				"more than 2^16-1 indices"
+				"more than 2^16-1 indices: " +
+				to_string(indices.size())
 			);
 		}
 		auto sbIndices = ObjectBuffer::getByteBuffer(context, faceCount * 3 * sizeof(uint16_t))->asShortBuffer();
diff --git a/src/tdme/engine/subsystems/rendering/Object3DRenderer.cpp b/src/tdme/engine/subsystems/rendering/Object3DRenderer.cpp
index c5f0c71e..0b146975 100644
--- a/src/tdme/engine/subsystems/rendering/Object3DRenderer.cpp
+++ b/src/tdme/engine/subsystems/rendering/Object3DRenderer.cpp
@@ -525,8 +525,7 @@ void Object3DRenderer::renderObjectsOfSameTypeNonInstanced(const vector<Object3D
 						modelViewMatrix.identity() :
 						modelViewMatrix.set(*_object3DGroup->groupTransformationsMatrix)
 					).
-						multiply(object->getTransformationsMatrix()).
-						multiply(cameraMatrix)
+						multiply(object->getTransformationsMatrix())
 				);
 				renderer->onUpdateModelViewMatrix(context);
 				// set up front face
diff --git a/src/tdme/engine/subsystems/shadowmapping/ShadowMapping.cpp b/src/tdme/engine/subsystems/shadowmapping/ShadowMapping.cpp
index 81f7b040..5bad362b 100644
--- a/src/tdme/engine/subsystems/shadowmapping/ShadowMapping.cpp
+++ b/src/tdme/engine/subsystems/shadowmapping/ShadowMapping.cpp
@@ -44,9 +44,6 @@ ShadowMapping::ShadowMapping(Engine* engine, Renderer* renderer, Object3DRendere
 		shadowMaps[i] = nullptr;
 	}
 	depthBiasMVPMatrix.identity();
-	mvMatrix.identity();
-	mvpMatrix.identity();
-	normalMatrix.identity();
 	runState = ShadowMapping_RunState::NONE;
 }
 
@@ -216,7 +213,7 @@ void ShadowMapping::endObjectTransformations()
 	depthBiasMVPMatrix.set(shadowTransformationsMatrix);
 }
 
-void ShadowMapping::updateTextureMatrix(Renderer* renderer, void* context)
+void ShadowMapping::updateTextureMatrix(void* context)
 {
 	if (runState == ShadowMapping_RunState::NONE) return;
 
@@ -225,13 +222,13 @@ void ShadowMapping::updateTextureMatrix(Renderer* renderer, void* context)
 		auto v = runState;
 		if (v == ShadowMapping_RunState::PRE) {
 			{
-				Engine::getShadowMappingShaderPre()->updateTextureMatrix(renderer, context);
+				Engine::getShadowMappingShaderPre()->updateTextureMatrix(context);
 				goto end_switch0;
 			}
 		} else
 		if (v == ShadowMapping_RunState::RENDER) {
 			{
-				Engine::getShadowMappingShaderRender()->updateTextureMatrix(renderer, context);
+				Engine::getShadowMappingShaderRender()->updateTextureMatrix(context);
 				goto end_switch0;
 			}
 		} else {
@@ -244,57 +241,36 @@ void ShadowMapping::updateTextureMatrix(Renderer* renderer, void* context)
 	}
 }
 
-void ShadowMapping::updateMatrices(Renderer* renderer, void* context)
+void ShadowMapping::updateMatrices(void* context)
 {
 	if (runState == ShadowMapping_RunState::NONE) return;
-
-	// model view matrix
-	mvMatrix.set(renderer->getModelViewMatrix());
-	// object to screen matrix
-	mvpMatrix.set(mvMatrix).multiply(renderer->getProjectionMatrix());
-	// normal matrix
-	normalMatrix.set(mvMatrix).invert().transpose();
-	// upload
+	// delegate to shader
 	{
-		auto v = runState;
-		if (v == ShadowMapping_RunState::PRE) {
-			{
-				Engine::getShadowMappingShaderPre()->updateMatrices(context, mvpMatrix);
-				goto end_switch0;;
-			}
+		if (runState == ShadowMapping_RunState::PRE) {
+			Engine::getShadowMappingShaderPre()->updateMatrices(context);
 		} else
-		if (v == ShadowMapping_RunState::RENDER) {
-			{
-				auto shader = Engine::getShadowMappingShaderRender();
-				shader->setProgramMVMatrix(context, mvMatrix);
-				shader->setProgramMVPMatrix(context, mvpMatrix);
-				shader->setProgramNormalMatrix(context, normalMatrix);
-				goto end_switch0;;
-			}
+		if (runState == ShadowMapping_RunState::RENDER) {
+			Engine::getShadowMappingShaderRender()->updateMatrices(context);
 		} else {
-			{
-				Console::println(string("ShadowMapping::updateMatrices(): unsupported run state '" + to_string(runState)));
-				goto end_switch0;;
-			}
+			Console::println(string("ShadowMapping::updateMatrices(): unsupported run state '" + to_string(runState)));
 		}
-		end_switch0:;
 	}
 }
 
-void ShadowMapping::updateMaterial(Renderer* renderer, void* context) {
+void ShadowMapping::updateMaterial(void* context) {
 	if (runState == ShadowMapping_RunState::NONE)
 		return;
 	{
 		auto v = runState;
 		if (v == ShadowMapping_RunState::PRE) {
 			{
-				Engine::getShadowMappingShaderPre()->updateMaterial(renderer, context);
+				Engine::getShadowMappingShaderPre()->updateMaterial(context);
 				goto end_switch0;;
 			}
 		} else
 		if (v == ShadowMapping_RunState::RENDER) {
 			{
-				Engine::getShadowMappingShaderRender()->updateMaterial(renderer, context);
+				Engine::getShadowMappingShaderRender()->updateMaterial(context);
 				goto end_switch0;;
 			}
 		}
@@ -302,26 +278,26 @@ void ShadowMapping::updateMaterial(Renderer* renderer, void* context) {
 	}
 }
 
-void ShadowMapping::updateLight(Renderer* renderer, void* context, int32_t lightId) {
+void ShadowMapping::updateLight(void* context, int32_t lightId) {
 	if (runState == ShadowMapping_RunState::RENDER) {
-		Engine::getShadowMappingShaderRender()->updateLight(renderer, context, lightId);
+		Engine::getShadowMappingShaderRender()->updateLight(context, lightId);
 	}
 }
 
-void ShadowMapping::bindTexture(Renderer* renderer, void* context, int32_t textureId) {
+void ShadowMapping::bindTexture(void* context, int32_t textureId) {
 	if (runState == ShadowMapping_RunState::NONE)
 		return;
 	{
 		auto v = runState;
 		if (v == ShadowMapping_RunState::PRE) {
 			{
-				Engine::getShadowMappingShaderPre()->bindTexture(renderer, context, textureId);
+				Engine::getShadowMappingShaderPre()->bindTexture(context, textureId);
 				goto end_switch0;;
 			}
 		} else
 		if (v == ShadowMapping_RunState::RENDER) {
 			{
-				Engine::getShadowMappingShaderRender()->bindTexture(renderer, context, textureId);
+				Engine::getShadowMappingShaderRender()->bindTexture(context, textureId);
 				goto end_switch0;;
 			}
 		}
diff --git a/src/tdme/engine/subsystems/shadowmapping/ShadowMapping.h b/src/tdme/engine/subsystems/shadowmapping/ShadowMapping.h
index e76d0ef8..9b840a4a 100644
--- a/src/tdme/engine/subsystems/shadowmapping/ShadowMapping.h
+++ b/src/tdme/engine/subsystems/shadowmapping/ShadowMapping.h
@@ -38,9 +38,6 @@ private:
 
 	Matrix4x4 shadowTransformationsMatrix;
 	Matrix4x4 depthBiasMVPMatrix;
-	Matrix4x4 mvMatrix;
-	Matrix4x4 mvpMatrix;
-	Matrix4x4 normalMatrix;
 
 	Engine* engine { nullptr };
 
@@ -96,24 +93,21 @@ public:
 
 	/** 
 	 * Update model view and projection matrix
-	 * @param renderer renderer
 	 * @param context context
 	 */
-	void updateMatrices(Renderer* renderer, void* context);
+	void updateMatrices(void* context);
 
 	/**
 	 * Update texture matrix
-	 * @param renderer renderer
 	 * @param context context
 	 */
-	void updateTextureMatrix(Renderer* renderer, void* context);
+	void updateTextureMatrix(void* context);
 
 	/**
 	 * Update material
-	 * @param renderer renderer
 	 * @param context context
 	 */
-	void updateMaterial(Renderer* renderer, void* context);
+	void updateMaterial(void* context);
 
 	/**
 	 * Set shader
@@ -124,17 +118,15 @@ public:
 
 	/**
 	 * Upload light
-	 * @param renderer renderer
 	 * @param lightId light id
 	 */
-	void updateLight(Renderer* renderer, void* context, int32_t lightId);
+	void updateLight(void* context, int32_t lightId);
 
 	/**
 	 * Bind texture
-	 * @param renderer renderer
 	 * @param textureId texture id
 	 */
-	void bindTexture(Renderer* renderer, void* context, int32_t textureId);
+	void bindTexture(void* context, int32_t textureId);
 
 	/** 
 	 * Update depth bias mvp matrix with given matrix
diff --git a/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPre.cpp b/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPre.cpp
index 366db5fc..30d159e1 100644
--- a/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPre.cpp
+++ b/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPre.cpp
@@ -70,27 +70,27 @@ void ShadowMappingShaderPre::unUseProgram()
 	engine = nullptr;
 }
 
-void ShadowMappingShaderPre::updateMatrices(void* context, const Matrix4x4& mvpMatrix)
+void ShadowMappingShaderPre::updateMatrices(void* context)
 {
 	auto& shadowMappingShaderPreContext = contexts[renderer->getContextIndex(context)];
 	if (shadowMappingShaderPreContext.implementation == nullptr) return;
-	shadowMappingShaderPreContext.implementation->updateMatrices(context, mvpMatrix);
+	shadowMappingShaderPreContext.implementation->updateMatrices(context);
 }
 
-void ShadowMappingShaderPre::updateTextureMatrix(Renderer* renderer, void* context) {
+void ShadowMappingShaderPre::updateTextureMatrix(void* context) {
 	auto& shadowMappingShaderPreContext = contexts[renderer->getContextIndex(context)];
 	if (shadowMappingShaderPreContext.implementation == nullptr) return;
 	shadowMappingShaderPreContext.implementation->updateTextureMatrix(renderer, context);
 }
 
-void ShadowMappingShaderPre::updateMaterial(Renderer* renderer, void* context)
+void ShadowMappingShaderPre::updateMaterial(void* context)
 {
 	auto& shadowMappingShaderPreContext = contexts[renderer->getContextIndex(context)];
 	if (shadowMappingShaderPreContext.implementation == nullptr) return;
 	shadowMappingShaderPreContext.implementation->updateMaterial(renderer, context);
 }
 
-void ShadowMappingShaderPre::bindTexture(Renderer* renderer, void* context, int32_t textureId)
+void ShadowMappingShaderPre::bindTexture(void* context, int32_t textureId)
 {
 	auto& shadowMappingShaderPreContext = contexts[renderer->getContextIndex(context)];
 	if (shadowMappingShaderPreContext.implementation == nullptr) return;
diff --git a/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPre.h b/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPre.h
index 9bc3f72f..0628198b 100644
--- a/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPre.h
+++ b/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPre.h
@@ -62,31 +62,27 @@ public:
 	/** 
 	 * Set up pre program mvp matrix
 	 * @param context context
-	 * @param mvpMatrix mvp matrix
 	 */
-	void updateMatrices(void* context, const Matrix4x4& mvpMatrix);
+	void updateMatrices(void* context);
 
 	/**
 	 * Set up pre program texture matrix
 	 * @param context context
-	 * @param renderer renderer
 	 */
-	void updateTextureMatrix(Renderer* renderer, void* context);
+	void updateTextureMatrix(void* context);
 
 	/**
 	 * Update material
-	 * @param renderer renderer
 	 * @param context context
 	 */
-	void updateMaterial(Renderer* renderer, void* context);
+	void updateMaterial(void* context);
 
 	/**
 	 * Bind texture
-	 * @param renderer renderer
 	 * @param context context
 	 * @param textureId texture id
 	 */
-	void bindTexture(Renderer* renderer, void* context, int32_t textureId);
+	void bindTexture(void* context, int32_t textureId);
 
 	/**
 	 * Set shader
diff --git a/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPreBaseImplementation.cpp b/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPreBaseImplementation.cpp
index c4d7401a..dceb726a 100644
--- a/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPreBaseImplementation.cpp
+++ b/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPreBaseImplementation.cpp
@@ -1,4 +1,4 @@
-#include <tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPreBaseImplementation.h>
+	#include <tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPreBaseImplementation.h>
 
 #include <tdme/engine/Engine.h>
 #include <tdme/engine/Timing.h>
@@ -41,6 +41,7 @@ void ShadowMappingShaderPreBaseImplementation::initialize()
 	if (renderer->isUsingProgramAttributeLocation() == true) {
 		renderer->setProgramAttributeLocation(programId, 0, "inVertex");
 		renderer->setProgramAttributeLocation(programId, 2, "inTextureUV");
+		renderer->setProgramAttributeLocation(programId, 4, "inOrigin");
 	}
 	// link
 	if (renderer->linkProgram(programId) == false) return;
@@ -56,6 +57,7 @@ void ShadowMappingShaderPreBaseImplementation::initialize()
 		//	uniforms
 		uniformMVPMatrix = renderer->getProgramUniformLocation(programId, "mvpMatrix");
 		if (uniformMVPMatrix == -1) return;
+		uniformModelTranslation = renderer->getProgramUniformLocation(programId, "modelTranslation");
 	}
 	uniformTextureMatrix = renderer->getProgramUniformLocation(programId, "textureMatrix");
 	if (uniformTextureMatrix == -1) return;
@@ -86,13 +88,20 @@ void ShadowMappingShaderPreBaseImplementation::unUseProgram(void* context)
 {
 }
 
-void ShadowMappingShaderPreBaseImplementation::updateMatrices(void* context, const Matrix4x4& mvpMatrix)
+void ShadowMappingShaderPreBaseImplementation::updateMatrices(void* context)
 {
 	if (renderer->isInstancedRenderingAvailable() == true) {
 		renderer->setProgramUniformFloatMatrix4x4(context, uniformProjectionMatrix, renderer->getProjectionMatrix().getArray());
 		renderer->setProgramUniformFloatMatrix4x4(context, uniformCameraMatrix, renderer->getCameraMatrix().getArray());
 	} else {
+		Matrix4x4 mvpMatrix;
+		Vector3 modelTranslation;
+		// model view projection matrix
+		mvpMatrix.set(renderer->getModelViewMatrix()).multiply(renderer->getCameraMatrix()).multiply(renderer->getProjectionMatrix());
+		// model translation
+		renderer->getModelViewMatrix().getTranslation(modelTranslation);
 		renderer->setProgramUniformFloatMatrix4x4(context, uniformMVPMatrix, mvpMatrix.getArray());
+		if (uniformModelTranslation != -1) renderer->setProgramUniformFloatVec3(context, uniformModelTranslation, modelTranslation.getArray());
 	}
 }
 
diff --git a/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPreBaseImplementation.h b/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPreBaseImplementation.h
index 1f802331..d372fffa 100644
--- a/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPreBaseImplementation.h
+++ b/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPreBaseImplementation.h
@@ -30,6 +30,7 @@ protected:
 	int32_t uniformCameraMatrix { -1 };
 	int32_t uniformMVPMatrix { -1 };
 	int32_t uniformTextureMatrix { -1 };
+	int32_t uniformModelTranslation { -1 };
 	int32_t uniformDiffuseTextureUnit { -1 };
 	int32_t uniformDiffuseTextureAvailable { -1 };
 	int32_t uniformDiffuseTextureMaskedTransparency { -1 };
@@ -44,7 +45,7 @@ public:
 	virtual void initialize() override;
 	virtual void useProgram(Engine* engine, void* context) override;
 	virtual void unUseProgram(void* context) override;
-	virtual void updateMatrices(void* context, const Matrix4x4& mvpMatrix) override;
+	virtual void updateMatrices(void* context) override;
 	virtual void updateTextureMatrix(Renderer* renderer, void* context) override;
 	virtual void updateMaterial(Renderer* renderer, void* context) override;
 	virtual void bindTexture(Renderer* renderer, void* context, int32_t textureId) override;
diff --git a/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPreImplementation.h b/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPreImplementation.h
index e7e4506f..b87266a3 100644
--- a/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPreImplementation.h
+++ b/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderPreImplementation.h
@@ -48,9 +48,8 @@ struct tdme::engine::subsystems::shadowmapping::ShadowMappingShaderPreImplementa
 	/** 
 	 * Set up pre program mvp matrix
 	 * @param context context
-	 * @param mvpMatrix mvp matrix
 	 */
-	virtual void updateMatrices(void* context, const Matrix4x4& mvpMatrix) = 0;
+	virtual void updateMatrices(void* context) = 0;
 
 	/**
 	 * Set up pre program texture matrix
diff --git a/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderRender.cpp b/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderRender.cpp
index 11ef7bc1..e2270405 100644
--- a/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderRender.cpp
+++ b/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderRender.cpp
@@ -71,47 +71,33 @@ void ShadowMappingShaderRender::unUseProgram()
 	engine = nullptr;
 }
 
-void ShadowMappingShaderRender::setProgramMVMatrix(void* context, const Matrix4x4& mvMatrix)
+void ShadowMappingShaderRender::updateMatrices(void* context)
 {
 	auto& shadowMappingShaderRenderContext = contexts[renderer->getContextIndex(context)];
 	if (shadowMappingShaderRenderContext.implementation == nullptr) return;
-	shadowMappingShaderRenderContext.implementation->setProgramMVMatrix(context, mvMatrix);
+	shadowMappingShaderRenderContext.implementation->updateMatrices(context);
 }
 
-void ShadowMappingShaderRender::setProgramMVPMatrix(void* context, const Matrix4x4& mvpMatrix)
-{
-	auto& shadowMappingShaderRenderContext = contexts[renderer->getContextIndex(context)];
-	if (shadowMappingShaderRenderContext.implementation == nullptr) return;
-	shadowMappingShaderRenderContext.implementation->setProgramMVPMatrix(context, mvpMatrix);
-}
-
-void ShadowMappingShaderRender::setProgramNormalMatrix(void* context, const Matrix4x4& normalMatrix)
-{
-	auto& shadowMappingShaderRenderContext = contexts[renderer->getContextIndex(context)];
-	if (shadowMappingShaderRenderContext.implementation == nullptr) return;
-	shadowMappingShaderRenderContext.implementation->setProgramNormalMatrix(context, normalMatrix);
-}
-
-void ShadowMappingShaderRender::updateTextureMatrix(Renderer* renderer, void* context) {
+void ShadowMappingShaderRender::updateTextureMatrix(void* context) {
 	auto& shadowMappingShaderRenderContext = contexts[renderer->getContextIndex(context)];
 	if (shadowMappingShaderRenderContext.implementation == nullptr) return;
 	shadowMappingShaderRenderContext.implementation->updateTextureMatrix(renderer, context);
 }
 
-void ShadowMappingShaderRender::updateMaterial(Renderer* renderer, void* context)
+void ShadowMappingShaderRender::updateMaterial(void* context)
 {
 	auto& shadowMappingShaderRenderContext = contexts[renderer->getContextIndex(context)];
 	if (shadowMappingShaderRenderContext.implementation == nullptr) return;
 	shadowMappingShaderRenderContext.implementation->updateMaterial(renderer, context);
 }
 
-void ShadowMappingShaderRender::updateLight(Renderer* renderer, void* context, int32_t lightId) {
+void ShadowMappingShaderRender::updateLight(void* context, int32_t lightId) {
 	auto& shadowMappingShaderRenderContext = contexts[renderer->getContextIndex(context)];
 	if (shadowMappingShaderRenderContext.implementation == nullptr) return;
 	shadowMappingShaderRenderContext.implementation->updateLight(renderer, context, lightId);
 }
 
-void ShadowMappingShaderRender::bindTexture(Renderer* renderer, void* context, int32_t textureId)
+void ShadowMappingShaderRender::bindTexture(void* context, int32_t textureId)
 {
 	auto& shadowMappingShaderRenderContext = contexts[renderer->getContextIndex(context)];
 	if (shadowMappingShaderRenderContext.implementation == nullptr) return;
diff --git a/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderRender.h b/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderRender.h
index 9a2abb14..b8eb917b 100644
--- a/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderRender.h
+++ b/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderRender.h
@@ -61,61 +61,37 @@ public:
 	 */
 	void unUseProgram();
 
-	/** 
-	 * Set up program projection and camera matrix
-	 */
-	void setProgramViewMatrices();
-
 	/**
-	 * Set up program model view matrix
-	 * @param context context
-	 * @param mvMatrix model view matrix
-	 */
-	void setProgramMVMatrix(void* context, const Matrix4x4& mvMatrix);
-
-	/** 
-	 * Set up program mvp matrix
+	 * Update matrices
 	 * @param context context
-	 * @param mvpMatrix mvp matrix
 	 */
-	void setProgramMVPMatrix(void* context, const Matrix4x4& mvpMatrix);
-
-	/** 
-	 * Set up program normal matrix
-	 * @param context context
-	 * @param normalMatrix normal matrix
-	 */
-	void setProgramNormalMatrix(void* context, const Matrix4x4& normalMatrix);
+	void updateMatrices(void* context);
 
 	/**
 	 * Set up pre program texture matrix
-	 * @param renderer renderer
 	 * @param context context
 	 */
-	void updateTextureMatrix(Renderer* renderer, void* context);
+	void updateTextureMatrix(void* context);
 
 	/**
 	 * Update material
-	 * @param renderer renderer
 	 * @param context context
 	 */
-	void updateMaterial(Renderer* renderer, void* context);
+	void updateMaterial(void* context);
 
 	/**
 	 * Update light
-	 * @param renderer renderer
 	 * @param context context
 	 * @param lightId light id
 	 */
-	void updateLight(Renderer* renderer, void* context, int32_t lightId);
+	void updateLight(void* context, int32_t lightId);
 
 	/**
 	 * Bind texture
-	 * @param renderer renderer
 	 * @param context context
 	 * @param textureId texture id
 	 */
-	void bindTexture(Renderer* renderer, void* context, int32_t textureId);
+	void bindTexture(void* context, int32_t textureId);
 
 	/** 
 	 * Set up program depth bias mvp matrix
diff --git a/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderRenderBaseImplementation.cpp b/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderRenderBaseImplementation.cpp
index b72ee5a9..02118245 100644
--- a/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderRenderBaseImplementation.cpp
+++ b/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderRenderBaseImplementation.cpp
@@ -55,6 +55,7 @@ void ShadowMappingShaderRenderBaseImplementation::initialize()
 		renderer->setProgramAttributeLocation(renderProgramId, 0, "inVertex");
 		renderer->setProgramAttributeLocation(renderProgramId, 1, "inNormal");
 		renderer->setProgramAttributeLocation(renderProgramId, 2, "inTextureUV");
+		renderer->setProgramAttributeLocation(renderProgramId, 4, "inOrigin");
 	}
 	// link
 	if (renderer->linkProgram(renderProgramId) == false)
@@ -80,6 +81,7 @@ void ShadowMappingShaderRenderBaseImplementation::initialize()
 		if (renderUniformMVPMatrix == -1) return;
 		renderUniformNormalMatrix = renderer->getProgramUniformLocation(renderProgramId, "normalMatrix");
 		if (renderUniformNormalMatrix == -1) return;
+		renderUniformModelTranslation = renderer->getProgramUniformLocation(renderProgramId, "modelTranslation");
 	}
 	uniformTextureMatrix = renderer->getProgramUniformLocation(renderProgramId, "textureMatrix");
 	if (uniformTextureMatrix == -1) return;
@@ -131,30 +133,30 @@ void ShadowMappingShaderRenderBaseImplementation::unUseProgram(void* context)
 {
 }
 
-void ShadowMappingShaderRenderBaseImplementation::setProgramViewMatrices(void* context) {
+void ShadowMappingShaderRenderBaseImplementation::updateMatrices(void* context) {
 	if (renderer->isInstancedRenderingAvailable() == true) {
 		renderer->setProgramUniformFloatMatrix4x4(context, renderUniformProjectionMatrix, renderer->getProjectionMatrix().getArray());
 		renderer->setProgramUniformFloatMatrix4x4(context, renderUniformCameraMatrix, renderer->getCameraMatrix().getArray());
+	} else {
+		Matrix4x4 mvMatrix;
+		Matrix4x4 mvpMatrix;
+		Matrix4x4 normalMatrix;
+		Vector3 modelTranslation;
+		// model view matrix
+		mvMatrix.set(renderer->getModelViewMatrix()).multiply(renderer->getCameraMatrix());
+		// object to screen matrix
+		mvpMatrix.set(mvMatrix).multiply(renderer->getProjectionMatrix());
+		// normal matrix
+		normalMatrix.set(mvMatrix).invert().transpose();
+		// model translation
+		renderer->getModelViewMatrix().getTranslation(modelTranslation);
+		// upload
+		if (renderUniformMVMatrix != -1) renderer->setProgramUniformFloatMatrix4x4(context, renderUniformMVMatrix, mvMatrix.getArray());
+		renderer->setProgramUniformFloatMatrix4x4(context, renderUniformMVPMatrix, mvpMatrix.getArray());
+		renderer->setProgramUniformFloatMatrix4x4(context, renderUniformNormalMatrix, normalMatrix.getArray());
+		if (renderUniformModelTranslation != -1) renderer->setProgramUniformFloatVec3(context, renderUniformModelTranslation, modelTranslation.getArray());
 	}
 }
-void ShadowMappingShaderRenderBaseImplementation::setProgramMVMatrix(void* context, const Matrix4x4& mvMatrix)
-{
-	if (renderer->isInstancedRenderingAvailable() == true) return;
-	if (renderUniformMVMatrix == -1) return;
-	renderer->setProgramUniformFloatMatrix4x4(context, renderUniformMVMatrix, mvMatrix.getArray());
-}
-
-void ShadowMappingShaderRenderBaseImplementation::setProgramMVPMatrix(void* context, const Matrix4x4& mvpMatrix)
-{
-	if (renderer->isInstancedRenderingAvailable() == true) return;
-	renderer->setProgramUniformFloatMatrix4x4(context, renderUniformMVPMatrix, mvpMatrix.getArray());
-}
-
-void ShadowMappingShaderRenderBaseImplementation::setProgramNormalMatrix(void* context, const Matrix4x4& normalMatrix)
-{
-	if (renderer->isInstancedRenderingAvailable() == true) return;
-	renderer->setProgramUniformFloatMatrix4x4(context, renderUniformNormalMatrix, normalMatrix.getArray());
-}
 
 void ShadowMappingShaderRenderBaseImplementation::updateTextureMatrix(Renderer* renderer, void* context) {
 	renderer->setProgramUniformFloatMatrix3x3(context, uniformTextureMatrix, renderer->getTextureMatrix(context).getArray());
diff --git a/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderRenderBaseImplementation.h b/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderRenderBaseImplementation.h
index 01a7b1db..fb29ed36 100644
--- a/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderRenderBaseImplementation.h
+++ b/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderRenderBaseImplementation.h
@@ -38,6 +38,7 @@ protected:
 	int32_t renderUniformMVMatrix { -1 };
 	int32_t renderUniformMVPMatrix { -1 };
 	int32_t renderUniformNormalMatrix { -1 };
+	int32_t renderUniformModelTranslation { -1 };
 	int32_t uniformTextureMatrix { -1 };
 	int32_t uniformDiffuseTextureUnit { -1 };
 	int32_t uniformDiffuseTextureAvailable { -1 };
@@ -61,10 +62,7 @@ public:
 	virtual void initialize() override;
 	virtual void useProgram(Engine* engine, void* context) override;
 	virtual void unUseProgram(void* context) override;
-	virtual void setProgramViewMatrices(void* context) override;
-	virtual void setProgramMVMatrix(void* context, const Matrix4x4& mvMatrix) override;
-	virtual void setProgramMVPMatrix(void* context, const Matrix4x4& mvpMatrix) override;
-	virtual void setProgramNormalMatrix(void* context, const Matrix4x4& normalMatrix) override;
+	virtual void updateMatrices(void* context) override;
 	virtual void updateTextureMatrix(Renderer* renderer, void* context) override;
 	virtual void updateMaterial(Renderer* renderer, void* context) override;
 	virtual void updateLight(Renderer* renderer, void* context, int32_t lightId) override;
diff --git a/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderRenderImplementation.h b/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderRenderImplementation.h
index ce4449b4..a3292b7e 100644
--- a/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderRenderImplementation.h
+++ b/src/tdme/engine/subsystems/shadowmapping/ShadowMappingShaderRenderImplementation.h
@@ -45,32 +45,11 @@ struct tdme::engine::subsystems::shadowmapping::ShadowMappingShaderRenderImpleme
 	 */
 	virtual void unUseProgram(void* context) = 0;
 
-	/** 
-	 * Set up program projection and camera matrix
-	 * @param context contet
-	 */
-	virtual void setProgramViewMatrices(void* context) = 0;
-
 	/**
-	 * Set up program model view matrix
-	 * @param context contet
-	 * @param mvMatrix model view matrix
-	 */
-	virtual void setProgramMVMatrix(void* context, const Matrix4x4& mvMatrix) = 0;
-
-	/** 
-	 * Set up program mvp matrix
-	 * @param context contet
-	 * @param mvpMatrix mvp matrix
-	 */
-	virtual void setProgramMVPMatrix(void* context, const Matrix4x4& mvpMatrix) = 0;
-
-	/** 
-	 * Set up program normal matrix
-	 * @param context contet
-	 * @param normalMatrix normal matrix
+	 * Update matrices
+	 * @param context context
 	 */
-	virtual void setProgramNormalMatrix(void* context, const Matrix4x4& normalMatrix) = 0;
+	virtual void updateMatrices(void* context) = 0;
 
 	/**
 	 * Set up pre program texture matrix
diff --git a/src/tdme/tests/FoliageTest.cpp b/src/tdme/tests/FoliageTest.cpp
index a6fe2722..18065cd5 100644
--- a/src/tdme/tests/FoliageTest.cpp
+++ b/src/tdme/tests/FoliageTest.cpp
@@ -123,16 +123,29 @@ void FoliageTest::initialize()
 	auto reedModel = ModelReader::read("resources/tests/models/reed", "Mesh_Environment_Reed_06.fbx.tm");
 	auto foliageObject = new Object3DRenderGroup("foliage", reedModel);
 	int reedIdx = 0;
-	for (float z = -20.0f; z < 20.0f;) {
-		for (float x = -20.0f; x < 20.0f;) {
-			Transformations transformations;
-			transformations.setTranslation(Vector3(x, 0.0f, z));
-			transformations.update();
-			foliageObject->addObject(transformations);
-			x+= Math::random() * 0.5f + 0.5;
+	#if defined(GLES2)
+		for (float z = -10.0f; z < 10.0f;) {
+			for (float x = -10.0f; x < 10.0f;) {
+				Transformations transformations;
+				transformations.setTranslation(Vector3(x, 0.0f, z));
+				transformations.update();
+				foliageObject->addObject(transformations);
+				x+= Math::random() * 1.0f + 1.0;
+			}
+			z+= Math::random() * 1.0f + 1.0;
 		}
-		z+= Math::random() * 0.75f + 0.25;
-	}
+	#else
+		for (float z = -20.0f; z < 20.0f;) {
+			for (float x = -20.0f; x < 20.0f;) {
+				Transformations transformations;
+				transformations.setTranslation(Vector3(x, 0.0f, z));
+				transformations.update();
+				foliageObject->addObject(transformations);
+				x+= Math::random() * 0.5f + 0.5;
+			}
+			z+= Math::random() * 0.5f + 0.5;
+		}
+	#endif
 	foliageObject->setShader("foliage");
 	foliageObject->updateRenderGroup();
 	engine->addEntity(foliageObject);
