diff --git a/src/tdme/engine/Camera.cpp b/src/tdme/engine/Camera.cpp
index 08102aa9..299e21d4 100644
--- a/src/tdme/engine/Camera.cpp
+++ b/src/tdme/engine/Camera.cpp
@@ -25,6 +25,8 @@ Camera::Camera(Renderer* renderer)
 	zNear = 0.1f;
 	zFar = 150.0f;
 	cameraMode = CAMERAMODE_LOOKAT;
+	frustumMode = FRUSTUMMODE_PERSPECTIVE;
+	orthographicFrustumScale = 1.0f;
 	upVector.set(0.0f, 1.0f, 0.0f);
 	forwardVector.set(0.0f, 0.0f, 1.0f);
 	sideVector.set(1.0f, 0.0f, 0.0f);
@@ -64,33 +66,65 @@ Vector3 Camera::computeUpVector(const Vector3& lookFrom, const Vector3& lookAt)
 Matrix4x4& Camera::computeProjectionMatrix()
 {
 	// see: see http://www.songho.ca/opengl/gl_transform.html
-	auto tangent = static_cast<float>(Math::tan(fovY / 2.0f * 3.1415927f / 180.0f));
-	auto height = zNear * tangent;
-	auto width = height * aspect;
-	return computeFrustumMatrix(-width, width, -height, height, zNear, zFar);
-}
-
-Matrix4x4& Camera::computeFrustumMatrix(float leftPlane, float rightPlane, float bottomPlane, float topPlane, float nearPlane, float farPlane)
-{
-	// see: http://www.songho.ca/opengl/gl_transform.html
-	return projectionMatrix.set(
-		2.0f * nearPlane / (rightPlane - leftPlane),
-		0.0f,
-		0.0f,
-		0.0f,
-		0.0f,
-		2.0f * nearPlane / (topPlane - bottomPlane),
-		0.0f,
-		0.0f,
-		(rightPlane + leftPlane) / (rightPlane - leftPlane),
-		(topPlane + bottomPlane) / (topPlane - bottomPlane),
-		-(farPlane + nearPlane) / (farPlane - nearPlane),
-		-1.0f,
-		0.0f,
-		0.0f,
-		-(2.0f * farPlane * nearPlane) / (farPlane - nearPlane),
-		1.0f
-	);
+	switch(frustumMode) {
+		case FRUSTUMMODE_ORTHOGRAPHIC:
+			{
+				auto leftPlane = (-width / 2.0f) * orthographicFrustumScale;
+				auto rightPlane = (width / 2.0f) * orthographicFrustumScale;
+				auto topPlane = (height / 2.0f) * orthographicFrustumScale;
+				auto bottomPlane = (-height / 2.0f) * orthographicFrustumScale;
+				auto nearPlane = zNear;
+				auto farPlane = zFar;
+				return projectionMatrix.set(
+					2.0f / (rightPlane - leftPlane),
+					0.0f,
+					0.0f,
+					0.0f,
+					0.0f,
+					2.0f / (topPlane - bottomPlane),
+					0.0f,
+					0.0f,
+					0.0f,
+					0.0f,
+					-2.0f / (farPlane - nearPlane),
+					0.0f,
+					-(rightPlane + leftPlane) / (rightPlane - leftPlane),
+					-(topPlane + bottomPlane) / (topPlane - bottomPlane),
+					-(farPlane + nearPlane) / (farPlane - nearPlane),
+					1.0f
+				);
+			}
+		default:
+			{
+				auto tangent = static_cast<float>(Math::tan(fovY / 2.0f * 3.1415927f / 180.0f));
+				auto height = zNear * tangent;
+				auto width = height * aspect;
+				auto leftPlane = -width;
+				auto rightPlane = width;
+				auto topPlane = height;
+				auto bottomPlane = -height;
+				auto nearPlane = zNear;
+				auto farPlane = zFar;
+				return projectionMatrix.set(
+					2.0f * nearPlane / (rightPlane - leftPlane),
+					0.0f,
+					0.0f,
+					0.0f,
+					0.0f,
+					2.0f * nearPlane / (topPlane - bottomPlane),
+					0.0f,
+					0.0f,
+					(rightPlane + leftPlane) / (rightPlane - leftPlane),
+					(topPlane + bottomPlane) / (topPlane - bottomPlane),
+					-(farPlane + nearPlane) / (farPlane - nearPlane),
+					-1.0f,
+					0.0f,
+					0.0f,
+					-(2.0f * farPlane * nearPlane) / (farPlane - nearPlane),
+					1.0f
+				);
+			}
+	}
 }
 
 Matrix4x4& Camera::computeModelViewMatrix()
diff --git a/src/tdme/engine/Camera.h b/src/tdme/engine/Camera.h
index adc8ceee..8d09b036 100644
--- a/src/tdme/engine/Camera.h
+++ b/src/tdme/engine/Camera.h
@@ -21,6 +21,7 @@ using tdme::math::Vector3;
 class tdme::engine::Camera final
 {
 public:
+	enum FrustumMode { FRUSTUMMODE_PERSPECTIVE, FRUSTUMMODE_ORTHOGRAPHIC };
 	enum CameraMode { CAMERAMODE_LOOKAT, CAMERAMODE_NONE };
 
 private:
@@ -33,6 +34,8 @@ private:
 	float zNear;
 	float zFar;
 	CameraMode cameraMode;
+	FrustumMode frustumMode;
+	float orthographicFrustumScale;
 	Vector3 lookFrom;
 	Vector3 lookAt;
 	Vector3 upVector;
@@ -96,6 +99,36 @@ public:
 		this->cameraMode = cameraMode;
 	}
 
+	/**
+	 * @return frustum mode
+	 */
+	inline FrustumMode getFrustumMode() const {
+		return frustumMode;
+	}
+
+	/**
+	 * Set frustum mode
+	 * @param frustum mode
+	 */
+	inline void setFrustumMode(FrustumMode frustumMode) {
+		this->frustumMode = frustumMode;
+	}
+
+	/**
+	 * @return orthographic frustum scale
+	 */
+	inline float getOrthographicFrustumScale() const {
+		return orthographicFrustumScale;
+	}
+
+	/**
+	 * Set orthographic frustum scale
+	 * @param orthographicFrustumScale orthographic frustum scale
+	 */
+	inline void setOrthographicFrustumScale(float orthographicFrustumScale) {
+		this->orthographicFrustumScale = orthographicFrustumScale;
+	}
+
 	/**
 	 * @return field of view Y
 	 */
@@ -336,18 +369,6 @@ private:
 	 */
 	Matrix4x4& computeProjectionMatrix();
 
-	/**
-	 * Computes frustum matrix
-	 * @param leftPlane left plane
-	 * @param rightPlane right plane
-	 * @param bottomPlane top plane
-	 * @param topPlane bottom plane
-	 * @param nearPlane near plane
-	 * @param farPlane far plane
-	 * @return frustum matrix
-	 */
-	Matrix4x4& computeFrustumMatrix(float leftPlane, float rightPlane, float bottomPlane, float topPlane, float nearPlane, float farPlane);
-
 	/**
 	 * Computes projection matrix for given look from, look at and up vector
 	 * @return model view matrix
diff --git a/src/tdme/engine/subsystems/shadowmapping/ShadowMap.cpp b/src/tdme/engine/subsystems/shadowmapping/ShadowMap.cpp
index b63c738f..cd898863 100644
--- a/src/tdme/engine/subsystems/shadowmapping/ShadowMap.cpp
+++ b/src/tdme/engine/subsystems/shadowmapping/ShadowMap.cpp
@@ -113,11 +113,92 @@ void ShadowMap::createShadowMap(Light* light)
 	// TODO: object->preRender only uses default context, lets see how to make this multithreaded
 	auto context = shadowMapping->renderer->getDefaultContext();
 
+	//
+	auto camera = shadowMapping->engine->getCamera();
+
+	// try to determine light position
+	// 	left
+	auto left = camera->getModelViewProjectionInvertedMatrix().multiply(
+		Vector4(
+			(2.0f * 0.0f) - 1.0f,
+			1.0f - (2.0f * 0.5f),
+			2.0f * 0.997f - 1.0f,
+			1.0f
+		)
+	);
+	left.scale(1.0f / left.getW());
+
+	//	right
+	auto right = camera->getModelViewProjectionInvertedMatrix().multiply(
+		Vector4(
+			(2.0f * 1.0f) - 1.0f,
+			1.0f - (2.0f * 0.5f),
+			2.0f * 0.997f - 1.0f,
+			1.0f
+		)
+	);
+	right.scale(1.0f / right.getW());
+
+	//	center
+	auto center4 = camera->getModelViewProjectionInvertedMatrix().multiply(
+		Vector4(
+			(2.0f * 0.5f) - 1.0f,
+			1.0f - (2.0f * 1.0f),
+			2.0f * 0.5f - 1.0f,
+			1.0f
+		)
+	);
+	center4.scale(1.0f / center4.getW());
+
+	// so we get some contraints for the shadow map camera, TODO: improve me
+	Vector3 center(Vector3(center4.getX(), center4.getY(), center4.getZ()));
+	auto width = Vector3(right.getX(), right.getY(), right.getZ()).sub(Vector3(left.getX(), left.getY(), left.getZ())).computeLength() * shadowMapping->engine->getShadowMapLightEyeDistanceScale();
+	width*= 1.0f;
+
+	// light camera
+	Vector3 lightDirection;
+	Vector3 lightLookFrom;
+	// compute camera from view of light
+	lightDirection.set(light->getSpotDirection()).normalize();
+	lightLookFrom
+		.set(center)
+		.sub(lightDirection.clone().scale(width));
+	/*
+	Console::println(
+		to_string(lightLookFrom.getX()) + ", " +
+		to_string(lightLookFrom.getY()) + ", " +
+		to_string(lightLookFrom.getZ())
+	);
+	Console::println(
+		to_string(width) + " <> " +
+		to_string(frameBuffer->getWidth()) + " x " +
+		to_string(frameBuffer->getHeight()) + ": " +
+		to_string(width / frameBuffer->getWidth())
+	);
+	*/
+	// set up light camera from view of light
+	Vector3 lightCameraUpVector;
+	Vector3 lightCameraSideVector;
+	lightCamera->setFrustumMode(Camera::FRUSTUMMODE_ORTHOGRAPHIC);
+	lightCamera->setOrthographicFrustumScale((width / frameBuffer->getWidth()) / 1.25f);
+	lightCamera->setZNear(camera->getZNear());
+	lightCamera->setZFar(500.0f);
+	lightCamera->setLookFrom(lightLookFrom);
+	lightCamera->setForwardVector(lightDirection);
+	lightCamera->setSideVector(Vector3(1.0f, 0.0f, 0.0f));
+	// TODO: fix cross product NaN if side vector == forward vector
+	lightCameraUpVector = Vector3::computeCrossProduct(lightCamera->getForwardVector(), lightCamera->getSideVector());
+	lightCamera->setUpVector(lightCameraUpVector);
+	lightCameraSideVector = Vector3::computeCrossProduct(lightCamera->getForwardVector(), lightCamera->getUpVector());
+	lightCamera->setSideVector(lightCameraSideVector);
+	lightCamera->setUpVector(lightCameraUpVector);
+	lightCamera->update(context, frameBuffer->getWidth(), frameBuffer->getHeight());
+
 	// clear visible objects
 	visibleObjects.clear();
 
 	// determine visible objects and objects that should generate a shadow
-	for (auto entity: shadowMapping->engine->getPartition()->getVisibleEntities(shadowMapping->engine->getCamera()->getFrustum())) {
+	for (auto entity: shadowMapping->engine->getPartition()->getVisibleEntities(lightCamera->getFrustum())) {
 		switch (entity->getEntityType()) {
 			case Entity::ENTITYTYPE_OBJECT3DRENDERGROUP:
 				{
@@ -211,71 +292,6 @@ void ShadowMap::createShadowMap(Light* light)
 		}
 	}
 
-	//
-	auto camera = shadowMapping->engine->getCamera();
-
-	// try to determine light position
-
-	// 	left
-	auto left = camera->getModelViewProjectionInvertedMatrix().multiply(
-		Vector4(
-			(2.0f * 0.0f) - 1.0f,
-			1.0f - (2.0f * 0.5f),
-			2.0f * 0.997f - 1.0f,
-			1.0f
-		)
-	);
-	left.scale(1.0f / left.getW());
-
-	//	right
-	auto right = camera->getModelViewProjectionInvertedMatrix().multiply(
-		Vector4(
-			(2.0f * 1.0f) - 1.0f,
-			1.0f - (2.0f * 0.5f),
-			2.0f * 0.997f - 1.0f,
-			1.0f
-		)
-	);
-	right.scale(1.0f / right.getW());
-
-	//	center
-	auto center4 = camera->getModelViewProjectionInvertedMatrix().multiply(
-		Vector4(
-			(2.0f * 0.5f) - 1.0f,
-			1.0f - (2.0f * 1.0f),
-			2.0f * 0.5f - 1.0f,
-			1.0f
-		)
-	);
-	center4.scale(1.0f / center4.getW());
-
-	// so we get some contraints for the shadow map camera, TODO: improve me
-	Vector3 center(Vector3(center4.getX(), center4.getY(), center4.getZ()));
-	auto width = Vector3(right.getX(), right.getY(), right.getZ()).sub(Vector3(left.getX(), left.getY(), left.getZ())).computeLength() * shadowMapping->engine->getShadowMapLightEyeDistanceScale();
-
-	// viewers camera
-	Vector3 lightDirection;
-	Vector3 lightLookFrom;
-	// compute camera from view of light
-	lightDirection.set(light->getSpotDirection()).normalize();
-	lightLookFrom
-		.set(center)
-		.sub(lightDirection.clone().scale(width * 1.25f));
-	// set up light camera from view of light
-	Vector3 lightCameraUpVector;
-	Vector3 lightCameraSideVector;
-	lightCamera->setZNear(camera->getZNear());
-	lightCamera->setZFar(150.0f);
-	lightCamera->setLookFrom(lightLookFrom);
-	lightCamera->setForwardVector(lightDirection);
-	lightCamera->setSideVector(Vector3(1.0f, 0.0f, 0.0f));
-	// TODO: fix cross product NaN if side vector == forward vector
-	lightCameraUpVector = Vector3::computeCrossProduct(lightCamera->getForwardVector(), lightCamera->getSideVector());
-	lightCamera->setUpVector(lightCameraUpVector);
-	lightCameraSideVector = Vector3::computeCrossProduct(lightCamera->getForwardVector(), lightCamera->getUpVector());
-	lightCamera->setSideVector(lightCameraSideVector);
-	lightCamera->setUpVector(lightCameraUpVector);
-	lightCamera->update(context, frameBuffer->getWidth(), frameBuffer->getHeight());
 	// bind frame buffer
 	frameBuffer->enableFrameBuffer();
 	// clear depth buffer
diff --git a/src/tdme/engine/subsystems/shadowmapping/ShadowMapping.h b/src/tdme/engine/subsystems/shadowmapping/ShadowMapping.h
index f9985fee..f0f9077b 100644
--- a/src/tdme/engine/subsystems/shadowmapping/ShadowMapping.h
+++ b/src/tdme/engine/subsystems/shadowmapping/ShadowMapping.h
@@ -28,6 +28,7 @@ using tdme::math::Vector4;
  */
 class tdme::engine::subsystems::shadowmapping::ShadowMapping final
 {
+	friend class tdme::engine::Engine;
 	friend class ShadowMap;
 
 private:
